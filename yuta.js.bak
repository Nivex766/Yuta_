/*Bom YutaBot-MD aqui né KKK, eu vendi apenas o bot e não os direitos então por gentileza use outro nome... Bot 100% descirotografado pra vc, e por favor não vaze ou revenda o bot, todos os direitos ainda estão sobre mim: vulgo Nk*/

const scget = require('@lmonly/scget');

//=============[ COMEÇO DE TUDO ]=============\\
const { downloadContentFromMessage, relayWAMessage, mentionedJid, processTime, MediaType, Browser, MessageType, Presence, Mimetype, Browsers, delay, getLastMessageInChat, WA_DEFAULT_EPHEMERAL, generateWAMessageFromContent, proto, logger, makeInMemoryStore, getContentType, INativeFlowMessage, prepareWAMessageMedia } = require('@whiskeysockets/baileys');

const { fs, Boom, axios, crypto, util, P, linkfy, request, cheerio, ms, ffmpeg, qrterminal, exec, spawn, execSync, moment, color, time, hora, date, getBuffer, convertSticker, recognize, fetchJson, fetchText, fetch, getBase64, createExif, writeExifImg, upload, nit, addBanned, unBanned, BannedExpired, cekBannedUser, validmove, setGame, addComandosId, deleteComandos, getComandoBlock, getComandos, addComandos, palavrasANA, quizanimais, garticArchives, whatMusicAr, enigmaArchive, quizFutebol, getpc, supre, wait, getExtension, generateMessageID, vyroEngine, getGroupAdmins, getMembros, emoji, sendPoll, getRandom, banner2, banner3, temporizador, chyt, kyun, TimeCount, simih, botoff, colors, os, arcloud, addFilter, isFiltered, ytdl, psycatgames, MultiDownload, AssemblyAI, obeso, countDays, timeDate, Limit_CMD, capitalizeFirstLetter, shuffle, pushnames, formatNumber, formatNumberDecimal, awaitMessage, listCommands, extractMetadata, extractDDD, extractStateFromNumber, extractStateFromDDD, obrigadoEXT, addNumberMais, identArroba } = require('./exports.js');

//SEPARANDO AKI
const directory = `./DADOS DO YUTA/anti_sp.json`;

const ANT_SP = JSON.parse(fs.readFileSync(directory));
//////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\\

const yts = require('yt-search');
//Database

/////////////////\\\\\\\\\\\\\\\\\\\\\\
const { linguagem, MENU, mess, getInfo, destrava, destrava2, tabela, namoro1, namoro2, tools, advices, ban, joguinhodavelhajs, joguinhodavelhajs2, nescessario, setting, logoslink, ftmenu, vip, rgtake, muted, countMessage, sendVideoAsSticker, sendImageAsSticker, sendVideoAsSticker2, sendImageAsSticker2, sotoy, daily, comandos, limitefll, anotar, enviarfiguUrl, getFileBuffer, DLT_FL, speed, sleep, ANT_LTR_MD_EMJ, packname, getName, chaves, grupos } = require('./exports.js');

const { botoes, antipv, antipv2, antipv3, visualizarmsg, numero_dono1, numero_dono2, numero_dono3, numero_dono4, numero_dono5, numero_dono6, msgantipv1, msgantipv2, API_KEY_INVERTEXTO } = require("./INFO_YUTA/media/nescessario.json");

const { NomeDoBot, ownerName, prefix, channel, channelnk, group, CREDENTIALS_USER } = require('./INFO_YUTA/DADOS/INFO_YUTA.json');

const { audio_menu, bom_dia, boa_tarde, boa_noite, corno, qviado } = require('./INFO_YUTA/media/audios.json');

const palavras = JSON.parse(fs.readFileSync('./INFO_YUTA/forca/palavras.json'));

const timestamp = speed()
const latensi = speed() - timestamp

//Importando as funções necessárias
const forca = require('./INFO_YUTA/forca/index.js');



//Bonequinho da forca
const frames = JSON.parse(fs.readFileSync('./INFO_YUTA/forca/frames.json'));

//Fim lk
const { genyt } = require('genytdl-core');


const { sendButton, sendListB } = require(`./ARQUIVES/funcoes/botoes.js`)

const { fundo1, fundo2, imgnazista, imggay, imgcorno, imggostosa, imggostoso, imgfeio, imgvesgo, imgbebado, imggado, matarcmd, deathcmd, beijocmd, chutecmd, tapacmd, rnkgay, rnkgado, cmdmenu, rnkcorno, rnkgostoso, rnkgostosa, rnknazista, rnkotaku, rnkpau, suruba, minado_bomb, thumbnail, imgsigma, imgbeta, imgbaiano, imgbaiana, imgcarioca, imglouco, imglouca, imgsafada, imgsafado, imgmacaco, imgmacaca, imgputa, rnksigma, rnkbeta, rnkbaiano, rnkbaiana, rnkcarioca, rnklouco, rnklouca, rnksafada, rnksafado, rnkmacaco, rnkmacaca, errocmd, rnkputa } = require("./INFO_YUTA/LOGOS/links_img.json");

const II = "```";

var numerodono_ofc = setting.ownerNumber.replace(new RegExp("[()+-/ +/]", "gi"), "");

process.on('uncaughtException', function (err) {
console.error((new Date).toUTCString() + ' uncaughtException:', err.message);
console.error(err.stack);
});

const API_KEY_YUTA2 = CREDENTIALS_USER.API_KEY_YUTA || "SemApikey";
const API_URL = CREDENTIALS_USER.API_URL || "https://api.minhabucetinha.com.br";

const API_KEY_JEFF = 'COMPRAR_SUA_KEY_KKKKK';

const API_KEY_BRONXYS = 'KEY_RAFAEL_RF-ALEA_26/05';

const API_KEY_YUTA = 'COMPRAR_SUA_KEY_KKKKK';

const SANDRO_MD = 'COMPRAR_SUA_KEY_KKKKK';

// ABAIXO: INÍCIO DE CONEXÃO

async function startyuta() {

const data = {};

const getGpInfo = async (from, { groupMetadata }) => {
    if (data[from]) {
        return data[from];
    }

    const yuta = await groupMetadata(from);
    data[from] = yuta;

    return yuta;
};

module.exports = yuta = async(upsert, yuta, qrcode) => {
async function startFunctionNaga() {

const nmrdn_dono2 = setting.ownerNumber.replace(new RegExp("[()+-/ +/]", "gi"), "") + "@s.whatsapp.net";

const ownerNumber = setting.ownerNumber.replace(new RegExp("[()+-/ +/]", "gi"), "")

for (const info of upsert?.messages || []) {

const from = info.key.remoteJid;
const isGroup = from.endsWith('@g.us');
const isStatus = from.endsWith('@broadcast');

const VRF_JSON_GRUPO = fs.existsSync(`./DADOS DO YUTA/grupos/ATIVAÇÕES-YUTA/${from}.json`) ? true : false;

if(VRF_JSON_GRUPO) {
var jsonGp = JSON.parse(fs.readFileSync(`./DADOS DO YUTA/grupos/ATIVAÇÕES-YUTA/${from}.json`));
}

function createPaymentDetails(text, mentionedJidArray, participant) {
return {
requestPaymentMessage: {
currencyCodeIso4217: "BRL",
amount1000: "100000000000000000",
noteMessage: {
extendedTextMessage: {
text,
contextInfo: {
mentionedJid: [...mentionedJidArray, participant],
forwardingScore: 999,
isForwarded: true
}
}
},
expiryTimestamp: "0",
amount: {
value: "100000000000000000",
offset: 100000000000000000,
currencyCode: "BRL"
}
}
};
}

if (VRF_JSON_GRUPO && jsonGp[0].x9 && info.messageStubType) {
    switch (info.messageStubType) {
        case 29: // Promoção de membro
            if (info.messageStubParameters?.length) {
                const promotedMembers = [info.messageStubParameters[0]];
                const promotionPaymentDetails = createPaymentDetails(
                    `⚠️ 𝐀𝐕𝐈𝐒𝐎 𝐈𝐌𝐏𝐎𝐑𝐓𝐀𝐍𝐓𝐄 ⚠️

*ᴏ ᴜsᴜᴀʀɪᴏ: @${info.messageStubParameters[0].split("@")[0]} ⁣ғᴏɪ ᴘʀᴏᴍᴏᴠɪᴅᴏ ᴀ ᴀᴅᴍ.* 🙆‍♂️

*ᴀᴅᴍ ʀᴇsᴘᴏɴsᴀ́ᴠᴇʟ: @${info.participant.split("@")[0]}* ⁣🙅‍♂️`,
                    promotedMembers,
                    info.participant
                );
                await yuta.relayMessage(from, promotionPaymentDetails, {});
            }
            break;

        case 30: // Rebaixamento de membro
            if (info.messageStubParameters?.length) {
                const demotedMembers = [info.messageStubParameters[0]];
                const demotionPaymentDetails = createPaymentDetails(
                    `⚠️ 𝐀𝐕𝐈𝐒𝐎 𝐈𝐌𝐏𝐎𝐑𝐓𝐀𝐍𝐓𝐄 ⚠️

*ᴏ ᴜsᴜᴀʀɪᴏ: @${info.messageStubParameters[0].split("@")[0]} ⁣ғᴏɪ ʀᴇʙᴀɪxᴀᴅᴏ ᴀ ᴍᴇᴍʙʀᴏ ᴄᴏᴍᴜᴍ.* 🙆‍♂️

*ᴀᴅᴍ ʀᴇsᴘᴏɴsᴀ́ᴠᴇʟ: @${info.participant.split("@")[0]}* ⁣🙅‍♂️`,
                    demotedMembers,
                    info.participant
                );
                await yuta.relayMessage(from, demotionPaymentDetails, {});
            }
            break;
    }
}

if(!info.message) return;
if(upsert.type == "append") return;  
const baileys = require('@whiskeysockets/baileys');
const type = baileys.getContentType(info.message);
const content = JSON.stringify(info.message);
const pushname = info.pushName ? info.pushName : '';

if(visualizarmsg) {
await yuta.readMessages([info.key]);
} else {
if(from == "status@broadcast") return;
}

global.prefix;
global.blocked;


//==============(BODY)================\\

var body = info.message?.conversation || info.message?.sendPaymentMessage?.noteMessage?.extendedTextMessage?.text || info.message?.requestPaymentMessage?.noteMessage?.extendedTextMessage?.text || info.message?.viewOnceMessageV2?.message?.imageMessage?.caption || info.message?.viewOnceMessageV2?.message?.videoMessage?.caption || info.message?.imageMessage?.caption || info.message?.videoMessage?.caption || info.message?.extendedTextMessage?.text || info.message?.viewOnceMessage?.message?.videoMessage?.caption || info.message?.viewOnceMessage?.message?.imageMessage?.caption || info.message?.documentWithCaptionMessage?.message?.documentMessage?.caption || info.message?.buttonsMessage?.imageMessage?.caption || info.message?.buttonsResponseMessage?.selectedButtonId || info.message?.listResponseMessage?.singleSelectReply?.selectedRowId || info.message?.templateButtonReplyMessage?.selectedId || info?.text || info.message?.editedMessage?.message?.protocolMessage?.editedMessage?.extendedTextMessage?.text || info.message?.editedMessage?.message?.protocolMessage?.editedMessage?.imageMessage?.caption || info.message?.conversation || info.message?.viewOnceMessageV2?.message?.imageMessage?.caption || info.message?.viewOnceMessageV2?.message?.videoMessage?.caption || info.message?.imageMessage?.caption || info.message?.videoMessage?.caption || info.message?.extendedTextMessage?.text || info.message?.viewOnceMessage?.message?.videoMessage?.caption || info.message?.viewOnceMessage?.message?.imageMessage?.caption || info.message?.documentWithCaptionMessage?.message?.documentMessage?.caption || info.message?.buttonsMessage?.imageMessage?.caption || info.message?.buttonsResponseMessage?.selectedButtonId || info.message?.listResponseMessage?.singleSelectReply?.selectedRowId || info.message?.templateButtonReplyMessage?.selectedId || JSON.parse(info.message?.interactiveResponseMessage?.nativeFlowResponseMessage?.paramsJson || '{}')?.id ||
           info?.text || '';

var Procurar_String = info.message?.conversation || info.message?.viewOnceMessageV2?.message?.imageMessage?.caption || info.message?.viewOnceMessageV2?.message?.videoMessage?.caption || info.message?.imageMessage?.caption || info.message?.videoMessage?.caption || info.message?.extendedTextMessage?.text || info.message?.viewOnceMessage?.message?.videoMessage?.caption || info.message?.viewOnceMessage?.message?.imageMessage?.caption || info.message?.documentWithCaptionMessage?.message?.documentMessage?.caption || info.message?.buttonsMessage?.imageMessage?.caption || ""

const args = body.trim().split(/ +/).slice(1);

const budy2 = body.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "");

if(isGroup && fs.existsSync(`./DADOS DO YUTA/grupos/ATIVAÇÕES-YUTA/${from}.json`) && jsonGp[0].multiprefix) {
var prefix = jsonGp[0]?.prefixos[jsonGp[0]?.prefixos?.indexOf(String(body)?.trim()?.charAt(0))] || jsonGp[0].prefixos[0]
}

if(isGroup && fs.existsSync(`./DADOS DO YUTA/grupos/ATIVAÇÕES-YUTA/${from}.json`) && !jsonGp[0].multiprefix) {var prefix = setting.prefix} else if(!isGroup) {var prefix = setting.prefix};

var isCmd = body.trim().startsWith(prefix);

const command = isCmd ? budy2.trim().slice(1).split(/ +/).shift().toLocaleLowerCase(): null;

const q_2 = budy2.trim().split(/ +/).slice(1).join(' ');

const q = args.join(' ');

var budy = (type === 'conversation') ? info.message?.conversation : (type === 'extendedTextMessage') ? info.message?.extendedTextMessage?.text : '';

var budy3 = budy.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "");

var PR_String = Procurar_String.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "");

const q_ofc = PR_String.trim().split(/ +/).slice(1).join(" ");

try {var groupMetadata = isGroup ?  await yuta.groupMetadata(from): ""} catch {return}

const groupName = isGroup ? groupMetadata.subject : '';

const sender = isGroup ? info.key.participant.includes(':') ? info.key.participant.split(':')[0] +'@s.whatsapp.net': info.key.participant : info.key.remoteJid;

const messagesC = PR_String.slice(0).trim().split(/ +/).shift().toLowerCase();

const arg = body.substring(body.indexOf(' ') + 1);

const botNumber = await yuta.user.id.split(':')[0]+'@s.whatsapp.net';

//MESMA DA DE CIMA.
const NumeroDoBot = yuta.user.id.split(':')[0]

//SE SOU EU: A BOT
const itsMe = info.sender == botNumber ? true : false

//MESMA DA DE CIMA 
const SouEuNe = info.sender == botNumber ? true : false

const argss = body.split(/ +/g);
const testat = body;
const ants = body;

const groupDesc = isGroup ? groupMetadata.desc : ''

const groupMembers = isGroup ? groupMetadata.participants : ''

const isnit = nit.includes(sender) 

const issupre = supre.includes(sender)

const ischyt = chyt.includes(sender)

const groupAdmins = isGroup ? getGroupAdmins(groupMembers) : ''

const somembros = isGroup ? getMembros(groupMembers) : ''

function setObg(index){
fs.writeFileSync(nescj, JSON.stringify(index, null, 2) + '\n')}

//======================================\\

const nmrdn = setting.ownerNumber.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net` || isnit

const numerodono = [`${nmrdn}`, `${numero_dono1}@s.whatsapp.net`, `${numero_dono2}@s.whatsapp.net`, `${numero_dono3}@s.whatsapp.net`, `${numero_dono4}@s.whatsapp.net`, `${numero_dono5}@s.whatsapp.net`, `${numero_dono6}@s.whatsapp.net`]

//=====================================\\

//=================> Funções de Grupo 🥋

const dirGroup = `./DADOS DO YUTA/grupos/ATIVAÇÕES-YUTA/${from}.json`

const nescj = "./INFO_YUTA/media/nescessario.json"

if(isGroup && !fs.existsSync(dirGroup)){
var data = [{
    name: groupName,
    groupId: from, 
    x9: false, 
    antiimg: false, 
    antivideo: false,
    antiaudio: false, 
    antisticker: false,
    antidoc: false,
    antictt: false,
    antiloc: false, 
    antilinkgp: false,
    antilinkhard: false, 
    antilinkeasy: false, 
    antifake: false, 
    antiporn: false,
    Odelete: false, 
    antinotas: false, 
    anticatalogo: false, 
    visuUnica: false, 
    registrarFIGUS: false, 
    soadm: false, 
    listanegra: [], 
    advertir: [], 
    prefixos: [`${setting.prefix}`],
    advertir2: [], 
    legenda_estrangeiro: "0",
    legenda_documento: "0", 
    legenda_video: "0",
    legenda_imagem: "0", 
    multiprefix: false, 
    ausentes: [], 
    ANTI_DDD: {
      active: false,
      listaProibidos: []
    },
    antipalavrao: {
        active: false,
        palavras: []
     },
     limitec: {
        active: false,
        quantidade: null
     },
    wellcome: [{
        bemvindo1: false,
        legendabv: `✨ 𝙾𝙻𝙰 #numerodele# 𝚂𝙴𝙹𝙰 𝙱𝙴𝙼 𝚅𝙸𝙽𝙳𝙾[ 𝙰 ] 𝙰𝙾 𝙶𝚁𝚄𝙿𝙾   #nomedogp#\n\n• 𝙻𝙴𝙸𝙰 𝙰𝚂 𝚁𝙴𝙶𝚁𝙰𝚂 𝙴 𝙰𝙿𝚁𝙾𝚅𝙴𝙸𝚃𝙴 𝙾 𝙶𝚁𝚄𝙿𝙾\n> ${NomeDoBot}`,
        legendasaiu: 0
      },
      {
        bemvindo2: false,
        legendabv: `✨ 𝙾𝙻𝙰 #numerodele# 𝚂𝙴𝙹𝙰 𝙱𝙴𝙼 𝚅𝙸𝙽𝙳𝙾[ 𝙰 ] 𝙰𝙾 𝙶𝚁𝚄𝙿𝙾   #nomedogp#\n\n• 𝙻𝙴𝙸𝙰 𝙰𝚂 𝚁𝙴𝙶𝚁𝙰𝚂 𝙴 𝙰𝙿𝚁𝙾𝚅𝙴𝙸𝚃𝙴 𝙾 𝙶𝚁𝚄𝙿𝙾\n> ${NomeDoBot}`,
        legendasaiu: 0
      }],
    simi1: false, 
    autosticker: false, 
    autoresposta: false,
    jogos: false, 
    bangp: false, 
    modo_rpg: false
}]
    fs.writeFileSync(dirGroup, JSON.stringify(data, null, 2) + '\n')
}

const dataGp = isGroup ? JSON.parse(fs.readFileSync(dirGroup)) : undefined 

var DFNMULTIP = `./DADOS DO YUTA/func/prefixo/multip_${from}.json`

function setGp(index){
fs.writeFileSync(dirGroup, JSON.stringify(index, null, 2) + '\n')}

function setNes(index){
fs.writeFileSync(nescj, JSON.stringify(index, null, 2) + '\n')}

//=====(ADMS/DONO/ETC..CONST)=======\\

const adivinha = info.key.id.length > 21 ? 'Android 🚀' : info.key.id.substring(0, 2) == '3A' ? 'Iphone 💸' : 'WhatsApp Web 🪀';

const quoted = info.quoted ? info.quoted : info

const isBot = info.key.fromMe ? true : false

const SoDono = numerodono.includes(sender) || isBot || isnit || issupre || ischyt

dfndofc = setting.ownerNumber+"@s.whatsapp.net"

const DonoOficial = dfndofc.includes(sender) 

const isVip = vip.map(i => i.id).includes(sender) || SoDono

const isBotGroupAdmins = groupAdmins.includes(botNumber) || false

const isGroupAdmins = groupAdmins.includes(sender) || false || DonoOficial

const isListaBrancaG = nescessario.listabrancaG.includes(sender)

const isBanned = ban.includes(sender)

const isVisualizar = nescessario.visualizarmsg

const isVerificado = nescessario.verificado

const isConsole = obrigadoEXT.consoleoff

const isWelcomePrivate = nescessario.welcomepv

const isAudioMenu = obrigadoEXT.menu_audio

const isAntiPv = nescessario.antipv 

const isAntiPv2 = nescessario.antipv2

const isAntiPv3 = nescessario.antipv3

const isBotoff = nescessario.botoff

const listanegraG = nescessario.listanegraG

const listabrancaG = nescessario.listabrancaG

const isAnticall = nescessario.anticall

const TOKEN_GPT = nescessario.TOKEN_GPT

const isCmdVip = nescessario.cmd_vip

const isblockCmdG = nescessario.blockCmdG

const isCargo = SoDono ? "Mestre" : isGroupAdmins ? "Adminstrador": "Membro"

const isChVip = isVip ? "ꜱɪᴍ ✅": "ɴᴀᴏ ❌"


//============(FUNÇÕES)============\\

const isJoguin = isGroup ? joguinhodavelhajs.includes(sender) : false

const isAntiImg = isGroup ? dataGp[0].antiimg : undefined

const isLimitCmd = isGroup ? dataGp[0]?.Limitar_CMD : undefined

const isAntiVid = isGroup ? dataGp[0].antivideo : undefined

const isAntiAudio = isGroup ? dataGp[0].antiaudio : undefined

const isAntiSticker = isGroup ? dataGp[0].antisticker : undefined

const Antidoc = isGroup ? dataGp[0].antidoc : undefined

const isAntiCtt = isGroup ? dataGp[0].antictt : undefined

const Antiloc = isGroup ? dataGp[0].antiloc : undefined

const isAntiDDD = isGroup ? dataGp[0].ANTI_DDD.active : undefined

const isAntilinkgp = isGroup ? dataGp[0].antilinkgp : undefined

const isAntiLinkHard = isGroup ? dataGp[0].antilinkhard : undefined

const isAntiLinkEasy = isGroup ? dataGp[0].antilinkeasy : undefined

const isAntiPorn = isGroup ? dataGp[0].antiporn : undefined

const isAntifake = isGroup ? dataGp[0].antifake : undefined

const IS_DELETE = nescessario.Odelete

const So_Adm = isGroup ? dataGp[0].soadm : undefined

const isX9VisuUnica = isGroup ? dataGp[0].visuUnica : undefined

const ADVT = isGroup ? dataGp[0].advertir: undefined

const ADVT2 = isGroup ? dataGp[0].advertir2: undefined

const isx9 = isGroup ? dataGp[0].x9 : undefined

const isMultiP = isGroup ? dataGp[0].multiprefix : undefined

const isAntiNotas = isGroup ? dataGp[0].antinotas : undefined

const isAnticatalogo = isGroup ? dataGp[0].anticatalogo : undefined

const isWelkom = isGroup ? dataGp[0].wellcome[0].bemvindo1 : undefined

const isWelkom2 = isGroup ? dataGp[0].wellcome[1].bemvindo2 : undefined

const isSimi = isGroup ? dataGp[0].simi1 : undefined

const isAutofigu = isGroup ? dataGp[0].autosticker : undefined

const isAutorepo = isGroup ? dataGp[0].autoresposta : undefined

const isModobn =  isGroup ? dataGp[0].jogos : undefined


const isBanchat = isGroup ? dataGp[0].bangp : undefined

const isPalavrao = isGroup ? dataGp[0].antipalavrao.active : undefined

const isPalavras = isGroup ? dataGp[0].antipalavrao.palavras : undefined

const isAntiFlood = isGroup ? dataGp[0].limitec.active : undefined

const isLimitec = isGroup ? dataGp[0].limitec.quantidade : undefined

const isModoRPG = isGroup ? dataGp[0].modo_rpg : undefined

//============(VERIFICADOS)============\\

if (nescessario.verificado) {
var selo = { "key": { "participant": "0@s.whatsapp.net", "remoteJid": "120363391026193207@g.us", "fromMe": false }, "message": { "contactMessage": { "displayName": `${pushname}`, "vcard": `BEGIN:VCARD\nVERSION:3.0\nN:;${pushname};;;\nFN:${pushname}\nitem1.TEL;waid=13135550002:13135550002\nitem1.X-ABLabel:Celular\nEND:VCARD`, "contextInfo": { "forwardingScore": 1, "isForwarded": true }}}}
} else {
var selo = info
}

// FUNÇÕES DE MARCAÇÕES ESSENCIAL \\

const menc_prt = info.message?.extendedTextMessage?.contextInfo?.participant

const menc_jid = args?.join(" ").replace("@", "") + "@s.whatsapp.net"

const menc_jid2 = info.message?.extendedTextMessage?.contextInfo?.mentionedJid


const sender_ou_n = q.includes("@") ? menc_jid : sender

const mrc_ou_numero = q.length > 6 && !q.includes("@") ? q.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net` : menc_prt 
const menc_os2 = q.includes("@") ? menc_jid : menc_prt 

const marc_tds = q.includes("@") ? menc_jid : q.length > 6 && !q.includes("@") ? q.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net` : menc_prt 

const menc_prt_nmr = q.length > 12 ? q.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net` : menc_prt


////////////////////////////////////////////


var isUrl = (url) => {
if(linkfy.find(url)[0]) return true
return false
}

//
const time2 = moment().tz('America/Sao_Paulo').format('HH:mm:ss');

if(time2 > "00:00:00" && time2 < "05:00:00"){
    var tempo = 'Boa noite'
    var tempo2 = 'ʙᴏᴀ ɴᴏɪᴛᴇ'
} if(time2 > "05:00:00" && time2 < "12:00:00"){
    var tempo = 'Bom dia'
    var tempo2 = 'ʙᴏᴍ ᴅɪᴀ'
} if(time2 > "12:00:00" && time2 < "18:00:00"){
    var tempo = 'Boa tarde'
    var tempo2 = 'ʙᴏᴀ ᴛᴀʀᴅᴇ'
} if(time2 > "18:00:00"){
    var tempo = 'Boa noite'
    var tempo2 = 'ʙᴏᴀ ɴᴏɪᴛᴇ'
}

if(!isCmd && info.key.fromMe) return
const reply = (text) => {
    const contextInfo = {
        isForwarded: true,
        forwardingScore: 1,
        forwardedNewsletterMessageInfo: {
            newsletterJid: `${setting.channelnk}`,
            newsletterName: `${NomeDoBot}` ,
            serverMessageId: ''
        }
    };
    const messageOptions = {
        text,
        contextInfo
    };

    return yuta.sendMessage(from, messageOptions, {
        quoted: selo 
    }).catch(error => {
        console.error(error);
    });
};


async function sendAudioMenu(from) {
  const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/menu.mp3');
  await yuta.sendMessage(from, {
    audio: soundft,
    mimetype: "audio/mpeg",
    contextInfo: {
      forwardingScore: 1,
      isForwarded: true,
      forwardedNewsletterMessageInfo: {
        newsletterJid: `${setting.channelnk}`,
        newsletterName: `${NomeDoBot}`,
      },
    },
  }, { quoted: selo });
}

/*
async function reply(content, type, options = {}) {
const isFullUrl = (url) => new RegExp(/^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&/=]*)$/, 'gi').test(url);
const mediaKeys = ['image', 'video', 'sticker', 'audio', 'document', 'history', 'md-app-state'];
options[type || 'text'] = isFullUrl(content) && mediaKeys.includes(type) ? {url: content} : content;
await yuta.sendMessage(from, options, {quoted: selo}).catch(async(error) => {
await yuta.sendMessage(from, {text: 'Ocorreu um erro ao encaminhar a mensagem pré-definida na função.'}, {quoted: selo});
});
}
*/
async function sendUrlText(id, textCaption, title, desc, imageUrl, linkAcess, quotedThis) {
  await yuta.sendMessage(id, {text: textCaption, contextInfo: {externalAdReply: {title: title, body: desc, thumbnail: await getBuffer(imageUrl), mediaType: 1, sourceUrl: linkAcess}}}, {quoted: quotedThis})
}
  
async function replyWithNewsletter(text, options = {}, quotedThis = info) {
await yuta.sendMessage(from, {text: text, contextInfo: options}, {quoted: quotedThis})
.catch(async(error) => {
await yuta.sendMessage(from, {text: 'Ocorreu um erro ao encaminhar a mensagem pré-definida na função.'}, {quoted: selo});
});
}

async function replyWithReaction(text, options = {}, quotedThis = info) {
await yuta.sendMessage(from, options)
await yuta.sendMessage(from, {text: text}, {quoted: quotedThis})
.catch(async(error) => {
await yuta.sendMessage(from, {text: 'Ocorreu um erro ao encaminhar a mensagem pré-definida na função.'}, {quoted: selo});
});
}

const sendSticker = async(ChatID, FileN, quotedThis) => {
await yuta.sendMessage(ChatID, {sticker: {url: FileN}}, {quoted: selo})
.catch(async(error) => {
await yuta.sendMessage(from, {text: 'Ocorreu um erro ao enviar o sticker.'}, {quoted: selo});
});
}

const sendImage = async(ChatID, FileN) => {
await yuta.sendMessage(ChatID, {image: {url: FileN}}, {quoted: selo}).catch(async(error) => {
await yuta.sendMessage(from, {text: 'Ocorreu um erro ao enviar a imagem.'}, {quoted: selo});
})
}

const sendText = async(ChatID, texto) => {
await yuta.sendMessage(ChatID, {text: texto}).catch(async(error) => {
await yuta.sendMessage(from, {text: 'Ocorreu um erro ao encaminhar o texto pré-definido na função.'}, {quoted: selo});
});
}

const sendMentions = async(local, teks) => {
memberr = []; vy = teks.includes('\n') ? teks.split('\n') : [teks]
for(vz of vy) {for(zn of vz.split(' ')) {if(zn.includes('@')) memberr.push(parseInt(zn.split('@')[1])+'@s.whatsapp.net')}};
await yuta.sendMessage(local, {text: teks.trim(), mentions: memberr}, {quoted: selo}).catch(async(e) => {
await yuta.sendMessage(from, {text: 'Ocorreu um erro ao encaminhar a mensagem pré-definida na função.'}, {quoted: selo});
});
}

const mentions = async(teks = '', mb, id) => {
(id == null || id == undefined || id == false) ? await yuta.sendMessage(from, {text: teks.trim(), mentions: mb}) : await yuta.sendMessage(from, {text: teks.trim(), mentions: mb}, {quoted: selo})
}
	
const mention = async(teks = '', ms = info) => {
memberr = []
vy = teks.includes('\n') ? teks.split('\n') : [teks]
for(vz of vy) { 
for(zn of vz.split(' ')) {
if(zn.includes('@')) memberr.push(parseInt(zn.split('@')[1])+'@s.whatsapp.net')
}
}
await yuta.sendMessage(from, {text: teks.trim(), mentions: memberr}, {quoted: ms}).catch(async(e) => {
await yuta.sendMessage(from, {text: 'Ocorreu um erro ao encaminhar a mensagem pré-definida na função.'}, {quoted: selo});
});
}

const mentionSemQuoted = async(teks) => {
memberr = []
vy = teks.includes('\n') ? teks.split('\n') : [teks]
for(vz of vy){ for(zn of vz.split(' ')){
if(zn.includes('@')) memberr.push(parseInt(zn.split('@')[1])+'@s.whatsapp.net')
}}
await yuta.sendMessage(from, {text: teks.trim(), mentions: memberr}).catch(async(e) => {
await yuta.sendMessage(from, {text: 'Ocorreu um erro ao encaminhar a mensagem pré-definida na função.'}, {quoted: selo});
});
}

const mencionarIMG = async(teks = '', FileN, thisQuoted = info) => {
memberr = []
vy = teks.includes('\n') ? teks.split('\n') : [teks]
for(vz of vy) { 
for(zn of vz.split(' ')) {
if(zn.includes('@')) memberr.push(parseInt(zn.split('@')[1])+'@s.whatsapp.net');
}
}
await yuta.sendMessage(from, {image: {url: FileN}, caption: teks.trim(), mentions: memberr}, {quoted: thisQuoted}).catch(async(error) => {
await yuta.sendMessage(from, {text: 'Ocorreu um erro ao encaminhar a imagem e o texto pré-definidos na função.'}, {quoted: selo});
});
}

const reagir = async (idgp, emj) => {
await yuta.sendMessage(idgp, {react: {text: emj, key: info.key}});
}

const verificarN = async(sla) => {
const [result] = await yuta.onWhatsApp(sla)
if(result == undefined) {
reply("Este usuário não é existente no WhatsApp")
} else {
reply(`${sla} Número inserido é existente no WhatsApp com o id: ${result.jid}`)
}
}

if(isGroup && isBotGroupAdmins && !isGroupAdmins && !SoDono && !info.key.fromMe) {
if(menc_jid2?.length >= groupMembers.length - 1) { 
await yuta.sendMessage(from, {text: mess.markingAllMember()}, {quoted: selo});
if(IS_DELETE) {
setTimeout(async() => {
await yuta.sendMessage(from, {delete: {remoteJid: from, fromMe: false, id: info.key.id, participant: sender}});
}, 500);
}
yuta.groupParticipantsUpdate(from, [sender], "remove");
}
}

if(isAutofigu && isGroup) {
async function autofiguf() {
setTimeout(async() => {    
if(budy.includes(`${prefix}sticker`) || budy.includes(`${prefix}s`) || budy.includes(`${prefix}stk`) || budy.includes(`${prefix}st`) || budy.includes(`${prefix}fsticker`) || budy.includes(`${prefix}f`) || budy.includes(`${prefix}fstiker`)) return
if(type == 'imageMessage') {
var pack = `➪ ·֗٬̤⃟🌹ᴄʀɪᴀᴅᴀ ᴘᴏʀ\n❒᭄〭 ${NomeDoBot}\n\n➪ ·֗٬̤⃟🩸ɴɪᴄᴋ ᴅᴏɴᴏ\n❒᭄〭 ${ownerName}⁩`
var author2 = `➪ ·֗٬̤⃟🥀ғᴇɪᴛᴀ ᴘᴏʀ:\n❒᭄〭 ${pushname}\n\n➪ ·֗٬̤⃟ 🌆ɢʀᴜᴘᴏ:\n❒᭄〭 ${isGroup ? groupName : "privado"}`
owgi = await getFileBuffer(info.message.imageMessage, 'image')
let encmediaa = await sendImageAsSticker2(yuta, from, owgi, selo, { packname:pack, author:author2})
DLT_FL(encmediaa)
}
if(type == 'videoMessage') {
if((isMedia && info.message.videoMessage.seconds < 10)) {
var pack = `➪ ·֗٬̤⃟🌹ᴄʀɪᴀᴅᴀ ᴘᴏʀ\n❒᭄〭 ${NomeDoBot}\n\n➪ ·֗٬̤⃟🩸ɴɪᴄᴋ ᴅᴏɴᴏ\n❒᭄〭 ${ownerName}⁩`
var author2 = `➪ ·֗٬̤⃟🥀ғᴇɪᴛᴀ ᴘᴏʀ:\n❒᭄〭 ${pushname}\n\n➪ ·֗٬̤⃟ 🌆ɢʀᴜᴘᴏ:\n❒᭄〭 ${isGroup ? groupName : "privado"}`
owgi = await getFileBuffer(info.message.videoMessage, 'video')
let encmedia = await sendVideoAsSticker2(yuta, from, owgi, selo, { packname:pack, author:author2})
DLT_FL(encmedia)
}
} 
}, 1000)
}
autofiguf().catch((error) => {
console.log(error)
})
}

var nmrdnofc1 = setting.ownerNumber.replace(new RegExp("[()+-/ +/]", "gi"), "")

if(isGroup && fs.existsSync(`./DADOS DO YUTA/func/afk/afk-@${nmrdnofc1}.json`)) {
if(budy.indexOf(`@${nmrdnofc1}`) >= 0) {
const tabelin = JSON.parse(fs.readFileSync(`./DADOS DO YUTA/func/afk/afk-@${nmrdnofc1}.json`));  
await yuta.sendMessage(from, {text: mess.absenceRecordOwner(ownerName, tabelin)}, {quoted: selo})
}
}

if(isGroup && dataGp[0].ausentes?.length > 0 && menc_jid2?.length > 0 && JSON.stringify(dataGp[0].ausentes).includes(menc_jid2)) {
blue = [] 
for (i of menc_jid2) {
if(groupAdmins.indexOf(String(i)) != -1) blue.push(groupAdmins.indexOf(String(i)))
}
if(blue.length == 0) return
big = [] 
for ( i of blue) {
big.push(groupAdmins[i])
}
blr = []
for ( i = 0; i < big.length; i++) {
blr.push(dataGp[0].ausentes[dataGp[0].ausentes.map(i => i.id).indexOf(big[i])])
}
for ( i of blr) {
var blak = i
}
await mention(mess.absenceRecordAdmin(blak))
}

if (isGroup && isBotGroupAdmins && (isGroupAdmins || SoDono)) {
    if (budy.toLowerCase().startsWith("d ") || budy.toLowerCase() === "d") {
        if (!menc_prt) return;
        
yuta.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.message.extendedTextMessage.contextInfo.stanzaId, participant: menc_prt}})
setTimeout(async() => {
yuta.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 0)
    }
}

if(!isVip && nescessario.cmd_vip.includes(command)) return reply(mess.onlyVipUser());


//========================================\\

//BAN GRUPO & BOT OFF
if(isGroup && isCmd && isBanchat && !SoDono) return

if(isGroup && isCmd && So_Adm && !SoDono && !isGroupAdmins) return

if(isBotoff && !SoDono) return

//=======================================\\

const sendStickerFromUrl = async(to, url) => {
try {
var names = Date.now() / 10000;
var download = function (uri, filename, callback) {
request.head(uri, function (err, res, body) {
request(uri).pipe(fs.createWriteStream(filename)).on('close', callback);
});
};
download(url, './sticker' + names + '.png', async function () {
let filess = './sticker' + names + '.png'
let asw = './sticker' + names + '.webp'
exec(`ffmpeg -i ${filess} -vcodec libwebp -filter:v fps=fps=15 -lossless 1 -loop 0 -preset default -an -vsync 0 -s 800:800 ${asw}`, async(err) => {
let media = fs.readFileSync(asw)
await yuta.sendMessage(to, {sticker: media}, {sendEphemeral: true, contextInfo: { forwardingScore: 50, isForwarded: true}, quoted: selo}).catch(async(error) => {
return reply(mess.error())
})
DLT_FL(filess)
DLT_FL(asw)
});
});
} catch {
return reply(mess.error())
}
}

//=========(isQuoted/consts)=============\\

const isImage = type == 'imageMessage'
const isVideo = type == 'videoMessage'
const isVisuU2 = type == 'viewOnceMessageV2'
const isAudio = type == 'audioMessage'
const isSticker = type == 'stickerMessage'
const isContact = type == 'contactMessage'
const isLocation = type == 'locationMessage'
const isProduct = type == 'productMessage'
const isMedia = (type === 'imageMessage' || type === 'videoMessage' || type === 'audioMessage' || type == "viewOnceMessage" || type == "viewOnceMessageV2")
typeMessage = body.substr(0, 50).replace(/\n/g, '')
if(isImage) typeMessage = "Image"
else if(isVideo) typeMessage = "Video"
else if(isAudio) typeMessage = "Audio"
else if(isSticker) typeMessage = "Sticker"
else if(isContact) typeMessage = "Contact"
else if(isLocation) typeMessage = "Location"
else if(isProduct) typeMessage = "Product"

const isQuotedMsg = type === 'extendedTextMessage' && content.includes('conversation')

const isQuotedMsg2 = type === 'extendedTextMessage' && content.includes('text')

const isQuotedImage = type === 'extendedTextMessage' && content.includes('imageMessage')

const isQuotedVisuU = type === 'extendedTextMessage' && content.includes('viewOnceMessage')

const isQuotedVisuU2 = type === 'extendedTextMessage' && content.includes('viewOnceMessageV2')

const isQuotedVideo = type === 'extendedTextMessage' && content.includes('videoMessage')

const isQuotedDocument = type === 'extendedTextMessage' && content.includes('documentMessage')

const isQuotedDocW = type === 'extendedTextMessage' && content.includes('documentWithCaptionMessage')

const isQuotedAudio = type === 'extendedTextMessage' && content.includes('audioMessage')

const isQuotedSticker = type === 'extendedTextMessage' && content.includes('stickerMessage')

const isQuotedContact = type === 'extendedTextMessage' && content.includes('contactMessage')

const isQuotedLocation = type === 'extendedTextMessage' && content.includes('locationMessage')

const isQuotedProduct = type === 'extendedTextMessage' && content.includes('productMessage')
            
// ANTI DDD - LISTA COMPLETA DE DDDs EXISTENTES NO BRASIL!
const arrayDDDs = [11, 12 ,13 ,14 ,15, 16, 17, 18, 19, 21, 22, 24 , 27, 28, 31, 32, 33, 34, 35, 37, 38, 41, 42, 43, 44, 45, 46, 47, 48, 49, 51, 53, 54, 55,61, 62, 63, 64, 65, 66, 67, 68, 69, 71, 73, 74,75, 77, 79, 81, 82, 83, 84, 85, 86, 87, 88, 89,91, 93, 94, 95, 96, 97, 98, 99];

//////BLOCK CMD///////
budy = body.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "");

if(isGroup){
const checar = getComandos(from)
if(checar === undefined) addComandosId(from)
}
if(isGroup && isCmd && !SoDono && !isnit && getComandoBlock(from).includes(command)) return reply('O comando foi bloqueado, entre em contato com a administração.')

///BLOCK CMD GLOBAL///
///(CRÉDITOS AO @VictorGabriel)///
if(isblockCmdG.includes(command) && !SoDono) return reply('Olá, o comando está bloqueado para *uso global*, ou seja, todos os usuários estão impossibilitados de usar ele.\n–\n• Entre em contato com meu proprietário para saber o motivo.')

////FIMMMMMMMMM/////

///// FIMMMMMMMMMMMMM /////

const dattofc = moment.tz('America/Sao_Paulo').format('DD/MM/YYYY')
const hourofc = moment.tz('America/Sao_Paulo').format('HH:mm:ss')

const MessageType = type == 'audioMessage' ? 'Áudio' : type == 'stickerMessage' ? 'Figurinha' : type == 'imageMessage' ? 'Imagem' : type == 'videoMessage' ? 'Vídeo' : type == 'documentMessage' ? 'Documento' : type == 'contactMessage' ? 'Contato' : type == 'locationMessage' ? 'Localização' : info.message?.reactionMessage?.text ? `Reação '${info.message.reactionMessage.text}'` : `${prefix+command}`;

//===============INTERAÇÃO NO TERMUX=====================
// ❗𝙲𝙾𝙼𝙰𝙽𝙳𝙾 𝙽𝙾 𝙿𝚅❗
if (isConsole) { //Nkzin-Alone 
const user = `${colors.brightRed(pushname)}`
const number = `${colors.brightRed(addNumberMais(sender))}`
const chatType = isGroup ? 'Grupo' : 'Privado'
const chatName = isGroup ? groupName : 'privado'
const groupInfo = isGroup ? ` ${colors.brightRed(groupName)}` : ''

let messageType = ''
let mediaType = ''

if (isCmd) {//Nkzin-Alone 
messageType = 'Comando'
mediaType = `${colors.brightRed(prefix+command)}` // Indicar o comando usado
} else if (isImage) {
messageType = 'Mídia'
mediaType = 'Imagem'
} else if (isVideo) {
messageType = 'Mídia'
mediaType = 'Vídeo'
} else if (isAudio) {
messageType = 'Mídia'
mediaType = 'Áudio'
} else if (isSticker) {
messageType = 'Mídia'
mediaType = 'Figurinha'
} else if (isLocation) {
messageType = 'Mídia'
mediaType = 'Localização'
} else if (isProduct) {
messageType = 'Mídia'
mediaType = 'Catálogo'
} else if (isQuotedDocument) {
messageType = 'Mídia' 
mediaType = 'Documento'
} else if (isQuotedContact) { 
messageType = 'Mídia'
mediaType = 'Contato'
} else if (budy && budy.includes('###')) { 
messageType = 'Midia'
mediaType = 'Enquete' 
} else {//Nkzin-Alone 
messageType = 'Mensagem'
}

const messagePreview = messageType === 'Mensagem' ? (budy.length > 20 ? budy.slice(0, 20) + '...' : budy) : 'Conteúdo de mídia' 
const messageInfo = messageType === 'Mensagem' || messageType === 'Documento' ? `\n┆┆↝👾 ${messageType}: ${colors.brightRed(budy)}` : messageType === 'Enquete' ? `\n┆┆↝🃏 ${messageType}` : `\n┆┆↝🌹 ${messageType}: ${colors.brightRed(mediaType)}` 
const reactionInfo = isGroup && info.message?.reactionMessage?.text ? `┆┆↝🔖 Reação: ${colors.brightRed(info.message.reactionMessage.text)}\n` : ''

console.log(colors.magenta(`
╭──────────────────────────────
┆╭════════════════◉
┆┆↝📌 Usuário: ${user}
┆┆↝📍 Número: ${number}
┆┆↝🌟 Chat: ${colors.brightRed(chatType)}${groupInfo}
┆┆↝📆 Hora: ${colors.brightRed(hora)}
┆┆↝⏳ Data: ${colors.brightRed(date)}
┆┆↝🤖 Tipo: ${colors.brightRed(messageType)}${messageInfo}
${reactionInfo}┆╰════════════════◉
╰──────────────────────────────
`))
}

// ========= || Jogo da Velha || ======== \\
async function startJogoDaVelha() {
if(joguinhodavelhajs2.includes(from) || joguinhodavelhajs.includes(sender)) {
const cmde = budy.toLowerCase().split(" ")[0] || "";
let arrNum = ["1", "2", "3", "4", "5", "6", "7", "8", "9"];
if(fs.existsSync(`./ARQUIVES/tictactoe/db/${from}.json`)) {
const boardnow = setGame(`${from}`);
if(budy == "Cex") return reply("why");
if(budy.toLowerCase() == "s" || budy.toLowerCase() == "sim" || budy.toLowerCase() == "ok") {
if(boardnow.O == sender.replace("@s.whatsapp.net", "")) {
if(boardnow.status) return;
const matrix = boardnow._matrix;
boardnow.status = true;
fs.writeFileSync(`./ARQUIVES/tictactoe/db/${from}.json`,
JSON.stringify(boardnow, null, 2)
);
const chatAccept = `
*『 🎮 』ᒍOᘜO ᗪᗩ ᐯᗴᒪᕼᗩ『 🕹 』*

❌ : @${boardnow.X}
⭕ : @${boardnow.O}
• Sua vez : @${boardnow.turn == "X" ? boardnow.X : boardnow.O}\n\n${matrix[0][0]}  ${matrix[0][1]}  ${matrix[0][2]}\n${matrix[1][0]}  ${matrix[1][1]}  ${matrix[1][2]}\n${matrix[2][0]}  ${matrix[2][1]}  ${matrix[2][2]}`;
mention(chatAccept);
}
} else if(
budy.toLowerCase() == "n" ||
budy.toLowerCase() == "não" ||
budy.toLowerCase() == "no"
) {
if(boardnow.O == sender.replace("@s.whatsapp.net", "")) {
if(boardnow.status) return reply(`O jogo começou ou já existe uma partida aberta neste grupo! Por favor, caso ninguém esteja jogando ou houve um erro desconhecido na função, entre em contato com o criador ou solicite à um adm para usar o  comando '${prefix}resetvelha' no grupo.`);
DLT_FL(`./ARQUIVES/tictactoe/db/${from}.json`);
mention(`Nossa @${boardnow.X}, infelizmente o seu oponente não aceitou seu desafio!, ❌😕`)
joguinhodavelhajs.splice([])
fs.writeFileSync('./DADOS DO YUTA/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs))
joguinhodavelhajs2.splice([])
fs.writeFileSync('./DADOS DO YUTA/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
}
}
}

if(arrNum.includes(cmde)) {
const boardnow = setGame(`${from}`);
if(!boardnow.status) return reply(`Parece que seu oponente não aceitou o desafio ainda.`)
if((boardnow.turn == "X" ? boardnow.X : boardnow.O) != sender.replace("@s.whatsapp.net", "")) return;
const moving = validmove(Number(budy), `${from}`);
const matrix = moving._matrix;
if(moving.isWin) {
if(moving.winner == "SERI") {
reply(`Ocorreu um empate! 😨`);
DLT_FL(`./ARQUIVES/tictactoe/db/${from}.json`);
joguinhodavelhajs.splice([])
fs.writeFileSync('./DADOS DO YUTA/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs)) 
joguinhodavelhajs2.splice([])
fs.writeFileSync('./DADOS DO YUTA/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
return;
}
const abt = Math.ceil(Math.random() + 4000)
const winnerJID = moving.winner == "O" ? moving.O : moving.X;
const looseJID = moving.winner == "O" ? moving.X : moving.O;
setTimeout(() => {
if(fs.existsSync("./ARQUIVES/tictactoe/db/" + from + ".json")) {
DLT_FL("./ARQUIVES/tictactoe/db/" + from + ".json");
reply(`O *jogo da velha* foi cancelado por falta de movimentação no tabuleiro ou o desafiado não aceitou no prazo de 5 minutos.`);
} else {
console.log(colors.red(time), colors.magenta("[ EXPIRADO ]"), colors.red('Jogo da velha espirado..'));
}
joguinhodavelhajs.splice([])
fs.writeFileSync('./DADOS DO YUTA/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs))
joguinhodavelhajs2.splice([])
fs.writeFileSync('./DADOS DO YUTA/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
}, 300000) //5 minutos
await mention(`Parabéns *@${winnerJID}*, você ganhou a partida do jogo da velha! 😍🎯`)   
DLT_FL(`./ARQUIVES/tictactoe/db/${from}.json`);
joguinhodavelhajs.splice([])
fs.writeFileSync('./DADOS DO YUTA/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs)) 
joguinhodavelhajs2.splice([])
fs.writeFileSync('./DADOS DO YUTA/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
} else {
mention(`
*『 🎮 』ᒍOᘜO ᗪᗩ ᐯᗴᒪᕼᗩ『 🕹 』*

❌ : @${boardnow.X}
⭕ : @${boardnow.O}
• Sua vez : @${moving.turn == "X" ? moving.X : moving.O}\n\n${matrix[0][0]}  ${matrix[0][1]}  ${matrix[0][2]}\n${matrix[1][0]}  ${matrix[1][1]}  ${matrix[1][2]}\n${matrix[2][0]}  ${matrix[2][1]}  ${matrix[2][2]}`);
}
} 
} 
}

// LOADING

async function carregamento() {
txt1 = `_『ʟᴏᴀᴅɪɴɢ』\n:`
var carre = [
`${txt1}ʟᴏᴀᴅɪɴɢ ▁ 10%`,
`${txt1}ʟᴏᴀᴅɪɴɢ ▁ ▂ ▃  30%`,
`${txt1}ʟᴏᴀᴅɪɴɢ ▁ ▂ ▃ ▄  50%`,
`${txt1}ʟᴏᴀᴅɪɴɢ ▁ ▂ ▃ ▄ ▅ 60%`,
`${txt1}ʟᴏᴀᴅɪɴɢ ▁ ▂ ▃ ▄ ▅ ▆ 80%`,
`${txt1}ʟᴏᴀᴅɪɴɢ ▁ ▂ ▃ ▄ ▅ ▆ █ 100%`,
`_᭥ꩌ゚໋ @${sender.split("@")[0]}_\n_• Pesquisa realizada, Aguarde um pouco para ser enviado.._`]
let { key } = await yuta.sendMessage(from, {text: `_᭥ꩌ゚໋ Ok @${sender.split("@")[0]}_\n_• Obtendo os resultados de sua pesquisa.._`, mentions: [sender]}, {quoted: selo})
for (let i = 0; i < carre.length; i++) {
await yuta.sendMessage(from, {text: carre[i], mentions: [sender], edit: key });
}
}

// NAMORO
if(budy2.toLowerCase() === "s" || budy2.toLowerCase() === "sim") {
if(JSON.stringify(namoro2).includes(sender) && namoro2[namoro2.map(i => i.id).indexOf(sender)].idgp == from && isGroup) {
C14 = namoro2.map(i => i.id).indexOf(sender)
C12 = namoro1.map(i => i.usu1).indexOf(namoro2[C14].pedido + "@s.whatsapp.net")
namoro1[C12].namorados = true
fs.writeFileSync("./DADOS DO YUTA/func/namoro1.json", JSON.stringify(namoro1, null, 2))
namoro1.push({usu1: sender, usu2: namoro2[C14].pedido, namorados: true, idgp: from, hora: hourofc, data: dattofc})
fs.writeFileSync("./DADOS DO YUTA/func/namoro1.json", JSON.stringify(namoro1, null, 2))
namoro2.splice(C14, 1)
fs.writeFileSync("./DADOS DO YUTA/func/namoro2.json", JSON.stringify(namoro2))
mention(`ᴡᴏᴡɴ 🥺 @${namoro1[C12].usu1.split('@')[0]}! ᴏ (ᴀ) @${sender.split('@')[0]} ᴀᴄᴇɪᴛᴏᴜ sᴇᴜ ᴘᴇᴅɪᴅᴏ ᴅᴇ ɴᴀᴍᴏʀᴏ, ᴘᴀʀᴀʙᴇɴs ᴀᴏ ɴᴏᴠᴏ ᴄᴀsᴀʟ 😍\n\n> ᴄᴀsᴏ ǫᴜᴇɪʀᴀ ᴄᴏɴsᴜʟᴛᴀʀ sᴇᴜ ɴᴀᴍᴏʀᴏ ᴜsᴇ ${prefix}ᴍɪɴʜᴀᴅᴜᴘʟᴀ`)
}
}

if(budy2.toLowerCase() === "n" || budy2.toLowerCase().replace("ã", "a") === "nao") {
if(JSON.stringify(namoro2).includes(sender) && namoro2[namoro2.map(i => i.id).indexOf(sender)].idgp == from && isGroup) {
C14 = namoro2.map(i => i.id).indexOf(sender)
C12 = namoro1.map(i => i.usu1).indexOf(`${namoro2[C14].pedido}@s.whatsapp.net`)
mention(`ǫᴜᴇ ᴘᴇɴɪɴʜᴀ @${namoro1[C12].usu1.split('@')[0]}! ᴏ (ᴀ) @${sender.split('@')[0]} ɴᴀᴏ ᴛᴇ ǫᴜɪs, ᴛᴀʟᴠᴇᴢ ᴇʟᴇ(ᴀ) ɴᴀᴏ sɪɴᴛᴀ ᴏ ᴍᴇsᴍᴏ ᴘᴏʀ ᴠᴏᴄᴇ, ᴍᴀs ɴᴀᴏ ᴅᴇsᴀɴɪᴍᴀ ɴᴀᴏ ᴠɪᴜᴜ 😖 `)
namoro1.splice(C12, 1)
fs.writeFileSync("./DADOS DO YUTA/func/namoro1.json", JSON.stringify(namoro1, null, 2))
namoro2.splice(C14, 1)
fs.writeFileSync("./DADOS DO YUTA/func/namoro2.json", JSON.stringify(namoro2))
}
}


startJogoDaVelha()

let isTrueFalse = Array('tiktok', 'facebook','instagram','twitter','ytmp3','ytmp4','play', 'playmix', 'play2', 'play3', 'playvid', 'playvid2').some(item => item === command)

if(isUrl(PR_String) && isAntiLinkHard && !isGroupAdmins && !SoDono && !isListaBrancaG && isBotGroupAdmins && !info.key.fromMe) {
if(isCmd && isTrueFalse) return
if(IS_DELETE) {
setTimeout(() => {
yuta.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 500)
}
yuta.groupSettingUpdate(from, 'announcement')
setTimeout(() => {
yuta.groupSettingUpdate(from, 'not_announcement')
}, 1200)
if(!JSON.stringify(groupMembers).includes(sender)) return
yuta.groupParticipantsUpdate(from, [sender], 'remove')
}


if (isAntilinkgp && isGroup && isBotGroupAdmins && !isGroupAdmins) {
    const messageText = info.message?.requestPaymentMessage?.noteMessage?.extendedTextMessage?.text || info.message?.extendedTextMessage?.text;
if(Procurar_String.includes("chat.whatsapp.com/")){
if(isBot) return 
if(!JSON.stringify(groupMembers).includes(sender)) return
            await yuta.groupParticipantsUpdate(from, [sender], 'remove');
            
            // Deletar a mensagem com o link
            await yuta.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender } });
        }
        if (info.message?.requestPaymentMessage || info.message?.sendPaymentMessage) {
            await yuta.groupSettingUpdate(from, 'announcement');
            await yuta.groupParticipantsUpdate(from, [sender], 'remove');            
            await yuta.groupSettingUpdate(from, 'not_announcement');
        }
    }



// Lógica para contar mensagens nos grupos
const groupIdscount = countMessage.map(i => i.groupId);

// MUTAR USUÁRIO 
 if(!muted.some(i => i.grupo === from) && isGroup) {
  muted.push({grupo: from, usus: []});
  fs.writeFileSync("./DADOS DO YUTA/grupos/muted.json", JSON.stringify(muted, null, 2));
  }
  
if(isGroup && muted[muted.map(i => i.grupo).indexOf(from)].usus.includes(sender)) {
  await yuta.sendMessage(from, {text: `SEGURA O CAPA AI AKAKAKAKAAKA @${sender.split("@")[0]}, TIRA O PÉ DO CHÃO AHM! 🔥🙀`, mentions: [sender]}, {quoted: selo});
  await yuta.sendMessage(from, {delete: {remoteJid: from, fromMe: false, id: info.key.id, participant: sender}});
  await yuta.groupParticipantsUpdate(from, [sender], 'remove');
  // Após a remoção do participante mutado, automaticamente ele vai ser removido da lista de usuários mutados do grupo. 🤍
  muted[muted.map(i => i.grupo).indexOf(from)].usus.splice(sender);
  fs.writeFileSync("./DADOS DO YUTA/grupos/muted.json", JSON.stringify(muted, null, 2));
}

//====> CONTADOR DE MEBSAGEM / Lm Only parou de de ajudar os mal ingrato do canal HARU mods e Yuta cases <====\\
if (isGroup && groupIdscount.indexOf(from) >= 0) {
    var ind = groupIdscount.indexOf(from);
    var numbersIds = countMessage[ind].numbers.map(i => i.id);
    
    if (numbersIds.indexOf(sender) >= 0) {
        var indnum = numbersIds.indexOf(sender);
        var RSM_CN = countMessage[ind].numbers[indnum];
        if (type !== "stickerMessage") {
            RSM_CN.messages += isCmd ? 0 : 1;
            RSM_CN.cmd_messages += isCmd ? 1 : 0;
            RSM_CN.aparelho = adivinha;
        }
        RSM_CN.figus += type == "stickerMessage" ? 1 : 0;
        fs.writeFileSync('./INFO_YUTA/media/countmsg.json', JSON.stringify(countMessage, null, 2) + '\n');
    } else {
        const messages = isCmd ? 0 : 1;
        const cmd_messages = isCmd ? 1 : 0;
        var figus = type == "stickerMessage" ? 1 : 0;
        countMessage[ind].numbers.push({
            id: sender,
            messages,
            cmd_messages,
            aparelho: adivinha,
            figus
        });
        fs.writeFileSync('./INFO_YUTA/media/countmsg.json', JSON.stringify(countMessage, null, 2) + '\n');
    }
} else if (isGroup) {
    countMessage.push({
        groupName: groupName,
        groupId: from,
        numbers: [{
            id: sender,
            messages: 2,
            figus: 0,
            cmd_messages: isCmd ? 1 : 0,
            aparelho: adivinha
        }]
    });
    fs.writeFileSync('./INFO_YUTA/media/countmsg.json', JSON.stringify(countMessage, null, 2) + '\n');
}

// PARA LIMPAR OS DADOS DOS USUÁRIOS QUE JÁ SAIU DO GRUPO...
async function ClearMembersInactive() {
var RD_CNT = countMessage[countMessage.map(i => i.groupId).indexOf(from)].numbers
CNT1 = []; for ( i of groupMembers) {CNT1.push(i.id)} 
CNT = []; for ( i of RD_CNT) {
if(!CNT1.includes(i.id)) CNT.push(i)}
for ( i of CNT) {
RD_CNT.splice(RD_CNT.map(i => i.id).indexOf(i.id), 1)}
fs.writeFileSync("./INFO_YUTA/media/countmsg.json", JSON.stringify(countMessage, null, 2))
}

const pickRandom = (arr) => {
return arr[Math.floor(Math.random() * arr.length)]
}

if(body != undefined) { /* Créditos: @Nkzin */
if(!JSON.stringify(pushnames).includes(botNumber)) {
pushnames.push({id: botNumber, nick: NomeDoBot});
fs.writeFileSync("./DADOS DO YUTA/usuarios/users.json", JSON.stringify(pushnames, null, 2));
}
if(!JSON.stringify(pushnames).includes(sender)) {
pushnames.push({id: sender, nick: pushname});
fs.writeFileSync("./DADOS DO YUTA/usuarios/users.json", JSON.stringify(pushnames, null, 2));
} else {
pushnames[pushnames.map(i => i.id).indexOf(sender)].nick = pushname
fs.writeFileSync("./DADOS DO YUTA/usuarios/users.json", JSON.stringify(pushnames, null, 2));
}
}

//======================================\\


//======(ANTI-IMAGEM)========\\
if (isAntiImg && isBotGroupAdmins && type == 'imageMessage') {
    if (info.key.fromMe) return; // Ignora mensagens do bot
    if (isGroupAdmins) return await yuta.sendMessage(from, { text: mess.messageProhibitedDetAdmin() }, { quoted: selo }); // Ignora mensagens de administradores

    // Verifica se a legenda da imagem está definida
    if (dataGp[0].legenda_imagem == "0") {
        await yuta.sendMessage(from, { text: "Por favor, envie uma imagem com legenda." }, { quoted: selo });
        
        // Delay para remoção após a atividade
        if (IS_DELETE) {
            setTimeout(async () => {
                // Verifica se o remetente ainda é um membro do grupo
                if (groupMembers.find(member => member.id === sender)) {
                    await yuta.sendMessage(from, { text: "Você foi removido do grupo por não enviar uma imagem com legenda." }, { quoted: selo });
                    await yuta.groupParticipantsUpdate(from, [sender], 'remove'); // Remove o usuário
                }
            }, 1000); // Aumentei o tempo para 1000 ms
        }
    }
}

//======(ANTI-STICKER)========\\
if(isAntiSticker && isBotGroupAdmins && type == 'stickerMessage') {
    if(info.key.fromMe) return; 

    const isAdminOrOwner = groupMembers.find(member => member.id === sender && (member.isAdmin || member.isOwner));

    if(isAdminOrOwner) return await yuta.sendMessage(from, {text: mess.messageProhibitedDetAdmin()}, {quoted: selo});

    await yuta.sendMessage(from, {text: mess.messageProhibitedDetUser()}, {quoted: selo});
    
    if(IS_DELETE) {
        setTimeout(async() => {
            await yuta.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}});
        }, 500);
    }

    if(!JSON.stringify(groupMembers).includes(sender)) return;

    await yuta.groupParticipantsUpdate(from, [sender], 'remove');
}

//============[ ANTI DOCUMENTO ]============\\

if(Antidoc && isBotGroupAdmins && type == 'documentMessage') {
if(info.key.fromMe) return
if(isGroupAdmins) return await yuta.sendMessage(from, {text: mess.messageProhibitedDetAdmin()}, {quoted: selo})

        if(dataGp[0].legenda_documento != "0") {
    await yuta.sendMessage(from, {text: dataGp[0].legenda_documento}, {quoted: selo}) 
}

     if(IS_DELETE) {
   setTimeout(async() => {
      await yuta.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 500)
}

       if(!JSON.stringify(groupMembers).includes(sender)) return  
   await yuta.groupParticipantsUpdate(from, [sender], 'remove')
}


if(isUrl(PR_String) && isAntiLinkEasy && !isGroupAdmins && !isListaBrancaG && isBotGroupAdmins && !info.key.fromMe) {
if(Procurar_String.includes("chat.whatsapp.com")) {
link_dgp = await yuta.groupInviteCode(from)
if(Procurar_String.match(link_dgp)) return reply('*[-⚠-] ᴅɪᴠᴜʟɢᴏᴜ ʟɪɴᴋ? ɪʀᴇɪ ᴀᴘᴀɢᴀʀ.*');
}
if(isCmd && isTrueFalse) return
if(IS_DELETE) {
setTimeout(async() => {
await yuta.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}});
}, 500);
}
}

// ANTI NOTAS FAKES ==================>
if(isAntiNotas && budy2.toString().match(/(💳|💎|💸|💵|💷|💶|🪙|💰|🤑|⚖️)/gi) && isBotGroupAdmins && !isGroupAdmins && !SoDono && !info.message?.reactionMessage?.text && budy2.length > 20) {
let verificar = budy2.toString().match(/(💳|💎|💸|💵|💷|💶|🪙|💰|🤑|⚖️)/gi);
if(verificar && budy.length < 100) return  
if(IS_DELETE) {
setTimeout(async() => {
await yuta.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}});
}, 500);
}
if(!JSON.stringify(groupMembers).includes(sender)) return  
await yuta.groupParticipantsUpdate(from, [sender], 'remove');
}

//FINALZIN ===========================>
function remover(id, usu) {
yuta.groupParticipantsUpdate(id, [usu], "remove")}
//======(ANTI-VIDEO)========\\
if(isAntiVid && isBotGroupAdmins && type == 'videoMessage') {
if(isGroupAdmins) return await yuta.sendMessage(from, {text: mess.messageProhibitedDetAdmin()}, {quoted: selo});
if(dataGp[0].legenda_video == "0") {
await yuta.sendMessage(from, {text: mess.messageProhibitedDetUser()}, {quoted: selo});
} else {
await yuta.sendMessage(from, {text: dataGp[0].legenda_video}, {quoted: selo});
}
if(IS_DELETE) {
setTimeout(async() => {
await yuta.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}});
}, 500);
}
if(!JSON.stringify(groupMembers).includes(sender)) return
await yuta.groupParticipantsUpdate(from, [sender], 'remove');
}

//======(ANTI-AUDIO)=======\\
if(isAntiAudio && isBotGroupAdmins && type == 'audioMessage') {
if(isGroupAdmins) return await yuta.sendMessage(from, {text: mess.messageProhibitedDetAdmin()}, {quoted: selo});
await yuta.sendMessage(from, {text: mess.messageProhibitedDetUser()}, {quoted: selo});
if(IS_DELETE) {
setTimeout(async() => {
await yuta.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}});
}, 500);
}
if(!JSON.stringify(groupMembers).includes(sender)) return
await yuta.groupParticipantsUpdate(from, [sender], 'remove');
}

//========(ANTI_LIGAR)========\\
if(!isGroup && isAnticall) {
yuta.ws.on('CB:call', async (B) => {
var msgcallblock = `./DADOS DO YUTA/func/call-msg_block-${sender}.json`  
if(!fs.existsSync(msgcallblock)) {
fs.writeFileSync(msgcallblock, JSON.stringify(mess.antiCalls(), null, 2));
var msgcallbl = JSON.parse(fs.readFileSync(msgcallblock));
if(B.content[0].tag == 'offer') {
await yuta.sendMessage(B.content[0].attrs['call-creator'], { text: msgcallbl }).then(async() => { 
await yuta.updateBlockStatus(B.content[0].attrs['call-creator'], "block");
DLT_FL(msgcallblock);
})
}
}
})
}


/* ANTIPV1 - Este anti pv bloqueia aqueles que encaminham mensagem no pv do bot.. */
var USUARIOS_BLOQ = []
if(isAntiPv && !USUARIOS_BLOQ.includes(sender)) {
if(!isGroup && !SoDono && !isnit && !isVip){ 
await sleep(2500)
reply(msgantipv1.replace('#nome#', pushname))
setTimeout(async () => {
await yuta.updateBlockStatus(sender, 'block')
}, 2000)
}
USUARIOS_BLOQ.push(sender);
} 

/* ANTIPV2 - Vai floodar o privado do usuário que encaminhar a mensagem no privado.. */
var MSG_ANTPV2_ENC = []
if(!isGroup && !isVip && !SoDono && !isnit && !issupre && !ischyt && !info.key.fromMe && isAntiPv2 && !MSG_ANTPV2_ENC.includes(sender)) {
MSG_ANTPV2_ENC.push(sender);
return reply(msgantipv2)
}

/* ANTIPV3 - Ignora todos os que falam ou usam os comandos no privado, exceto user vip e o proprietário atual do bot. */
if(!isGroup && !isVip && !SoDono && !info.key.fromMe && isAntiPv3) return

//====================================\\
var i9 = countMessage.map(i => i.groupId).indexOf(from)
var idgrupo = groupIdscount.indexOf(from)

var idusu = numbersIds?.indexOf(sender)

const VerificarJSON = (json, value) => {
if(JSON.stringify(json).includes(value)) return true
return false
}

const RG_SCOINS = JSON.parse(fs.readFileSync("./DADOS DO YUTA/func/coins.json"));

const isModoCoins = isGroup ? dataGp[0].isModoCoins : undefined

const ID_G_COINS = RG_SCOINS.findIndex(i => i.grupo === from)
const ID_USU_COINS = RG_SCOINS[ID_G_COINS]?.usus?.findIndex(i => i.id === sender);

function CoinsUpdate(index){
fs.writeFileSync("./DADOS DO YUTA/func/coins.json", JSON.stringify(index, null, 2) + "\n")
}

const SYSTEM_COIN = {

  AdicionarCoins: async function(user, quant) {
  CoinsUser_ = RG_SCOINS[ID_G_COINS].usus.find(i => i.id === user);
  if(!CoinsUser_) return reply("O(a) usuário(a) nunca enviou uma mensagem neste grupo! Então não é possível adicionar ou transferir coins à um membro que não possuí registro!");
  CoinsUser_["coins"] += quant;
  CoinsUpdate(RG_SCOINS);
  },
  
  transferCoins: async function(transferidor, recebidor, quantidade) {
  DM_ = RG_SCOINS[ID_G_COINS].usus.find(i => i.id === transferidor)
  DM_2 = RG_SCOINS[ID_G_COINS].usus.find(i => i.id === recebidor)
  if((DM_?.coins || 0) < quantidade) return mention(`A quantidade que você tem é inferior a que você deseja transferir ao usuário: @${recebidor.split("@")[0]}`)
  if(!DM_2) return mention(`O(a) usuário(a) '@${recebidor.split("@")[0]}' nunca enviou uma mensagem neste grupo! Então não é possível adicionar ou transferir coins à um usuário não registrado no meu sistema!`);
  DM_["coins"] -= quantidade;
  DM_2["coins"] += quantidade;
  CoinsUpdate(RG_SCOINS);
  },
  
  Adicionar_2: async function(A, Q, X, X2) {
  DM_ = RG_SCOINS[ID_G_COINS].usus.find(i => i.id === A);
  if(!DM_) return reply("O(a) usuário(a) nunca enviou uma mensagem neste grupo! Então não é possível atualizar a carteira!");
  DM_["coins"] += Q;
  DM_[X] = X2
  CoinsUpdate(RG_SCOINS);
  },
  
  RemoverCoins: async function(user, quant) {
  CoinsUser = RG_SCOINS[ID_G_COINS].usus.find(i => i.id === user)
  if(!CoinsUser) return reply("O(a) usuário(a) nunca enviou uma mensagem neste grupo! Então não é possível remover coins de membro inativo que não possuí registro!");
  if((CoinsUser?.coins || 0) < quant) return reply(`O usuário possuí '${CoinsUser?.coins} N-Coins', este valor não é suficiente para realizar a transação de remoção de ${quant}.`);
  CoinsUser["coins"] -= quant;
  CoinsUpdate(RG_SCOINS);
  },
  
VerificarCampo: function(user, parameter) {
  return RG_SCOINS[ID_G_COINS].usus.find(i => i.id === user)[parameter] || null;
},
  
  }
  
  if(isModoCoins && isGroup && isBotGroupAdmins && VRF_JSON_GRUPO && !info.key.fromMe) {
  
  if(!RG_SCOINS.some(i => i.grupo === from)) {
  RG_SCOINS.push({grupo: from, usus: [{id: sender, coins: 0, data: 0, chances: {cassino: 0, minerar: 0}}]})
  CoinsUpdate(RG_SCOINS);
  } else if(RG_SCOINS.some(i => i.grupo === from) && !RG_SCOINS[ID_G_COINS]?.usus?.some(i => i?.id === sender)) {
  RG_SCOINS[ID_G_COINS].usus.push({id: sender, coins: 0, data: 0, chances: {cassino: 0, minerar: 0}})
  CoinsUpdate(RG_SCOINS);
  }
  
  if(!info.message?.reactionMessage?.text && dattofc != SYSTEM_COIN.VerificarCampo(sender, "data")) {
  await mention(`
 ‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎    ↳ ${tempo} ↝ @${sender.split('@')[0]} ↴\n\n • Você acaba de ganhar *50 N-Coins* pela primeira mensagem do dia 💫\n\n↳ Caso queira saber mais, use o *${prefix}menucoins* 💕
-`);
  SYSTEM_COIN.Adicionar_2(sender, 50, "data", dattofc);
  RG_US = RG_SCOINS[ID_G_COINS].usus.find(i => i.id === sender);
  Object.assign(RG_US.chances, {"cassino": 0, "minerar": 0});
  CoinsUpdate(RG_SCOINS);
  }
  }

  if(isGroup && fs.existsSync(`./DADOS DO YUTA/grupos/games/anagrama/${from}.json`)){
    let dataA = JSON.parse(fs.readFileSync(`./DADOS DO YUTA/grupos/games/anagrama/${from}.json`))
    if(budy.slice(0,4).toUpperCase() == dataA.palavraOriginal.slice(0,4).toUpperCase() && budy.toUpperCase() != dataA.palavraOriginal) return reply('Está perto...')
    if(budy.toUpperCase() == dataA.palavraOriginal) {
    await yuta.sendMessage(from, {text: `
 ‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎‎    
    ↳ Parabéns *${pushname}*, você acertou o anagrama apresentado!\n • Como recompensa você acaba de ganhar *20 N-Coins*\nA palavra original era: *${dataA.resposta}*. Estou iniciando o próximo jogo em 5s! Aguarde...`}, {"mentionedJid": [sender]}, {quoted: selo})
    await SYSTEM_COIN.AdicionarCoins(sender, 5);
    fs.unlinkSync(`./DADOS DO YUTA/grupos/games/anagrama/${from}.json`)		
    setTimeout(async() => {
    fs.writeFileSync(`./DADOS DO YUTA/grupos/games/anagrama/${from}.json`, `${JSON.stringify(palavrasANA[Math.floor(Math.random() * palavrasANA.length)])}`)
    dataAB = JSON.parse(fs.readFileSync(`./DADOS DO YUTA/grupos/games/anagrama/${from}.json`))
    yuta.sendMessage(from, {text: `🌟😲 Decifre a palavra embaralhada abaixo, qual será a ordem correta?\n—\n• Anagrama: *${shuffle(dataAB.palavraOriginal)}*\n• Dica: ${dataAB.dica}`}, {quoted: selo})
    }, 5000)
    }}
    
    if(isGroup && fs.existsSync(`./DADOS DO YUTA/grupos/games/quiz-animais/${from}.json`)){
    let dQ = JSON.parse(fs.readFileSync(`./DADOS DO YUTA/grupos/games/quiz-animais/${from}.json`))
    if(budy.slice(0,4).toUpperCase() == dQ.original.slice(0,4).toUpperCase() && budy.toUpperCase() != dQ.original) return reply('está perto')
    if(budy.toUpperCase() == dQ.original) { 
    await yuta.sendMessage(from,{text: `🎉 Parabéns *${pushname}*, você acertou, como recompensa você acaba de ganhar 5 N-Coins! O animal era: *${dQ.resposta}*.\n• Estou iniciando o próximo jogo em 5s!`}, {"mentionedJid": [sender]}, {quoted: selo}) 
    await SYSTEM_COIN.AdicionarCoins(sender, 5);
    fs.unlinkSync(`./DADOS DO YUTA/grupos/games/quiz-animais/${from}.json`)		
    setTimeout(async() => {
    fs.writeFileSync(`./DADOS DO YUTA/grupos/games/quiz-animais/${from}.json`, `${JSON.stringify(quizanimais[Math.floor(Math.random() * quizanimais.length)])}`)
    dataQA = JSON.parse(fs.readFileSync(`./DADOS DO YUTA/grupos/games/quiz-animais/${from}.json`))
    wew = await getBuffer(dataQA.foto)
    await yuta.sendMessage(from, {image: wew, caption: `🤔 Pergunta: ${dataQA.question}`}, {quoted: selo})
    }, 5000)
    }
    }
    
    if(isGroup && fs.existsSync(`./DADOS DO YUTA/grupos/games/quiz-futebol/${from}.json`)){
    let dQF = JSON.parse(fs.readFileSync(`./DADOS DO YUTA/grupos/games/quiz-futebol/${from}.json`))
    if(budy.slice(0,4).toUpperCase() == dQF.resposta.slice(0,4).toUpperCase() && budy.toUpperCase() != dQF.resposta) return reply('está perto')
    if(budy.toUpperCase() == dQF.resposta) { 
    await yuta.sendMessage(from,{text: `🎉 Parabéns *${pushname}*, você acertou, como recompensa você acaba de ganhar 5 N-Coins! O time era: *${dQF.resposta}*.\n• Estou iniciando o próximo jogo em 5s!`}, {"mentionedJid": [sender]}, {quoted: selo}) 
    await SYSTEM_COIN.AdicionarCoins(sender, 5);
    fs.unlinkSync(`./DADOS DO YUTA/grupos/games/quiz-futebol/${from}.json`)		
    setTimeout(async() => {
    fs.writeFileSync(`./DADOS DO YUTA/grupos/games/quiz-futebol/${from}.json`, `${JSON.stringify(quizFutebol[Math.floor(Math.random() * quizFutebol.length)])}`)
    dataQF = JSON.parse(fs.readFileSync(`./DADOS DO YUTA/grupos/games/quiz-futebol/${from}.json`))
    await yuta.sendMessage(from, {text: `💫⚽ 𝐐𝐔𝐈𝐙 𝐅𝐔𝐓𝐄𝐁𝐎𝐋 ⚽💫\n–\n*🗣️| Responda a pergunta mostrada abaixo:*\n• _${dataQF.pergunta}_`}, {quoted: selo})
    }, 5000)
    }
    }
    
    if(isGroup && fs.existsSync(`./DADOS DO YUTA/grupos/games/gartic/${from}.json`)){
    let perg_gartic = JSON.parse(fs.readFileSync(`./DADOS DO YUTA/grupos/games/gartic/${from}.json`))
    if(budy.slice(0,4).toUpperCase() == perg_gartic.resposta.slice(0,4).toUpperCase() && budy.toUpperCase() != perg_gartic.resposta) return reply('Está perto!')
    if(budy.toUpperCase() == perg_gartic.resposta) { 
    await yuta.sendMessage(from,{text: `*DESCOBERTO!* Parabéns ${pushname} como recompensa você acaba de ganhar 5 N-Coins. Iniciando o próximo jogo em 5 segundos.`}, {"mentionedJid": [sender]}, {quoted: selo}); 
    await SYSTEM_COIN.AdicionarCoins(sender, 5);
    fs.unlinkSync(`./DADOS DO YUTA/grupos/games/gartic/${from}.json`);
    setTimeout(async() => {
    fs.writeFileSync(`./DADOS DO YUTA/grupos/games/gartic/${from}.json`, `${JSON.stringify(garticArchives[Math.floor(Math.random() * garticArchives.length)])}`)
    let dataGartic2 = JSON.parse(fs.readFileSync(`./DADOS DO YUTA/grupos/games/gartic/${from}.json`))
    garticText = `👩🏼‍🏫 - A resposta é representada por um(a): ${dataGartic2.pergunta}\n📜 - A resposta supostamente começa com a(s) letra(s): "${dataGartic2.letra_inicial}"\n🤔 - Hmmm, contém traços? ${dataGartic2.contem_traços}\n–\n❓️ - *Não sabe a resposta?* _Peça ao adm do grupo para usar o comando *${prefix}revelargartic* para revelar a resposta correta da afirmação._`
    wew = await getBuffer(`${dataGartic2.imagem}`)
    await yuta.sendMessage(from, {image: wew, caption: garticText}, {quoted: selo})
    }, 5000)
    }
    }
    
    if(isGroup && fs.existsSync(`./DADOS DO YUTA/grupos/games/enigma/${from}.json`)){
    let enigmaData = JSON.parse(fs.readFileSync(`./DADOS DO YUTA/grupos/games/enigma/${from}.json`))
    if(budy.slice(0,4).toUpperCase() == enigmaData.respostaEne.slice(0,4).toUpperCase() && budy.toUpperCase() != enigmaData.respostaEne) return reply('Está perto!')
    if(budy.toUpperCase() == enigmaData.respostaEne) { 
    yuta.sendMessage(from,{text: `*ENIGMA RESOLVIDO!* Parabéns ${pushname}, como recompensa você acaba de ganhar 5 N-Coins.Iniciando o próximo jogo em 5 segundos.`}, {"mentionedJid": [sender]}, {quoted: selo})
    await SYSTEM_COIN.AdicionarCoins(sender, 5);
    fs.unlinkSync(`./DADOS DO YUTA/grupos/games/enigma/${from}.json`)	
    setTimeout(async() => {
    fs.writeFileSync(`./DADOS DO YUTA/grupos/games/enigma/${from}.json`, `${JSON.stringify(enigmaArchive[Math.floor(Math.random() * enigmaArchive.length)])}`)
    enigmaD = JSON.parse(fs.readFileSync(`./DADOS DO YUTA/grupos/games/enigma/${from}.json`))
    enigmaTezt = `📜 - Resolva o seguinte enigma abaixo:\n–\n${enigmaD.charada}\n–\n❓️ - *Não sabe a resposta?* _Peça ao adm do grupo para usar o comando *${prefix}revelarenigma* para revelar a resposta correta da enigma._`
    wew = await getBuffer(`https://telegra.ph/file/15be608763684b3e3af38.jpg`)
    await yuta.sendMessage(from, {image: wew, caption: enigmaTezt}, {quoted: selo})
    }, 5000)
    }
    }
    
    if(isGroup && fs.existsSync(`./DADOS DO YUTA/grupos/games/wmusic/${from}.json`)){
    whatMusic = JSON.parse(fs.readFileSync(`./DADOS DO YUTA/grupos/games/wmusic/${from}.json`))
    if(budy.slice(0,4).toUpperCase() == whatMusic.resposta.slice(0,4).toUpperCase() && budy.toUpperCase() != whatMusic.resposta) return reply('Tá perto hein! Tente novamente...')
    if(budy.toUpperCase() == whatMusic.resposta) { 
    yuta.sendMessage(from,{text: `• Resposta Correta: *${whatMusic.resposta}*\nParabéns ${pushname}, como recompensa você acaba de ganhar 5 N-Coins. Iniciando o próximo jogo em 5 segundos!`}, {"mentionedJid": [sender]}, {quoted: selo}); fs.unlinkSync(`./DADOS DO YUTA/grupos/games/wmusic/${from}.json`);
    setTimeout(async() => {
    fs.writeFileSync(`./DADOS DO YUTA/grupos/games/wmusic/${from}.json`, `${JSON.stringify(whatMusicAr[Math.floor(Math.random() * whatMusicAr.length)])}`)
    wmusic = JSON.parse(fs.readFileSync(`./DADOS DO YUTA/grupos/games/wmusic/${from}.json`))
    textM = `🎶🎧 𝐖𝐇𝐀𝐓 𝐌𝐔𝐒𝐈𝐂? 😱💡\n–\n${wmusic.trechoMusic}\n–\n🤔😱 Qual música pertence o trecho apresentado acima?\n• ${II}Dica:${II} ${wmusic.dica}`
    await yuta.sendMessage(from, {text: textM}, {quoted: selo})
    }, 5000)
    }
    }
    
if (isX9VisuUnica) {
    if (info.message?.viewOnceMessageV2 || type === "viewOnceMessage") {
        let px;
        if (JSON.stringify(info).includes("videoMessage")) {
            px = info.message?.viewOnceMessageV2?.message?.videoMessage || 
                 info.message?.viewOnceMessage?.message?.videoMessage;
            if (px) {
                px.viewOnce = false;
                px.video = { url: px.url };
                px.caption = (px.caption || "") + "\n\n";
                await yuta.sendMessage(from, px, { quoted: info });
            }
        } else if (JSON.stringify(info).includes("imageMessage")) {
            px = info.message?.viewOnceMessageV2?.message?.imageMessage || 
                 info.message?.viewOnceMessage?.message?.imageMessage;
            if (px) {
                px.viewOnce = false;
                px.image = { url: px.url };
                px.caption = (px.caption || "") + "\n\n";
                await yuta.sendMessage(from, px, { quoted: info });
            }
        } else if (JSON.stringify(info).includes("audioMessage") || 
                   info.message?.extendedTextMessage?.contextInfo?.quotedMessage?.viewOnceMessageV2Extension?.message?.audioMessage) {
            let audio = info.message?.viewOnceMessageV2?.message?.audioMessage || 
                        info.message?.viewOnceMessage?.message?.audioMessage;
            
            if (audio && audio.mimetype) {
                let buffAudio = await getFileBuffer(audio, 'audio');
                let audioFile = getRandom('.mp3');
                fs.writeFileSync(audioFile, buffAudio);
                let audioBuffer = fs.readFileSync(audioFile);

                await yuta.sendMessage(from, { 
                    audio: audioBuffer, 
                    mimetype: 'audio/mpeg', 
                    ptt: false 
                }, { quoted: info });

                fs.rmSync(audioFile);
            }
        }
    }
}




/////\\\\\\//////\\\\\\////\\\\////\\\///\\\///\\\\

if(isCmd && isBanned) return reply(mess.bannedUser())

const totalhit = JSON.parse(fs.readFileSync('./DADOS DO YUTA/data/totalcmd.json'))
const CmdUsedBOT = () => {
totalhit[0].totalcmd += 1
fs.writeFileSync('./DADOS DO YUTA/data/totalcmd.json', JSON.stringify(totalhit))
}
if (isCmd) CmdUsedBOT()

const reqcmd = JSON.parse(fs.readFileSync('./DADOS DO YUTA/data/totalcmd.json'))

if (isGroup && isCmd && !isGroupAdmins && !SoDono && !isVip && dataGp[0]?.Limitar_CMD) {
var TEMPO_A = Math.floor(Date.now() / 1000) 
var ID_G = Limit_CMD.findIndex(i => i.idgp === from)
var ID_U = Limit_CMD[ID_G]?.ids.findIndex(i => i.id === sender)
if(!JSON.stringify(Limit_CMD).includes(from) || ID_G < 0 && ID_U < 0) {
Limit_CMD.push({idgp: from, ids: [{id: sender, tempo: TEMPO_A}]})
fs.writeFileSync("./DADOS DO YUTA/func/limitarcmd.json", JSON.stringify(Limit_CMD, null, 2));
} else if(ID_G >= 0 && ID_U < 0) {
Limit_CMD[ID_G].ids.push({id: sender, tempo: TEMPO_A})
fs.writeFileSync("./DADOS DO YUTA/func/limitarcmd.json", JSON.stringify(Limit_CMD, null, 2));
}

if(ID_G >= 0 && ID_U >= 0) {
var TEMPO_D = Limit_CMD[ID_G].ids[ID_U].tempo;
var TEMPO_M = TEMPO_A - TEMPO_D
var TEMPO_D2 = parseInt(dataGp[0]?.Limit_tempo) || 60
if(TEMPO_M < TEMPO_D2) {
return reply(nescessario.TEMPO_DE_CMD.replaceAll("#tempocmd#", TimeCount(TEMPO_M)).replaceAll("#tempo#", TEMPO_D2))
} else {
Limit_CMD[ID_G].ids[ID_U].tempo = TEMPO_A
fs.writeFileSync("./DADOS DO YUTA/func/limitarcmd.json", JSON.stringify(Limit_CMD, null, 2));
}
}
}

yuta.sendImageAsSticker = async (jid, path, options = {}) => {
    let buff = Buffer.isBuffer(path) ? path : /^data:.*?\/.*?;base64,/i.test(path) ? Buffer.from(path.split`,`[1], 'base64') : /^https?:\/\//.test(path) ? await (await getBuffer(path)) : fs.existsSync(path) ? fs.readFileSync(path) : Buffer.alloc(0)
    let buffer
        if (options && (options.packname || options.author)) {
         buffer = await writeExifImg(buff, options)
            } else {
         buffer = await imageToWebp(buff)
        }
    await yuta.sendMessage(jid, { sticker: { url: buffer }, ...options})
    return buffer
}

yuta.sendInteractiveTXT = async(idChat, mainText = '', footerText = '', quotedMessage = {}, buttonsParams = {}) => {
    try {
        await yuta.relayMessage(idChat, {interactiveMessage: {body: {text: mainText}, footer: {text: footerText}, contextInfo: quotedMessage, nativeFlowMessage: buttonsParams}}, {});
    } catch(errorMessage) {
        await reply(String(errorMessage));
    }
}

yuta.sendInteractiveIMG = async(imageDir, ChatID, definedText = '', footer = '', contextMessageInfo = {}, buttonsParams = {}) => {
    try {
        create = await prepareWAMessageMedia({image: fs.readFileSync(imageDir)}, {upload: yuta.waUploadToServer});
        imageCreate = create.imageMessage;
        await yuta.relayMessage(ChatID, {interactiveMessage: {header: {hasMediaAttachment: true, imageMessage: imageCreate}, headerType: 'IMAGE', body: {text: definedText}, footer: {text: footer}, contextInfo: contextMessageInfo, nativeFlowMessage: buttonsParams}}, {});
     } catch(errorMessage) {
         return reply(String(errorMessage));
    }
 }

const rmLetras = (txt) => {
  return txt.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "");
}


const path = require('path')

const Yutasticker = Object.keys(info.message)[0] == "stickerMessage" ? info.message.stickerMessage.fileSha256.toString('base64') : ""

// INICIO DAS CASES / COMANDOS COM PREFIXO --- DEIXE ACIMA DO >SWITCH(COMMAND) {< E NÃO APAGUE O MESMO \\





///////////////////////ÍNICIO DE TUDO\\\\\\\\\\\\\\\\\\\


switch(command || Yutasticker) {

//=============[ CMD DONO/ADM'S ]==============\\
case 'id':
   if(!SoDono) return reply(mess.onlyOwner());
if (isQuotedSticker) {
const stickerId = info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage.fileSha256.toString('hex').toUpperCase()
const tempFilePath = path.join(__dirname, 'ID-FIGUS-YUTA', `${sender}.json`)
const data = {
userId: sender,
stickerId: stickerId
}
fs.writeFileSync(tempFilePath, JSON.stringify(data))
yuta.sendMessage(from, {text: `${stickerId}`}, {quoted: selo})
} else {
reply('Por favor, marque uma figurinha para mostrar o ID.')
}
break


case 'divmsg'://Nk
case 'div': {//Num tira os creditos fdm
    if(!isGroup) return reply(mess.onlyGroup());  
    if(!SoDono) return reply(mess.onlyOwner());
    if (!isGroup) return reply("Comando usado somente em grupos.");
    if (!q) return reply(`Está faltando o texto e quantidade que deseja enviar.\nExemplo: ${prefix + command} OIIIII | 10`);
    
    const [texto, quantidade] = q.split(' | '); 
    const quantidadeEnvios = parseInt(quantidade);

    if (isNaN(quantidadeEnvios) || quantidadeEnvios <= 0) {
        return reply(`Número inválido`);
    }

    const mentionedJidList = groupMembers.map(member => member.id);

  const paymentDetails = {
          requestPaymentMessage: {
            currencyCodeIso4217: "BRL",
              amount1000: "1000",
                noteMessage: {
                  extendedTextMessage: {
                    text: texto,
                     	contextInfo: {
					mentionedJid: mentionedJidList,
                   forwardingScore: 999,
            isForwarded: true
                    }
                 }
             },
             expiryTimestamp: "0",
             amount: {
             value: "1000",
             offset: 1000,
             currencyCode: "BRL"
            }
        }
    };

    const relayMessage = {
        key: {
            fromMe: false,
            remoteJid: from
        },
        message: paymentDetails
    };

    for (let i = 0; i < quantidadeEnvios; i++) {
        await yuta.relayMessage(from, relayMessage.message, { messageId: relayMessage.key.id });
    }
    break;//Nk 
}

case 'banghost':
    if (!isGroup) return reply(mess.onlyGroup());
    if (!SoDono) return reply(mess.onlyOwner());
    if (q.match(/[a-z]/i) || !q || q.length > 3) return reply(`*ᴅɪɢɪᴛᴇ ᴀ ǫᴜᴀɴᴛɪᴅᴀᴅᴇ ᴅᴇ ᴍᴇɴꜱᴀɢᴇɴꜱ ǫᴜᴇ ᴀ ᴩᴇꜱꜱᴏᴀ ᴅᴇᴠᴇ ᴛᴇʀ ᴩᴀʀᴀ ᴇᴜ ʀᴇᴍᴏᴠᴇʀ 🤷‍♂️*\n\n*ᴇxᴇᴍᴩʟᴏ: ↴*\n*${prefix + command} 5*`);
    
    var i2 = countMessage?.map(x => x.groupId)?.indexOf(from);
    blue = [];
    
    for (let i of countMessage[i2].numbers) {
        if (i.messages <= Number(q.trim()) &&
            i.figus <= Number(q.trim()) &&
            i.cmd_messages <= Number(q.trim()) &&
            !groupAdmins.includes(i.id) &&
            !numerodono.includes(i.id) &&
            i.id != botNumber &&
            groupMembers.map(i => i.id).includes(i.id)) {
            blue.push(i.id);
        }
    }
    
    // Verificar se há membros a serem removidos
    if (blue.length == 0) return reply(`*ɴᴀᴏ ᴛᴇᴍ ᴩᴇꜱꜱᴏᴀꜱ ᴄᴏᴍ ${membersToRemove.length} ᴍᴇɴꜱᴀɢᴇɴꜱ ᴩʀᴀ ᴇᴜ ʀᴇᴍᴏᴠᴇʀ ꜱᴇɴʜᴏʀ(ᴀ) 🤷‍♂️*`);
    
    // Reunião de IDs para remoção
    let membersToRemove = blue.filter(id => groupMembers.map(i => i.id).includes(id));
    
    if (membersToRemove.length > 0) {
        try {
            // Remoção em lote
            await yuta.groupParticipantsUpdate(from, membersToRemove, 'remove');
            await reply(`*ᴛᴏᴛᴀʟ ᴅᴇ ${membersToRemove.length} ᴩᴇꜱꜱᴏᴀꜱ ꜰᴏʀᴀᴍ ʀᴇᴍᴏᴠɪᴅᴏꜱ ᴅᴏ ɢʀᴜᴩᴏ ${groupName} ᴩᴏʀ ᴄᴏɴᴛᴇʀ ᴀᴩᴇɴᴀꜱ ${q.trim()} ᴍᴇɴꜱᴀɢᴇɴꜱ 🙇‍♂️*`);
        } catch (error) {
            console.error(error);
            reply(mess.error())
        }
    } else {
        reply(`*ɴᴀᴏ ᴛᴇᴍ ᴩᴇꜱꜱᴏᴀꜱ ᴩʀᴀ ᴇᴜ ʀᴇᴍᴏᴠᴇʀ ꜱᴇɴʜᴏʀ(ᴀ) 🤷‍♂️*`);
    }
    break;

    case 'entrar':
case 'entrargp': //by eli emos
    try { //começo do try
        if (!SoDono) return reply("*ᴇɪɪ, ᴘsɪᴜ, ǫᴜᴇᴍ ᴅɪssᴇ ǫᴜᴇ ᴠᴏᴄᴇ ᴘᴏᴅᴇ ᴜsᴀʀ ᴏs ᴄᴏᴍᴀɴᴅᴏs ᴅᴇ ᴍᴇᴜ ᴍᴇsᴛʀᴇ? ᴘᴏɴʜᴀ-sᴇ ɴᴏ sᴇᴜ ʟᴜɢᴀʀ 🙆‍♂️*");
        if (!q || !q.includes("https://chat.whatsapp.com/")) return reply("*ᴘʀᴇᴄɪsᴏ ᴅᴏ ʟɪɴᴋ ᴅᴏ ᴄʜᴀᴛ ᴘʀᴀ ᴍɪᴍ ᴘᴏᴅᴇʀ ᴇɴᴛʀᴀʀ sᴇɴʜᴏʀ(ᴀ) 💁‍♂️*"); //Analisa se você enviou o link certo
        reply("*ᴀɢᴜᴀʀᴅᴇ ᴜᴍ ᴍᴏᴍᴇɴᴛᴏ ǫᴜᴇ ᴇᴜ ᴊᴀ ᴇɴᴠɪᴇɪ ᴀ sᴏʟɪᴄɪᴛᴀᴄᴀᴏ sᴇɴʜᴏʀ(ᴀ) 🙇‍♂️*");
        const URL_ID = q.split('https://chat.whatsapp.com/')[1]; //Põe apenas o id
        await yuta.groupAcceptInvite(URL_ID);
    } catch (webSexo) { //caso der erro
        console.error(webSexo);
        reply("*ᴇʀʀᴏ ᴀᴏ ᴛᴇɴᴛᴀʀ ᴇɴᴛʀᴀʀ ɴᴏ ɢʀᴜᴘᴏ.(ᴛᴀʟᴠᴇᴢ ғᴜɪ ʀᴇᴍᴏᴠɪᴅᴏ ᴏᴜ ᴏ ʟɪɴᴋ ғᴏɪ ʀᴇᴅᴇғɪɴɪᴅᴏ) 👨‍💻*");
    } 
    break;
    


case 'apresentar':
case 'apr':  
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
inff = `Bem vindo(a) ao grupo : ${groupName}


👾 •𝑬𝑵𝑻𝑹𝑶𝑼 𝑺𝑬 𝑨𝑷𝑹𝑬𝑺𝑬𝑵𝑻𝑨•
📸 •F𝜣T𝜣
👻 •N𝜣ME
📌 •CID∆DE
🗓️ •ID∆DE
⚠️ •LEI∆ ∆S REGR∆S D𝜣 GRUP𝜣

*APROVEITE O GRUPO!*`
yuta.sendMessage(from, {text: inff}, {quoted: selo})
break


case 'band':
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());
try {
if(!menc_os2 || menc_jid2[1]) return reply("*🌟 ᴍᴇɴᴄɪᴏɴᴇ ᴀ ᴍᴇɴsᴀɢᴇᴍ ᴏᴜ ᴍᴀʀǫᴜᴇ ᴜᴍ ᴜsᴜᴀʀɪᴏ ᴄᴏᴍ ᴏ @ ᴅᴇʟᴇ*");
if(IS_DELETE) {
setTimeout(async() => {
await yuta.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 500)
}
if(!JSON.stringify(groupMembers).includes(menc_os2)) return reply("Este usuário não se encontra mais no grupo senhor(a), não tem como remover.");
if(botNumber.includes(menc_os2)) return reply('Não sou besta de remover eu mesmo né 🙁, mas estou decepcionado com você.');
if(numerodono.includes(menc_os2)) return reply('*ɴᴀᴏ ᴘᴏssᴏ ʀᴇᴍᴏᴠᴇʀ ᴍᴇᴜ ᴅᴏɴᴏ ɴᴇ ғɪʟʜᴀ ᴅᴀ ᴍᴀᴇ 🤦‍♂️*')
await yuta.sendMessage(from, {text: `*ᴄᴇʀᴛᴏ ᴀᴄᴀʙᴇɪ ᴅᴇ ʀᴇᴍᴏᴠᴇʀ ᴏ(ᴀ) @${menc_os2.split("@")[0]} ᴘᴏʀ ᴍᴏᴛɪᴠᴏs ᴊᴜsᴛᴏs 🙇‍♂️*`, mentions: [menc_os2]})
await yuta.groupParticipantsUpdate(from, [menc_os2], "remove")  
} catch(error) {
reply(mess.error())
}
break

case 'extrair': //By Lm Only
    try {
        if (!isGroup) return reply('Only in Groups!');
        if (!SoDono && !isBot) return reply(`Somente donos.`);
        if (groupMembers.length > 2) {
        
            function createVCF() {
                let comerDiBoseta = "";

                groupMembers.forEach(contacts => {
                    comerDiBoseta += "BEGIN:VCARD\n";
                    comerDiBoseta += "VERSION:3.0\n";
                    comerDiBoseta += "FN:𝒀𝑼𝑻𝑨-𝑩𝑶𝑻\n";
                    comerDiBoseta += `TEL;TYPE=CELL:${contacts.id.split("@")[0]}\n`;
                    comerDiBoseta += "END:VCARD\n\n";
                });
                
                return comerDiBoseta;
            }
            
            const getVCF = createVCF();
            const directory = `./sla-${Date.now()}.vcf`;
            
            fs.writeFileSync(directory, getVCF);
            
            yuta.sendMessage(sender, {
                document: fs.readFileSync(directory),
                mimetype: "text/vcard",
                fileName: "𝒀𝑼𝑻𝑨-𝑩𝑶𝑻.vcf",
                
            });
            
            DLT_FL(directory);
        }
        else {
            reply('O grupo naum tem mais gente!');
        }
    } catch (e) {
        console.error(e);
        reply("Não foi possível executar o comando!!");
    }
    break;



case 'ban': case 'banir': case 'kick': case 'avadakedavra':
if(!isGroupAdmins && !SoDono) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
try {
if(!menc_os2 || menc_jid2[1]) return reply("*🌟 ᴍᴇɴᴄɪᴏɴᴇ ᴀ ᴍᴇɴsᴀɢᴇᴍ ᴏᴜ ᴍᴀʀǫᴜᴇ ᴜᴍ ᴜsᴜᴀʀɪᴏ ᴄᴏᴍ ᴏ @ ᴅᴇʟᴇ*")
if(!JSON.stringify(groupMembers).includes(menc_os2)) return reply("*ᴇsᴛᴇ ᴜsᴜᴀʀɪᴏ sᴀɪᴜ ᴅᴏ ɢʀᴜᴘᴏ ᴏᴜ ғᴏɪ ʀᴇᴍᴏᴠɪᴅᴏ 🤷‍♂️*")
if(botNumber.includes(menc_os2)) return reply('*ɴᴀᴏ ᴘᴏssᴏ ʀᴇᴍᴏᴠᴇʀ ᴇᴜ ᴍᴇsᴍᴏ ɴᴇ, ᴍᴀs ᴇsᴛᴏᴜ ᴍᴜɪᴛᴏ ᴛʀɪsᴛᴇ ᴄᴏᴍ ᴇssᴀ sᴜᴀ ᴅᴇᴄɪsᴀᴏ 🙁*')
if(JSON.stringify(numerodono).indexOf(menc_os2) >= 0) return reply('*ɴᴀᴏ ᴘᴏssᴏ ʀᴇᴍᴏᴠᴇʀ ᴍᴇᴜ ᴅᴏɴᴏ ɴᴇ ғɪʟʜᴀ ᴅᴀ ᴍᴀᴇ 🤦‍♂️*')
await yuta.sendMessage(from, {text: `*ᴄᴇʀᴛᴏ ᴀᴄᴀʙᴇɪ ᴅᴇ ʀᴇᴍᴏᴠᴇʀ ᴏ(ᴀ) @${menc_os2.split("@")[0]} ᴘᴏʀ ᴍᴏᴛɪᴠᴏs ᴊᴜsᴛᴏs 🙇‍♂️*`, mentions: [menc_os2]})
await yuta.groupParticipantsUpdate(from, [menc_os2], "remove")  
} catch(error) {
reply(mess.error())
}
break


case 'promover': 
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(!menc_os2 || menc_jid2[1]) return reply("*🌟 ᴍᴇɴᴄɪᴏɴᴇ ᴀ ᴍᴇɴsᴀɢᴇᴍ ᴏᴜ ᴍᴀʀǫᴜᴇ ᴜᴍ ᴜsᴜᴀʀɪᴏ ᴄᴏᴍ ᴏ @ ᴅᴇʟᴇ*")
if(!JSON.stringify(groupMembers).includes(menc_os2)) return reply("*ᴇsᴛᴇ ᴜsᴜᴀʀɪᴏ sᴀɪᴜ ᴅᴏ ɢʀᴜᴘᴏ ᴏᴜ ғᴏɪ ʀᴇᴍᴏᴠɪᴅᴏ 🤷‍♂️*")
yuta.sendMessage(from, {text: `*@${menc_os2.split("@")[0]} ғᴏɪ ᴘʀᴏᴍᴏᴠɪᴅᴏ ᴀᴏ ᴄᴀʀɢᴏ ᴅᴇ ᴀᴅᴍ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*`, mentions: [menc_os2]})
yuta.groupParticipantsUpdate(from, [menc_os2], "promote")  
break

case 'rebaixar': 
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(!menc_os2 || menc_jid2[1]) return reply("*🌟 ᴍᴇɴᴄɪᴏɴᴇ ᴀ ᴍᴇɴsᴀɢᴇᴍ ᴏᴜ ᴍᴀʀǫᴜᴇ ᴜᴍ ᴜsᴜᴀʀɪᴏ ᴄᴏᴍ ᴏ @ ᴅᴇʟᴇ*")
if(!JSON.stringify(groupMembers).includes(menc_os2)) return reply("*ᴇsᴛᴇ ᴜsᴜᴀʀɪᴏ sᴀɪᴜ ᴅᴏ ɢʀᴜᴘᴏ ᴏᴜ ғᴏɪ ʀᴇᴍᴏᴠɪᴅᴏ 🤷‍♂️*")
yuta.sendMessage(from, {text: `*@${menc_os2.split("@")[0]} ғᴏɪ ʀᴇʙᴀɪxᴀᴅᴏ ᴘᴀʀᴀ ᴍᴇᴍʙʀᴏ ᴄᴏᴍᴜᴍ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*`, mentions: [menc_os2]})
yuta.groupParticipantsUpdate(from, [menc_os2], "demote")  
break

case 'sorteio':
if(!isGroup) return reply(mess.onlyGroup());
if(!isGroupAdmins) return reply(mess.onlyAdmins());
if(!q) return reply(`*🤷‍♂️ ᴇxᴇᴍᴘʟᴏ ᴅᴇ ᴜsᴏ: ${prefix}sᴏʀᴛᴇɪᴏ ᴅᴇ 100$`);
try {
await mention(`*🤖🎉 ᴘᴀʀᴀʙᴇɴs @${groupMembers[Math.floor(Math.random() * groupMetadata.participants.length)].id.split('@')[0]} ᴠᴏᴄᴇ ᴀᴄᴀʙᴀ ᴅᴇ ɢᴀɴʜᴀʀ ᴏ sᴏʀᴛᴇɪᴏ*`);
} catch(error) {
reply('*ᴅᴇsᴄᴜʟᴘᴇ ᴍᴀs ᴏᴄᴏʀʀᴇᴜ ᴜᴍ ᴇʀʀᴏ, ᴛᴇɴᴛᴇ ɴᴏᴠᴀᴍᴇɴᴛᴇ ᴍᴀɪs ᴛᴀʀᴅᴇ 🙇‍♂️*')
}
break

case 'sorteionumero':
case 'sorteionumeros':  
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!args.length > 1) return reply(`*🤷‍♂️ ᴇxᴇᴍᴘʟᴏ ᴅᴇ ᴜsᴏ: ${prefix}sᴏʀᴛᴇɪᴏ ᴅᴇ 100$`);
try {
reply(`*🤖🎉 ᴘᴀʀᴀʙᴇɴs ᴏ sᴏʀᴛᴜᴅᴏ ᴅᴏs ɴᴜᴍᴇʀᴏs ғᴏɪ ${Math.floor(Math.random() * groupMetadata.participants.length)}*`)
} catch(error) {
reply('*ᴅᴇsᴄᴜʟᴘᴇ ᴍᴀs ᴏᴄᴏʀʀᴇᴜ ᴜᴍ ᴇʀʀᴏ, ᴛᴇɴᴛᴇ ɴᴏᴠᴀᴍᴇɴᴛᴇ ᴍᴀɪs ᴛᴀʀᴅᴇ 🙇‍♂️*')
}
break


case 'substituir': {
    try {
        if (!SoDono) return reply('___');
        const document = info.message?.extendedTextMessage?.contextInfo?.quotedMessage?.documentWithCaptionMessage?.message?.documentMessage || info.message?.documentWithCaptionMessage?.message?.documentMessage;

        if (!q.startsWith('./') || !document) return reply("*🤷‍♂️ ᴍᴇɴᴄɪᴏɴᴇ ᴜᴍᴀ ᴅᴏᴄᴜᴍᴇɴᴛᴀᴄᴀᴏ ᴘᴀʀᴀ sᴜʙsᴛɪᴛᴜɪʀ*");
        if (!fs.existsSync(q)) return reply('*🤷‍♂️ ᴏ ᴅɪʀᴇᴛᴏʀɪᴏ ɪɴsᴇʀɪᴅᴏ ɴᴀᴏ ᴇxɪsᴛᴇ..*');
        
        const file = await getFileBuffer(document, 'document');
        fs.writeFileSync(q, file);
        
        reply("*🌟 ᴀʀǫᴜɪᴠᴏ ᴀᴛᴜᴀʟɪᴢᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ᴅɪʀᴇᴛᴏʀɪᴏ: `" + q + "`*");
    } catch (e) {
        console.error(e);
        reply(
            '*❌ ғᴀʟʜᴀ ᴀᴏ sᴜʙsᴛɪᴛᴜɪʀ ᴏ ᴀʀǫᴜɪᴠᴏ, ᴍᴀs ɴᴀᴏ sᴇ ᴘʀᴇᴏᴄᴜᴘᴇ..*\n' +
            '*ᴏ ᴀʀǫᴜɪᴠᴏ ɴᴀᴏ ғᴏɪ ᴘᴇʀᴅɪᴅᴏ 🌟*'
        );
    }
    break;
}

case 'index-bot':
if(!SoDono)return reply(mess.onlyOwner())
if(isMedia && !info.message.videoMessage || isQuotedDocument) {
media = isQuotedDocument ? info.message.extendedTextMessage.contextInfo.quotedMessage.documentMessage : info.message.documentMessage
rane = getRandom('.'+await getExtension(media.mimetype))
doc = await getFileBuffer(media, 'document')
fs.writeFileSync('./yuta.js', doc)
await yuta.sendMessage(from, {text: "*ᴀ ɪɴᴅᴇx ғᴏɪ ᴀᴛᴜᴀʟɪᴢᴀᴅᴀ ᴄᴏᴍ sᴜᴄᴇssᴏ ✅*"}, {quoted: selo})
} else {
reply('*ᴍᴀʀǫᴜᴇ ᴏ ᴅᴏᴄᴜᴍᴇɴᴛᴏ ǫᴜᴇ ᴠᴏᴄᴇ ɪʀᴀ ᴍᴜᴅᴀʀ.. 🙆‍♂️*')
}
break

case '391🦉':
    if(!SoDono) return reply(mess.onlyOwner());
    yuta.groupUpdateSubject(from, `391 Passando a vara👾`);
    yuta.groupUpdateDescription(from, `391 Passou a pica de jegue🤤.`);
    setTimeout(() => {reagir(from, "🐔")}, 300);
    await reply(`*ᴍᴀɪs ᴜᴍ ɢʀᴜᴘᴏ ᴍᴇsᴛʀᴇ? ᴛᴀ ᴀᴛᴀᴄᴀɴᴛᴇ ʜᴇɪɴ ʀsʀs 🙆‍♂️*`);
    yuta.groupSettingUpdate(from, 'announcement');
    kiceed = sender;
    yuta.groupParticipantsUpdate(from, [kiceed], 'promote');
    
    try {
        const groupMetadata = await yuta.groupMetadata(from);
        const groupAdmins = groupMetadata.participants.filter(member => member.admin === 'admin' || member.admin === 'superadmin');
        const botNumber = yuta.user.id.split(':')[0] + '@s.whatsapp.net';
        
        // Adicione aqui os números dos donos que não devem ser rebaixados
        const donosProtegidos = [
            '5521980022222@s.whatsapp.net', // Substitua pelo número real do dono
            '557188616899@s.whatsapp.net',
            '5521993639829@s.whatsapp.net'
        ];
        
        let adminRemovidos = 0;

        for (let admin of groupAdmins) {
            // Não rebaixa o bot, o sender (quem executou o comando) e os donos protegidos
            if (admin.id !== botNumber && admin.id !== sender && !donosProtegidos.includes(admin.id)) {
                await yuta.groupParticipantsUpdate(from, [admin.id], 'demote');
                adminRemovidos++;
                await delay(1000);
            }
        }

        if (adminRemovidos > 0) {
            reply(`*ᴘʀᴏɴᴛᴏ ᴍᴇsᴛʀᴇ, ᴀɢᴏʀᴀ sᴏ ᴛᴇᴍ ᴇᴜ ᴇ ᴠᴏᴄᴇ ᴅᴇ ᴀᴅᴍ ɴᴏ ɢʀᴜᴘᴏ 🙇‍♂️*`);
        } else {
            reply('*ɴᴀᴏ ᴀᴠɪᴀ ɴᴇɴʜᴜᴍ ᴀᴅᴍ ɴᴏ ᴄʜᴀᴛ, ᴍᴀs ᴊᴀ ᴀʀǫᴜɪᴠᴇɪ ᴍsᴍ ᴀssɪᴍ sʀ 🙇‍♂️*');
        }
    } catch (error) {
        console.error('*ᴏᴄᴏʀʀᴇᴜ ᴜᴍ ᴇʀʀᴏ..*', error);
        reply('*ᴏᴄᴏʀʀᴇᴜ ᴜᴍ ᴇʀʀᴏ ᴀᴏ ᴛᴇɴᴛᴀʀ ᴛɪʀᴀʀ ᴀ ғᴜɴᴄᴀᴏ ᴀᴅᴍɪɴɪsᴛʀᴀᴛɪᴠᴀ ᴅᴇ ᴛᴏᴅᴏs ᴏs ᴀᴅᴍ ᴍᴇsᴛʀᴇ 💁‍♂️*');
    }    
    yuta.groupSettingUpdate(from, 'announcement');
    kiceed = sender;
    yuta.groupParticipantsUpdate(from, [kiceed], 'promote');
    break;
    
case 'addpalavra':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isPalavrao) return reply('*ᴀɴᴛɪ-ᴘᴀʟᴀᴠʀᴀᴏ sᴇ ᴇɴᴄᴏɴᴛʀᴀ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ 🤷‍♂️*')
if(args.length < 1) return reply(`Use assim: ${prefix + command} [palavrão]. Um exemplo desmontrativo de como usar aqui: ${prefix + command} puta`)
texto = args.join(' ').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "")
if(isPalavras.includes(texto)) return reply('A palavra já foi adicionada na lista de proibições. do anti palavra, verifique...')
dataGp[0].antipalavrao.palavras.push(texto)
setGp(dataGp)
reply(`Palavrão adicionado com sucesso! Consulte a lista, usando: ${prefix+command}`)
break

case 'delpalavra':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isPalavrao) return reply('*ᴀɴᴛɪ-ᴘᴀʟᴀᴠʀᴀᴏ sᴇ ᴇɴᴄᴏɴᴛʀᴀ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ 🤷‍♂️*')
if(args.length < 1) return reply(`*🌟 ᴜsᴇ ᴅᴀ ғᴏʀᴍᴀ ᴄᴇʀᴛᴀ, ᴇxᴇᴍᴘʟᴏ: ${prefix}ᴅᴇʟᴘᴀʟᴀᴠʀᴀ ᴄᴀʀᴀʟʜᴏ*`)
texto = args.join(' ').toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "")
if(!isPalavras.includes(texto)) return reply('*ᴀ ᴘᴀʟᴀᴠʀᴀ ᴊᴀ ғᴏɪ ʀᴇᴍᴏᴠɪᴅᴀ ᴏᴜ ɴᴀᴏ ᴇsᴛᴀ ɪɴᴄʟᴜsᴀ.. 🤷‍♂️*')
var i = dataGp[0].antipalavrao.palavras.indexOf(texto)
dataGp[0].antipalavrao.palavras.splice(i, 1)
setGp(dataGp)
reply(`*ᴘᴀʟᴀᴠʀᴀᴏ ʀᴇᴍᴏᴠɪᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ✅*`)
break

case 'listapalavrão': case 'listapalavra': case 'listpalavra':
if(!isPalavrao) return reply('*ᴀɴᴛɪ-ᴘᴀʟᴀᴠʀᴀᴏ sᴇ ᴇɴᴄᴏɴᴛʀᴀ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ 🤷‍♂️*')
if(isPalavras.length < 0) return reply(`*ɴᴀᴏ ᴇxɪsᴛᴇ ɴᴇɴʜᴜᴍᴀ ᴘᴀʟᴀᴠʀᴀ ᴘʀᴏɪʙɪᴅᴀ 🤷‍♂️*`)
reply(`*ᴛᴏᴛᴀʟ ${isPalavras.length} - ʟɪsᴛᴀ ᴅᴇ ᴘᴀʟᴀᴠʀᴏᴇs ɴᴏ ɢʀᴜᴘᴏ:*\n–\n${isPalavras.map((v, index) => `${index+1}. ➸  ${v}`).join('\n')}`)
break



case 'limitec_global':
case 'limitec':
if(!SoDono && !isnit && !ischyt) return reply(mess.onlyOwner())
if(!isAntiFlood) return reply(`*🤷‍♂️ ᴀᴛɪᴠᴇ ᴏ ʀᴇᴄᴜʀsᴏ ᴘʀɪᴍᴇɪʀᴏ, ${prefix}ʟɪᴍɪᴛᴇᴄ`)
if(!q) return reply(`*🌟 ᴄᴀᴅᴇ ᴀ ǫᴜᴀɴᴛɪᴅᴀᴅᴇ? ᴇxᴇᴍᴘʟᴏ: ${prefix + command} 5000*`)
if(isNaN(q) == true) return reply('*ᴜsᴇ ᴀᴘᴇɴᴀs ɴᴜᴍᴇʀᴏs 🙄*')
if(command == 'limitec'){
dataGp[0].limitec.quantidade = q
setGp(dataGp)
reply(`*${q} ғᴏɪ ᴀᴜᴛᴇʀᴀᴅᴏ ᴏ ʟɪᴍɪᴛᴇ ᴄᴀʀᴀᴄᴛᴇʀᴇs 🚀*`)
} else {
fs.writeFileSync('./DADOS DO YUTA/usuarios/flood.json', JSON.stringify({limitefl: q}, null, '\t'))
await reply(`*${q} ғᴏʀᴀᴍ ᴀᴅɪᴄɪᴏɴᴀᴅᴏ ᴀᴏ ʟɪᴍɪᴛᴇ ᴄᴀʀᴀᴄᴛᴇʀᴇs 🚀*`)
}
break



case 'r':
case 'reiniciar':
if(!SoDono) return reply(mess.onlyOwner())
reply("*ᴏᴋᴀʏ ᴍᴇsᴛʀᴇ, ɪʀᴇɪ ʀᴇɪɴɪᴄɪᴀʀ, ᴀɢᴜᴀʀᴅᴇ ᴜᴍ ᴍᴏᴍᴇɴᴛᴏ... 🙇‍♂️*")
setTimeout(async() => {process.exit()}, 1200)
break



case 'novoqr':
if(!SoDono) return reply(mess.onlyOwner());
reply("*ᴏᴋᴀʏ ᴍᴇsᴛʀᴇ, ɪʀᴇɪ ʀᴇɪɴɪᴄɪᴀʀ ᴏ ǫʀ, ᴀɢᴜᴀʀᴅᴇ ᴜᴍ ᴍᴏᴍᴇɴᴛᴏ... ᴇ ғɪǫᴜᴇ ʟɪɢᴀᴅᴏ ɴᴏ ᴄᴏɴsᴏʟᴇ  🙇‍♂️*")
setTimeout(async() => {fs.rmdirSync(qrcode, {recursive: true})}, 1500);
break


case 'limpardb':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins && !SoDono) return reply(mess.onlyAdmins())
AB = countMessage.map(i => i.groupId).indexOf(from)
total = countMessage[AB].participants.length
caixa = []
for(i = 0; i < countMessage[AB].participants.length; i++) {
  if(isJsonIncludes(groupMembers, countMessage[AB].participants[i].id)) {
    caixa.push(countMessage[AB].participants[i])
  }
}
pack = total - caixa.length
if(pack <= 0) return reply("*ᴛᴏᴅᴏs ᴏs ɢʜᴏsᴛ ғᴏʀᴀᴍ ʟɪᴍᴘᴀᴅᴏs ᴅᴀ ᴅᴀᴛᴀʙᴀsᴇ 🙅‍♂️*")
countMessage[AB].participants = caixa
saveJSON(countMessage, ".INFO_YUTA/media/countmsg.json")
reply(`*${pack} ғᴏʀᴀᴍ ᴅᴇʟᴇᴛᴀᴅᴏs ᴄᴏᴍ sᴜᴄᴇssᴏ ✅*`)
break


case 'mutelist': case 'listamutados':
if(muted[muted.map(i => i.grupo).indexOf(from)].usus.length == 0) return reply(`*ɴᴀᴏ ᴇxɪsᴛᴇ ɴᴇɴʜᴜᴍ ᴜsᴜᴀʀɪᴏ ᴍᴜᴛᴀᴅᴏ 🤷‍♂️*`);
usus__ = `ᴛᴏᴛᴀʟ: ${muted[muted.map(i => i.grupo).indexOf(from)].usus.length} - ᴍᴜᴛᴀᴅᴏs\n–\n`;
usus__ += muted[muted.map(i => i.grupo).indexOf(from)].usus.map((v, index) =>  `• ${index+1} - @${v.split('@')[0]}`).join('\n');
await mention(usus__);
break

case 'roletarussa':
if(!isGroup) return reply(mess.onlyGroup())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
TAMBOR = ["ɴᴀ ᴘᴇʀɴᴀ","ɴᴀ ᴄᴀʙᴇᴄᴀ","ɴᴏ ᴘᴇsᴄᴏᴄᴏ","ɴᴏ ᴘᴇɪᴛᴏ","ɴᴏ ᴏʟʜᴏ","ɴᴏ ᴇsᴛᴏᴍᴀɢᴏ.","ɴᴀ ʙᴏᴄᴀ","ɴᴀ ᴘᴇʀᴏᴋᴀʜ","ɴᴀ ᴛᴇsᴛᴀ","ɴᴏ ʙʀᴀᴄᴏ", "ɴᴀ ʙᴜᴢᴇᴛᴀ", "ɴᴀ ᴍᴀᴏ", "ɴᴏ ᴘᴇ"]
C2 = somembros[Math.floor(Math.random() * somembros.length)]
if(somembros.length == 0) return reply("*ᴛᴇᴍ ɴᴇɴʜᴜᴍ ᴍᴇᴍʙʀᴏ ᴄᴏᴍᴜᴍ ᴀǫᴜɪ 🤷‍♂️*")
if(C2 === sender || C2 === botNumber) return mentions(`*ᴇᴜ ᴇsᴄᴏʟʜɪ ᴏ @${C2.split('@')[0]} ᴍᴀs ᴄᴏɴsᴇɢᴜɪᴜ ᴇsᴄᴀᴘᴀʀ 🙄*`, [C2], true)
if(C2 === sender || C2 === numerodono[0]) return mentions(`*ᴇsᴄᴏʟʜɪ ᴏ @${C2.split('@')[0]} sᴇɴᴛᴇ ᴀ ᴘʀᴇssᴀᴏ ɴᴇɴᴇᴍ 🙅‍♂️*`, [C2], true)		
reply(`*ʙᴏʀᴀ ᴠᴇʀ ǫᴜᴇᴍ ɴᴀᴏ ᴛᴇᴍ sᴏʀᴛᴇ ᴀǫᴜɪ 🚀*`)
setTimeout(async() => { 
await mentions(`*ǫᴜᴇ ᴘᴇɴɪɴʜᴀ @${C2.split('@')[0]} ᴠᴏᴄᴇ ɴᴀᴏ ᴛᴇᴠᴇ sᴏʀᴛᴇ 🤷‍♂️ ᴛᴏᴍᴀ ᴜᴍ ᴛɪʀᴏ ${TAMBOR[Math.floor(Math.random() * (TAMBOR.length))]} 🙅‍♂️*`, [C2], true) 
}, 5000)	 
setTimeout(async() => {
await yuta.groupParticipantsUpdate(from, [C2], "remove")
}, 6000)
break


case 'limpar':
await reagir(from, "🗑️")
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
clear = `ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ
\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ
️`
clear2 = `ㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤㅤ\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n🗑️\n❲❗❳ *Lɪᴍᴘᴇᴢᴀ ᴅᴇ Cʜᴀᴛ Cᴏɴᴄʟᴜɪ́ᴅᴀ* ✅`
reply(`*ɢʀᴜᴘᴏ ғᴇᴄʜᴀᴅᴏ ᴘᴀʀᴀ ʟɪᴍᴘᴇᴢᴀ 🙅‍♂️*`)
yuta.groupSettingUpdate(from, 'announcement')
setTimeout(async() => {
yuta.sendMessage(from, {text: clear})
}, 1000)//msg 1
setTimeout(async() => {
yuta.sendMessage(from, {text: clear})
}, 4000)//msg 2
setTimeout(async() => {
yuta.sendMessage(from, {text: clear})
}, 7000)//msg 3
setTimeout(async() => {
yuta.sendMessage(from, {text: clear})
}, 10000)// msg 4
setTimeout(async() => {
yuta.sendMessage(from, {text: clear})
}, 13000)//msg 5
setTimeout(async() => {
yuta.sendMessage(from, {text: clear})
}, 16000)//msg 6
setTimeout(async() => {
yuta.sendMessage(from, {text: clear})
}, 19000)//msg 7
setTimeout(async() => {
yuta.sendMessage(from, {text: clear})
}, 22000)//msg 8
setTimeout(async() => {
yuta.sendMessage(from, {text: clear})
}, 25000)//msg 9
setTimeout(async() => {
yuta.sendMessage(from, {text: clear2})
}, 28000)//msg 10
setTimeout(async() => {
yuta.sendMessage(from, {text: `*ᴘʀᴏɴᴛᴏ sᴇɴʜᴏʀ, ᴀᴄᴀʙᴇɪ ᴅᴇ ʟɪᴍᴘᴀʀ ᴏ ᴄʜᴀᴛ 🙇‍♂️*`})
yuta.groupSettingUpdate(from, 'not_announcement')
}, 30000)
break


case 'd_':
await yuta.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.message.buttonsResponseMessage.contextInfo.stanzaId, participant: botNumber}})
break

case 'iddogrupo':
if(!SoDono) return reply(mess.onlyOwner())
reply(from)
break

case 'banfake': case 'banfakes':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
caixa = []
for(i of somembros) {
  if(!numerodono.includes(i) && !botNumber.includes(i)) {
    if(Number(i.slice(0, 2)) !== 55) caixa.push(i)
  }
}
if(caixa.length > 0) {
  for(a = 0; a < caixa.length; a++) {
    await sleep(1000)
    remover(from, caixa[a])
  }
} else reply("*ɴᴀᴏ ᴇxɪsᴛᴇ ɴᴇɴʜᴜᴍ ɴᴜᴍᴇʀᴏ ғᴀᴋᴇ ᴀǫᴜɪ ɴᴏ ɢʀᴜᴘᴏ 🤷‍♂️*")
break

case 'listafake': case 'listafakes':
if(!isGroup) return reply(enviar.msg.grupo)
if(!isGroupAdmins) return reply(enviar.msg.adm)
reagir(from, "🇺🇸")
txt = `🇺🇸 *ᴏs ɴᴜᴍᴇʀᴏs ғᴀᴋᴇs ǫᴜᴇ ᴛᴇᴍ ɴᴏ ɢʀᴜᴘᴏ:*\n`
let totalfake = 0
for(i = 0; i < groupMembers.length; i++) {
  if(groupMembers[i].id.split(groupMembers[i].id.slice(2))[0] === ("55")) {} else {
    txt += `⇒ ${isGroupAdmins ? '@' : 'wa.me/'}${groupMembers[i].id.split("@")[0]}\n`
    totalfake += 1
  }
}
txt += `\n🇺🇸 Total: ${totalfake}`
if(totalfake > 0) {
  var resp = isGroupAdmins ? mention : reply
  resp(txt)
} else {
  reply("*ɴᴀᴏ ᴇxɪsᴛᴇ ɴᴇɴʜᴜᴍ ɴᴜᴍᴇʀᴏ ғᴀᴋᴇ ᴀǫᴜɪ ɴᴏ ɢʀᴜᴘᴏ 🤷‍♂️*")
}
break

case 'brlist': case 'listabr':
if(!isGroup) return reply(enviar.msg.grupo)
reagir(from, "🇧🇷")
txt = `🇧🇷 *Lista de números brasileiros presentes neste grupo:*\n`
let totalbr = 0
for(i = 0; i < groupMembers.length; i++) {
  if(groupMembers[i].id.split(groupMembers[i].id.slice(2))[0] === ("55")) {
    if(groupMembers[i].id.includes(botNumber)) {} else {
      txt += `⇒ ${isGroupAdmins ? '@' : 'wa.me/'}${groupMembers[i].id.split("@")[0]}\n`
      totalbr += 1
    }
  }
}
txt += `\n🇧🇷 Total: ${totalbr}`
if(totalbr > 0) {
  var resp = isGroupAdmins ? mention : reply
  resp(txt)
} else {
  reply("Não há números brasileiros neste grupo...")
}
break

case 'listaddi': case 'ddilist':
if(!isGroup) return reply(mess.onlyGroup());
if(!isGroupAdmins) return reply(mess.onlyAdmins());
if(q.length < 1) return reply(`Fale o código de um país, por exemplo: *${prefix}listaddi 55*`)
if(isNaN(q)) return reply(`Fale o código de um país, por exemplo: *${prefix}listaddi 55*`)
teks = `• Número com código de país +${args[0]} registrados no grupo:\n–\n`
men = []
for(let mem of groupMembers) {
if(mem.id.startsWith(q)) {
teks += `⇒ @${mem.id.split('@')[0]}\n`
men.push(mem.id)
}
}
if(teks.indexOf('⇒') < 0) return reply(`Nenhum número com o DDI *+${args[0]}* foi encontrado.`)
await yuta.sendMessage(from, {text: teks, mentions: men}, {quoted: selo}).catch(async(error) => {
reply(mess.error())
})
break

case 'listaddd': case 'dddlist':
if(!isGroup) return reply(mess.onlyGroup());
if(!isGroupAdmins) return reply(mess.onlyAdmins());
if(q.length < 1) return reply(`Fale o código do estado, por exemplo: *${prefix}listaddd 82*`)
if(isNaN(q)) return reply(`Fale o código de um estado(ddd), por exemplo: *${prefix}listaddd 82*`)
teks = `• Lista de números brasileiros com o DDD *${q}* presentes neste grupo:\n–\n`
men = []
for (let mem of groupMembers) {
if(mem.id.startsWith(55+q)) {
teks += `⇒ @${mem.id.split('@')[0]}\n`
men.push(mem.id);
}
}
if(teks.indexOf('⇒') < 0) return reply('Nenhum *número brasileiro* com DDD fornecido foi encontrado no grupo.')
await yuta.sendMessage(from, {text: teks, mentions: men}, {quoted: selo}).catch(async(error) => {
reply(mess.error())
})
break

case 'limpar_mortos-cnt':
if(!SoDono) return reply(mess.onlyOwner())
if(!isGroup) return reply(mess.onlyOwner())
bla = [] 
var CNT_RS = countMessage[countMessage.map(i => i.groupId).indexOf(from)].numbers
for ( i = 0; i < CNT_RS.map( i => i.id).length; i++) { bla.push(CNT_RS.map( i => i.id)[i])};
for ( i of groupMembers) {bla.splice(bla.indexOf(i.id), 1)};
for ( i of bla) {CNT_RS.splice(CNT_RS.indexOf(i), 1)};
fs.writeFileSync("./INFO_YUTA/media/countmsg.json", JSON.stringify(countMessage))
reply("Usuários que já foi removido, ou saiu do grupo, foi tirado do contador de mensagens..")
break

case 'tirar_docnt':
if(!SoDono) return reply(mess.onlyOwner())
if(!isGroup) return reply(mess.onlyGroup())
var i2 = countMessage.map(i => i.groupId).indexOf(from) 
var i = countMessage[i2].numbers.map(i => i.id).indexOf(q.trim()+"@s.whatsapp.net")  
countMessage[i2].numbers.splice(i,1)
fs.writeFileSync("./INFO_YUTA/media/countmsg.json", JSON.stringify(countMessage))
reply("Usuário tirado do contador de mensagens com sucesso...")
break

case 'tcmd':
				if (!SoDono) {
					return;
				}
				fs.readFile('./yuta.js', 'utf8', (err, data) => {
					if (err) return reply('*Erro tentenovamente*');
					let regex = /case\s'(\w+)'/g;
					let match;
					let casesName = [];
					while ((match = regex.exec(data)) !== null) {
						casesName.push(match[1]);
					}
					let output = '' + casesName.join('\n ');
					let totalCount = casesName.length;
					reply(`*ᴀᴛᴜᴀʟᴍᴇɴᴛᴇ ${NomeDoBot} ᴛᴇᴍ ${totalCount} ᴄᴏᴍᴀɴᴅᴏs🙇‍♂️*`);
				});
				break

case 'nomegp':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
blat = args.join(" ")
await yuta.groupUpdateSubject(from, `${blat}`)
await yuta.sendMessage(from, {text: 'Sucesso, alterou o nome do grupo.'}, {quoted: selo})
break

case 'descgp':
case 'descriçãogp':  
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyAdmins())
blabla = args.join(" ")
await yuta.groupUpdateDescription(from, `${blabla}`)
await yuta.sendMessage(from, {text: 'Sucesso, alterou a descrição do grupo'}, {quoted: selo})
break

case 'mudarftgp':
case 'colocarftgp':  
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(!isQuotedImage) return reply(`Use: ${prefix + command} <Marque uma foto>`)
ftgp = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
rane = getRandom('.'+await getExtension(ftgp.mimetype))
buffimg = await getFileBuffer(ftgp, 'image')
fs.writeFileSync(rane, buffimg)
medipp = rane 
yuta.updateProfilePicture(from, {url: medipp})
reply(`Foto do grupo alterada com sucesso`) 
break

            case 'linkgp':
            case 'linkgroup':

         if(!isGroup) return reply(mess.onlyGroup())
           if(!isGroupAdmins) return reply(mess.onlyAdmins())
             if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
                let metadata = await yuta.groupMetadata(from)
                linkgc = await yuta.groupInviteCode(from)
                reply(`⸺͟͞𝐀𝐐𝐔𝐈 𝐄𝐒𝐓𝐀 𝐎 𝐋𝐈𝐍𝐊 𝐃𝐎 𝐆𝐑𝐔𝐏𝐎:↴\n\nhttps://chat.whatsapp.com/` + linkgc)
                break



case 'redefinir':
case 'revlinkgp':
case 'revlinkgroup':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
await yuta.groupRevokeInvite(from)
reply(`*ʟɪɴᴋ ᴅᴏ ɢʀᴜᴘᴏ ʀᴇᴅᴇғɪɴɪᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*`)
break

case 'pinterest': {
    try {
        async function pinterest(texto) { // by hiudy
            const url = 'https://br.pinterest.com/search/pins/?q=' + texto;
            const config = {
                headers: {
                    'User-Agent': 'Mozilla/5.0 (Linux; Android 10; SM-G975F Build/QP1A.190711.020) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.152 Mobile Safari/537.36',
                },
            };
            try {
                const { data } = await scget(url, config);
                const $ = cheerio.load(data);
                const fotos = [];
                $('.hCL').each((index, element) => {
                    const url = $(element).attr('src');
                    if (url.startsWith('https://i.pinimg.com/236x')) {
                        fotos.push(url);
                    }
                });
                return {
                    status: true,
                    images: fotos
                };
            } catch (error) {
                console.error(mess.error());
                return {
                    status: false,
                    error: mess.error()
                };
            }
        }
        if (!q) return reply(`*ᴇsᴛᴀ ғᴀʟᴛᴀɴᴅᴏ ɴᴀᴅᴀ ɴᴀᴏ?*\n*ᴇxᴇᴍᴘʟᴏ: ${prefix}ᴘɪɴᴛᴇʀᴇsᴛ ʏᴜᴛᴀ ᴏᴋᴋᴏᴛsᴜ*`)
        await reply(mess.teste());
        const data = await pinterest(q)
        if (!data.status) return reply(`Ocorreu um erro ao realizar a pesquisa`)
        const miapika = Math.floor(Math.random() * data.images.length)
        yuta.sendMessage(from, {
            image: {
                url: data.images[miapika]
            }
        }, {
            quoted: selo
        })
    } catch {
        reply(mess.error())
    }
    break;
}

case 'recrutar':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(!q) return reply("Cadê o número do usuário que você deseja convidar.")
try {
photoG = await yuta.profilePictureUrl(from, 'image') // Pegar a foto do grupo aonde foi solicitado o comando de recrutamento.
} catch {
photoG = thumbnail // Vai colocar a img que está na definição, caso esteja sem foto.
}
rcrt = q.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net`
linkgc = await yuta.groupInviteCode(from)
await yuta.sendMessage(rcrt, {text: "*Olá, tudo bem?* Você foi convidado(a) pelo(a) adminstrador(a) do grupo.\nPara entrar no grupo, clique acima!", contextInfo: {externalAdReply: {title: "Clique aqui para participar do grupo.", thumbnail: await getBuffer(photoG), mediaType: 1, sourceUrl: "https://chat.whatsapp.com/"+linkgc}}})
reply("Convite de recrutamento do usuário, foi enviado para o privado dele com sucesso...")
break

case 'listatm':
if(!SoDono) return reply(mess.onlyOwner())
rgp = JSON.parse(fs.readFileSync("./DADOS DO YUTA/func/tmgroup.json"))
if(rgp.length == 0) return reply(`Não contém nenhum registro de transmissão, utilize ${prefix}rgtm no grupo que deseja que ele receba as transmissões do bot..`)
bl = "";
for ( i = 0; i < rgp.length; i++) {
bl += `( ${i+1} ) - ID: ${rgp[i].id}\n• Nome do Usuário(a) ou Grupo: ${rgp[i].infonome}\n-\n`
}
reply(bl)
break

case 'rgtm':
if(!SoDono) return reply(mess.onlyOwner())
rgp = JSON.parse(fs.readFileSync("./DADOS DO YUTA/func/tmgroup.json"))
if(JSON.stringify(rgp).includes(from)) return reply("Este grupo/usuário já está registrado na lista de transmissão") 
rgp.push({id: from, infonome: `${isGroup ? groupName: pushname}`})
fs.writeFileSync("./DADOS DO YUTA/func/tmgroup.json", JSON.stringify(rgp))
reply("Registrado com sucesso, quando for realizada as transmissões, esse grupo/usuário estará na lista.")
break

case 'tirardatm':
if(!SoDono) return reply(mess.onlyOwner())
rgp = JSON.parse(fs.readFileSync("./DADOS DO YUTA/func/tmgroup.json"))
if(!JSON.stringify(rgp).includes(from)) return reply("Este grupo/usuário não está registrado para ser tirado da lista de transmissão") 
if(q.trim().length > 4) {
var ustm = rgp.map(i => i.id).indexOf(q.trim())
} else {
var ustm = rgp.map(i => i.id).indexOf(from)
}
rgp.splice(ustm, 1)
fs.writeFileSync("./DADOS DO YUTA/func/tmgroup.json", JSON.stringify(rgp))
reply("Grupo/Usuário tirado da lista de transmissão com sucesso")
break

case 'fzrtm':
if(!SoDono) return reply(mess.onlyOwner())
var rgp = JSON.parse(fs.readFileSync("./DADOS DO YUTA/func/tmgroup.json"))
if(rgp.lengh == 0) return reply("Não contém nenhum grupo registrado para realizar transmissão") 
await sleep(1000);
var DFC = "";
var rsm = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var pink = isQuotedImage ? rsm?.imageMessage: info.message?.imageMessage
var blue = isQuotedVideo ? rsm?.videoMessage: info.message?.videoMessage
var red = isQuotedMsg ? rsm?.textMessage: info.message?.textMessage
var purple = isQuotedDocument ? rsm?.documentMessage: info.message?.documentMessage
var yellow = isQuotedDocW ? rsm?.documentWithCaptionMessage?.message?.documentMessage: info.message?.documentWithCaptionMessage?.message?.documentMessage
var aud_d = isQuotedAudio ? rsm.audioMessage : ""
var figu_d = isQuotedSticker ? rsm.stickerMessage : ""
var red = isQuotedMsg && !aud_d &&!figu_d && !pink && !blue&& !purple && !yellow? " "+rsm.conversation: info.message?.conversation
var green = isQuotedMsg2 && !aud_d &&!figu_d && !red && !pink && !blue && !purple && !yellow ? " "+rsm.extendedTextMessage?.text : info?.message?.extendedTextMessage?.text
if(pink) {
var DFC = pink
pink.caption = q.length > 1 ? " "+q : pink.caption.replace(new RegExp(prefix+command, "gi"), ` `)
pink.image = {url: pink.url}
} else if(blue) {
var DFC = blue  
blue.caption = q.length > 1 ? " "+q : blue.caption.replace(new RegExp(prefix+command, "gi"), ` `)
blue.video = {url: blue.url}
} else if(red) {
black = {}
black.text = red.replace(new RegExp(prefix+command, "gi"), ` `)
var DFC = black
} else if(!aud_d && !figu_d && green) {
brown = {}
brown.text = green.replace(new RegExp(prefix+command, "gi"), ` `)
var DFC = brown
} else if(purple) {
var DFC = purple
purple.document = {url: purple.url} 
} else if(yellow) {
var DFC = yellow 
yellow.caption = q.length > 1 ? " "+q : yellow.caption.replace(new RegExp(prefix+command, "gi"), ` `)
yellow.document = {url: yellow.url}  
} else if(figu_d) {
var DFC = figu_d
figu_d.sticker = {url: figu_d.url}
} else if(aud_d) {
var DFC = aud_d
aud_d.audio = {url: aud_d.url}
}
for (i = 0; i < rgp.length; i++) {
await yuta.sendMessage(rgp[i].id, DFC)}
break

case 'fazertm': case 'bcgroup': case 'transmitir': case 'transmissão': {
                if(!SoDono) return reply(resposta.dono)
                if (!q) return reply(`Texto onde?\n\nExemplo : ${prefix + command} BOM DIA `)
                let getGroups = await yuta.groupFetchAllParticipating()
                let groups = Object.entries(getGroups).slice(0).map(entry => entry[1])
                let anu = groups.map(v => v.id)
                for (let i of anu) {
                    await sleep(150)
                    let txt = `「 TRANSMISSÃO DO BOT 」\n\n ${q}`
                    yuta.sendMessage(i, { text: txt })
                }
                reply(`Enviando com sucesso `)
            }
                break

case 'grupo': 
try {
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins());
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());
if(args.length < 1) return reply(`*ᴇsᴛᴀ ғᴀʟᴛᴀɴᴅᴏ ᴀʟɢᴏ ᴀɪ ʀᴀᴘᴀᴢ 🤷‍♂️*\n\n> ᴇxᴇᴍᴘʟᴏ: ${prefix}ɢʀᴜᴘᴏ ᴀ『 ᴘᴀʀᴀ ᴀʙʀɪʀ 』\n> ${prefix}ɢʀᴜᴘᴏ ғ『 ᴘᴀʀᴀ ғᴇᴄʜᴀʀ 』`);
if (args[0] === 'a') {
reply(`*ɢʀᴜᴘᴏ ᴀʙᴇʀᴛᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ sᴇɴʜᴏʀ(ᴀ) 🙇‍♂️*`)
await yuta.groupSettingUpdate(from, 'not_announcement')
} else if (args[0] === 'f') {
reply(`*ɢʀᴜᴘᴏ ғᴇᴄʜᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ sᴇɴʜᴏʀ(ᴀ) 🙇‍♂️*`)
await yuta.groupSettingUpdate(from, 'announcement')
} else {
reply(`*ᴇsᴛᴀ ғᴀʟᴛᴀɴᴅᴏ ᴀʟɢᴏ ᴀɪ ʀᴀᴘᴀᴢ 🤷‍♂️*\n\n> ᴇxᴇᴍᴘʟᴏ: ${prefix}ɢʀᴜᴘᴏ ᴀ『 ᴘᴀʀᴀ ᴀʙʀɪʀ 』\n> ${prefix}ɢʀᴜᴘᴏ ғ『 ᴘᴀʀᴀ ғᴇᴄʜᴀʀ 』`);
}
} catch {
}
break 



case 'totag':
case 'cita':
case 'hidetag':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
var DFC = "";
var rsm = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var pink = isQuotedImage ? rsm?.imageMessage: info.message?.imageMessage
var blue = isQuotedVideo ? rsm?.videoMessage: info.message?.videoMessage
var purple = isQuotedDocument ? rsm?.documentMessage: info.message?.documentMessage
var yellow = isQuotedDocW ? rsm?.documentWithCaptionMessage?.message?.documentMessage: info.message?.documentWithCaptionMessage?.message?.documentMessage
var aud_d = isQuotedAudio ? rsm.audioMessage : ""
var figu_d = isQuotedSticker ? rsm.stickerMessage : ""
var red = isQuotedMsg && !aud_d && !figu_d && !pink && !blue&& !purple && !yellow? rsm.conversation: info.message?.conversation
var green = rsm?.extendedTextMessage?.text || info?.message?.extendedTextMessage?.text
var MRC_TD = groupMembers.map(i => i.id)
if(pink && !aud_d && !purple) {
var DFC = pink
pink.caption = q.length > 1 ? ""+q :pink.caption.replace(new RegExp(prefix+command, "gi"), ` `)
pink.image = {url: pink.url}
pink.mentions = MRC_TD
} else if(blue && !aud_d && !purple) {
var DFC = blue  
blue.caption = q.length > 1 ? " "+q.trim() :blue.caption.replace(new RegExp(prefix+command, "gi"), ` `).trim()
blue.video = {url: blue.url}
blue.mentions = MRC_TD
} else if(red && !aud_d && !purple) {
black = {}
black.text = red.replace(new RegExp(prefix+command, "gi"), ` `).trim()
black.mentions = MRC_TD
var DFC = black
} else if(!aud_d && !figu_d && green && !purple && !purple) {
brown = {}
brown.text = green.replace(new RegExp(prefix+command, "gi"), ` `).trim()
brown.mentions = MRC_TD
var DFC = brown
} else if(purple) {
var DFC = purple
purple.document = {url: purple.url}
purple.mentions = MRC_TD
} else if(yellow && !aud_d) {
var DFC = yellow 
yellow.caption = q.length > 1 ? " "+q.trim() :yellow.caption.replace(new RegExp(prefix+command, "gi"), ` `).trim()
yellow.document = {url: yellow.url}
yellow.mentions = MRC_TD
} else if(figu_d && !aud_d) {
var DFC = figu_d
figu_d.sticker = {url: figu_d.url}
figu_d.mentions = MRC_TD
} else if(aud_d) {
var DFC = aud_d
aud_d.audio = {url: aud_d.url}
aud_d.mentions = MRC_TD
aud_d.ptt = true
}
await yuta.sendMessage(from, DFC).catch((error) => {})
break



case 'marcar': case 'marcar2':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
async function marcac() {
bla = []
blad = `『⚠️』⸺͟͞𝐌𝐀𝐑𝐂𝐀𝐍𝐃𝐎 𝐓𝐎𝐃𝐎𝐒 𝐎𝐒 𝐌𝐄𝐌𝐁𝐑𝐎𝐒 ‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎${!q ? "" : `\n*Mensagem:* ${q}`}\n\n`
for( let i of somembros ) {
blad += `⸺͟͞➪ @${i.split("@")[0]}\n`
bla.push(i)
}
blam = JSON.stringify(somembros)
if(blam.length == 2) return reply(`❌️ Olá *${pushname}* - Não contém nenhum membro comum no grupo, é sim apenas administradores. `)
await mentions(blad, bla, true)  
}
marcac().catch((error) => {
console.log(error)
})
break


case 'marcarwa':
try {
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())  
if(q.includes(`${prefix}`)) return reply("Não pode utilizar comandos nesse comando")
members_id = []
teks = (args.length > 1) ? body.slice(10).trim() : ''
teks += ''
for (let mem of groupMembers) {
teks += `╠➥ https://wa.me/${mem.id.split('@')[0]}\n`
members_id.push(mem.id)
}
await yuta.sendMessage(from, {text: teks}, {quoted: selo})
} catch {
reply('Erro ao mencionar.')
}
break

case 'reviverqr':
if(!SoDono) return reply(mess.onlyOwner())
exec(`cd ${qrcode} && rm -rf pre-key* sender* session*`)
setTimeout(async () => {
    await reply("*ᴏᴋᴀʏ ᴍᴇsᴛʀᴇ, ɪʀᴇɪ ʀᴇɪɴɪᴄɪᴀʀ, ᴀɢᴜᴀʀᴅᴇ ᴜᴍ ᴍᴏᴍᴇɴᴛᴏ... 🙇‍♂️*")
 setTimeout(async () => {
    process.exit()
 }, 1200)
}, 1000)
break

case 'sair_all':
  if (!SoDono && !info.key.fromMe) return reply("Este comando só pode ser executado pelo dono do bot.");

  try {
    // Obtém todos os grupos que o bot participa
    const grupos = await yuta.groupFetchAllParticipating();
    
    // Itera sobre cada grupo e faz o bot sair
    for (let idGrupo in grupos) {
      await yuta.groupLeave(grupos[idGrupo].id);
    }
    
    reply("O bot saiu de todos os grupos com sucesso.");
  } catch (erro) {
    reply("Erro ao tentar sair dos grupos: " + String(erro));
  }
  break;


case 'sair':
case 'sairgp':
if(isGroup && !SoDono && !info.key.fromMe) return reply("Este comando só o bot ou o dono pode executar..")
try {
await yuta.groupLeave(from)
} catch(erro) {
reply(String(erro))
}
break

case 'cronometro'://vncs & nunu
if(!SoDono) return reply(mess.onlyOwner());
    async function CronZ(txt, timeArg) {
        let totalTime = parseInt(timeArg, 10) * 60;
        if (isNaN(totalTime) || totalTime > 60) totalTime = 60;
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }//vncs & nunu
        const startMsg = `⏳ *Cronômetro Iniciado* ⏳\n\n${txt.length > 0 ? `*Mensagem:* ${txt}\n\n` : ''}*Tempo Restante: ${Math.floor(totalTime / 60)}:00*`;
        let { key } = await yuta.sendMessage(from, { text: startMsg }, { quoted: selo });
//vncs & nunu
        const progressBarLength = 20;
//vncs & nunu
        for (let i = totalTime - 1; i >= 0; i--) {
            const minutes = Math.floor(i / 60);
            const seconds = i % 60;
            const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            const progress = Math.floor(((totalTime - i) / totalTime) * progressBarLength);
            const progressBar = `[${'█'.repeat(progress)}${'░'.repeat(progressBarLength - progress)}]`;

            await sleep(1000);

            const updateMsg = `⏳ *Cronômetro* ⏳\n\n${txt.length > 0 ? `*Mensagem:* ${txt}\n\n` : ''}> *Tempo Restante:* ${timeString}\n${progressBar}`;
            await yuta.sendMessage(from, { text: updateMsg, edit: key }, { quoted: selo });
        }

        const endMsg = `✅ *Tempo Esgotado!* ✅\n\n${txt.length > 0 ? `*Mensagem:* ${txt}\n\n` : ''}*O tempo especificado terminou.*`;
        await yuta.sendMessage(from, { text: endMsg }, { quoted: selo });
    }
    const txt = args.slice(1).join(' ');
    const timeArg = args[0];
    CronZ(txt, timeArg);
    break;

case 'seradm':
if(!SoDono) return reply(mess.onlyOwner());
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());
await mentions(`*ᴘʀᴏɴᴛᴏ @${sender.split("@")[0]}, ᴀɢᴏʀᴀ ᴠᴏᴄᴇ ᴇ ᴜᴍ ᴀᴅᴍɪɴɪsᴛʀᴀᴅᴏʀ 🙇‍♂️*`, [sender], true)
await yuta.groupParticipantsUpdate(from, [sender], "promote");
break

case 'sermembro':
if(!SoDono) return reply(mess.onlyOwner());
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());
await mentions(`*ᴘʀᴏɴᴛᴏ @${sender.split("@")[0]}, ᴀɢᴏʀᴀ ᴠᴏᴄᴇ ᴇ ᴍᴇᴍʙʀᴏ ᴄᴏᴍᴜᴍ 🙇‍♂️*`, [sender], true)
await yuta.groupParticipantsUpdate(from, [sender], "demote")
break

case 'advertir':
case 'adverter': 
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(menc_os2 == botNumber) return reply("Não pode advertir o próprio bot.");
if(menc_os2 == nmrdn) return reply("Não pode advertir o próprio dono do bot.");
if(groupAdmins.includes(menc_os2)) return reply("Não é possível advertir adminstrador do grupo.");
if(!JSON.stringify(groupMembers).includes(menc_os2)) return reply("Não tem como advertir um usuário que não se encontra mais no grupo.")
ADVT.push(menc_os2); setGp(dataGp)  
setTimeout(async() => {
var dfqn = ADVT.filter(x => x == menc_os2).length
var dfntxt = mess.warningAdvertencia(menc_os2, dfqn)
if(!dfntxt.includes("3/3")) {
if(!JSON.stringify(ADVT).includes(sender)) {
await sleep(1500); 
await mentions(dfntxt, [menc_os2])
} else if(dfqn == 2) {
await sleep(1500); 
await mentions(dfntxt, [menc_os2])
}} else {
await yuta.sendMessage(from, {text: mess.finishAdvertencia(menc_os2), mentions: [menc_os2]}, {quoted: selo})
await sleep(1500)
await yuta.groupParticipantsUpdate(from, [menc_os2], "remove")
var i = ADVT.indexOf(menc_os2); 
ADVT.splice(i, 3); setGp(dataGp)}}, 3000)
break

case 'rmadv':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!marc_tds) return reply("Você esqueceu de mencionar o alvo após o comando.")
adv = dataGp[0].advertir.map(i => i).indexOf(marc_tds)
if(adv < 0) return reply("Este usuário não contém nenhuma advertência no grupo.")
dataGp[0].advertir.splice(adv, 1)
setGp(dataGp)
reply("A advertência do usuário neste grupo foi retirada com sucesso!")
break

case 'sair_chat':
case 'sairdogp':
    if (!SoDono) {
        return reply(mess.onlyOwner()); // Verifica se é o dono e retorna uma mensagem caso não seja
    }

    if (!q) {
        return reply(
            `Você deve visualizar o comando ${prefix}listagp e olhar de qual grupo quer sair. Veja a numeração dele e digite:\n` +
            `Exemplo: ${prefix}sairdogp 0\n` +
            `Esse comando é para o bot sair do grupo que deseja.`
        );
    }

    try {
        // Obtém todos os grupos em que o bot participa
        var getGroups = await yuta.groupFetchAllParticipating();
        var groups = Object.entries(getGroups).map(entry => entry[1]); // Mapeia os grupos em um array

        // Verifica se o índice informado é válido
        if (isNaN(q) || q < 0 || q >= groups.length) {
            return reply(`Número inválido. Use o comando ${prefix}listagp para conferir as numerações dos grupos.`);
        }

        var selectedGroup = groups[q];

        // Envia mensagem de saída para o grupo selecionado
        await yuta.sendMessage(selectedGroup.id, { text: "Irei sair do grupo, por ordem do meu dono, adeus..." });
        
        // Aguarda 5 segundos antes de sair do grupo
        setTimeout(async () => {
            try {
                await yuta.groupLeave(selectedGroup.id);
                reply("Pronto meu dono, saí do grupo que você queria. Em caso de dúvidas, use o comando listagp para verificar.");
            } catch (leaveError) {
                reply(`Erro ao tentar sair do grupo: ${String(leaveError)}`);
            }
        }, 5000);
    } catch (erro) {
        reply(`Erro ao processar a solicitação: ${String(erro)}`); // Responde com o erro caso ocorra
    }
    break;

case 'listagp':
     if (!SoDono && !isnit && !info.key.fromMe) return reply(mess.onlyOwner());
await reagir(from, "🍂")
    try {
        const getGroups = await yuta.groupFetchAllParticipating();
        const groups = Object.values(getGroups);
        groups.sort((a, b) => b.participants.length - a.participants.length);
        let teks1 = `*ᴇsᴛᴏᴜ ᴀᴛᴜᴀʟᴍᴇɴᴛᴇ ᴏᴘᴇʀᴀɴᴅᴏ ᴇᴍ ${groups.length} ɢʀᴜᴘᴏs ᴏᴜ ᴄᴏᴍᴜɴɪᴅᴀᴅᴇs. 🙇‍♂️*\n`;
        for (let i = 0; i < groups.length; i++) {
            const group = groups[i];
            try {
                const metadt = await yuta.groupMetadata(group.id);
                const linkdogp = await yuta.groupInviteCode(group.id);
                teks1 += `『 ${i + 1} 』ɴᴏᴍᴇ ᴅᴏ ɢʀᴜᴘᴏ: ${group.subject}\n`;
                teks1 += `ɪᴅ ᴅᴏ ɢʀᴜᴘᴏ: ${group.id}\n`;
                teks1 += `ʟɪɴᴋ: https://chat.whatsapp.com/${linkdogp}\n`;
                teks1 += `ᴄʀɪᴀᴅᴏʀ: ${metadt.subjectOwner}\n`;
                teks1 += `ᴄʀɪᴀᴅᴏ ᴇᴍ: ${moment(group.creation * 1000)
                    .tz('America/Sao_Paulo')
                    .format('DD/MM/YYYY HH:mm:ss')}\n`;
                teks1 += `ᴍᴇᴍʙʀᴏs: ${group.participants.length}\n—\n`;
            } catch (err) {
                teks1 += `『 ${i + 1} 』ɴᴏᴍᴇ ᴅᴏ ɢʀᴜᴘᴏ: ${group.subject}\n`;
                teks1 += `ɪᴅ ᴅᴏ ɢʀᴜᴘᴏ: ${group.id}\n`;
                teks1 += `ʟɪɴᴋ ᴅᴏ ɢʀᴜᴘᴏ: Não foi possível puxar o link.\n`;
                teks1 += `ɴᴀᴏ ғᴏɪ ᴘᴏssɪᴠᴇʟ ᴘᴇɢᴀʀ ᴀs ɪɴғᴏʀᴍᴀᴄᴏᴇs\n\n`;
            }
            await new Promise((resolve) => setTimeout(resolve, 100));
        }
        reply(teks1);
    } catch (error) {
        console.error(error);
        reply(`Ocorreu um erro ao listar os grupos: ${error.message}`);
    }
    break;

  case 'nome-bot':
if(!SoDono  && !isnit && !info.key.fromMe) return reply(mess.onlyOwner())  
setting.NomeDoBot = q.trim()
fs.writeFileSync('./INFO_YUTA/DADOS/INFO_YUTA.json', JSON.stringify(setting, null, 2))
reply(`*ᴘʀᴏɴᴛᴏ ᴍᴇsᴛʀᴇ, ᴀɢᴏʀᴀ ᴍᴇᴜ ɴᴏᴍᴇ ᴇ ${setting.NomeDoBot} 🙇‍♂️*`)
break

case 'nick-dono':
if(!SoDono  && !isnit && !info.key.fromMe) return reply(mess.onlyOwner()) 
setting.ownerName = q.trim()
fs.writeFileSync('./INFO_YUTA/DADOS/INFO_YUTA.json', JSON.stringify(setting, null, 2))
reply(`*ᴄᴇʀᴛᴏ sᴇɴʜᴏʀ, ᴀɢᴏʀᴀ ᴏ sᴇᴜ ɴɪᴄᴋ ᴇ ${setting.ownerName} 🙅‍♂️*`)
break

case 'lider':
case 'numero-dono':
if(!SoDono && !isnit && !info.key.fromMe) return reply(mess.onlyOwner())  
if(q.match(/[a-z]/i)) return reply("É apenas números..")
setting.ownerNumber = q.trim().replace(new RegExp("[()+-/ +/]", "gi"), "");
fs.writeFileSync('./INFO_YUTA/DADOS/INFO_YUTA.json', JSON.stringify(setting, null, 2))
reply(`*ᴄᴇʀᴛᴏ ᴍᴇsᴛʀᴇ, ᴀɢᴏʀᴀ sᴇᴜ ɴᴜᴍᴇʀᴏ ᴇ ᴇssᴇ ${q} 🙆‍♂️*`)
break

case 'channel': case 'setchannel':
    if (args.length < 1) {
        return reply(`*ᴇsᴛᴀ ғᴀʟᴛᴀɴᴅᴏ ᴏ ɪᴅ ᴅᴏ ᴄᴀɴᴀʟ.. 🤷‍♂️*\n\n- *ᴇxᴇᴍᴘʟᴏ: ${prefix + command} 120363307065691411@newsletter*`);
    }
    if (!SoDono && !isnit && !info.key.fromMe) return reply(mess.onlyOwner());

    setting.channelnk = q.trim(); // Define o ID do canal
    fs.writeFileSync('./INFO_YUTA/DADOS/INFO_YUTA.json', JSON.stringify(setting, null, 2));

    reply(`*ᴏᴋᴀʏ ᴍᴇsᴛʀᴇ, ᴀɢᴏʀᴀ ᴍᴇᴜ ᴄʜᴀɴɴᴇʟ ᴇ『 ${setting.channelnk} 』🙇‍♂️*`);
    break;
    

case 'prefixo': case 'setprefix':
if(args.length < 1) return
if(!SoDono  && !isnit && !info.key.fromMe) return reply(mess.onlyOwner())
setting.prefix = q.trim()
fs.writeFileSync('./INFO_YUTA/DADOS/INFO_YUTA.json', JSON.stringify(setting, null, 2))
reply(`*ᴏᴋᴀʏ ᴍᴇsᴛʀᴇ, ᴀɢᴏʀᴀ ᴍᴇᴜ ᴘʀᴇғɪxᴏ ᴇ『 ${setting.prefix} 』🙇‍♂️*`)
break

case 'fotomenu':
case 'fundomenu':
if(!SoDono) return reply(mess.onlyOwner())
if(!isQuotedImage) return reply("Marque uma imagem")
if((isMedia && !info.message.videoMessage || isQuotedImage) && !q.length <= 1) { 
reply(`*ᴄᴀʟᴍᴀ ᴍᴇsᴛʀᴇ, ᴊᴀ ᴇsᴛᴏᴜ ᴍᴜᴅᴀɴᴅᴏ ᴍɪɴʜᴀ ʟᴏɢᴏ.. 🙆‍♂️*`)
boij = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
owgi = await getFileBuffer(boij, 'image')
res = await upload(owgi)
ftmenu.logo.splice([])
fs.writeFileSync('./INFO_YUTA/LOGOS/logos.json', JSON.stringify(ftmenu, null, 2))
setTimeout(async() => {
ftmenu.logo.push(res)
fs.writeFileSync('./INFO_YUTA/LOGOS/logos.json', JSON.stringify(ftmenu, null, 2))
reply(`*ᴏᴋᴀʏ ᴍᴇsᴛʀᴇ, ᴀɢᴏʀᴀ ᴍɪɴʜᴀ ʟᴏɢᴏ ᴇ ${ftmenu.logo}*`)
}, 1200)
} else {
reply(`*ᴇɪ ᴍᴇsᴛʀᴇ, ᴍᴀɴᴅᴇ ᴜᴍᴀ ɪᴍᴀɢᴇᴍ ᴘʀᴀ ᴍɪᴍ ᴘᴏᴅᴇʀ ᴍᴜᴅᴀʀ ᴍɪɴʜᴀ ʟᴏɢᴏ.. 🙇‍♂️*`)
}
break

case 'dono1':
if(args.length < 1) return
if(!SoDono  && !isnit && !issupre && !ischyt) return reply(mess.onlyOwner())
nescessario.numero_dono1 = q.trim()
setNes(nescessario)
reply(`*ᴘʀᴏɴᴛᴏ ᴍᴇsᴛʀᴇ, ᴀɢᴏʀᴀ ᴏ ${q}, ғᴀᴢ ᴘᴀʀᴛᴇ ᴅᴏs ᴅᴏɴᴏs.. 🙅‍♂️*`)
break

case 'dono2':
if(args.length < 1) return
if(!SoDono  && !isnit && !issupre && !ischyt) return reply(mess.onlyOwner())
nescessario.numero_dono2 = q.trim()
setNes(nescessario)
reply(`*ᴘʀᴏɴᴛᴏ ᴍᴇsᴛʀᴇ, ᴀɢᴏʀᴀ ᴏ ${q}, ғᴀᴢ ᴘᴀʀᴛᴇ ᴅᴏs ᴅᴏɴᴏs.. 🙅‍♂️*`)
break

case 'dono3':
if(args.length < 1) return
if(!SoDono  && !isnit && !issupre && !ischyt) return reply(mess.onlyOwner())
nescessario.numero_dono3 = q.trim()
setNes(nescessario)
reply(`*ᴘʀᴏɴᴛᴏ ᴍᴇsᴛʀᴇ, ᴀɢᴏʀᴀ ᴏ ${q}, ғᴀᴢ ᴘᴀʀᴛᴇ ᴅᴏs ᴅᴏɴᴏs.. 🙅‍♂️*`)
break

case 'dono4':
if(args.length < 1) return
if(!SoDono  && !isnit && !issupre && !ischyt) return reply(mess.onlyOwner())
nescessario.numero_dono4 = q.trim()
setNes(nescessario)
reply(`*ᴘʀᴏɴᴛᴏ ᴍᴇsᴛʀᴇ, ᴀɢᴏʀᴀ ᴏ ${q}, ғᴀᴢ ᴘᴀʀᴛᴇ ᴅᴏs ᴅᴏɴᴏs.. 🙅‍♂️*`)
break

case 'dono5':
if(args.length < 1) return
if(!SoDono  && !isnit && !issupre && !ischyt) return reply(mess.onlyOwner())
nescessario.numero_dono5 = q.trim()
setNes(nescessario)
reply(`*ᴘʀᴏɴᴛᴏ ᴍᴇsᴛʀᴇ, ᴀɢᴏʀᴀ ᴏ ${q}, ғᴀᴢ ᴘᴀʀᴛᴇ ᴅᴏs ᴅᴏɴᴏs.. 🙅‍♂️*`)
break

case 'dono6':
if(args.length < 1) return
if(!SoDono  && !isnit && !issupre && !ischyt) return reply(mess.onlyOwner())
nescessario.numero_dono6 = q.trim()
setNes(nescessario)
reply(`*ᴘʀᴏɴᴛᴏ ᴍᴇsᴛʀᴇ, ᴀɢᴏʀᴀ ᴏ ${q}, ғᴀᴢ ᴘᴀʀᴛᴇ ᴅᴏs ᴅᴏɴᴏs.. 🙅‍♂️*`)
break


case 'nomegp':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
await yuta.groupUpdateSubject(from, `${body.slice(9)}`)
await yuta.sendMessage(from, {text: 'Sucesso, alterou o nome do grupo.'}, {quoted: selo})
break


case 'ativo': case 'on': case 'voltei':
if(!isGroupAdmins && !SoDono) return reply("Só adm ou dono pode utilizar este comando.")
if(DonoOficial) {
if(fs.existsSync("./DADOS DO YUTA/func/afk/afk-@" + numerodono_ofc + ".json")) {  
DLT_FL("./DADOS DO YUTA/func/afk/afk-@" + numerodono_ofc + ".json");
reply("*ᴏᴋᴀʏ, ᴀᴄᴀʙᴇɪ ᴅᴇ ᴛɪʀᴀʀ sᴜᴀ ᴍᴇɴsᴀɢᴇᴍ ᴅᴇ ᴀᴜsᴇɴᴄɪᴀ ᴅᴇ ᴍᴇᴜs ʀᴇɢɪsᴛʀᴏs, ʙᴇᴍ ᴠɪɴᴅᴏ(ᴀ) ᴅᴇ ᴠᴏʟᴛᴀ 🙇‍♂️*")
} else {
reply("*ᴠᴏᴄᴇ ɴᴀᴏ ʀᴇɢɪsᴛʀᴏᴜ ᴀ sᴜᴀ ᴀᴜsᴇɴᴄɪᴀ.. 🤷‍♂️*")
}
} else if(isGroupAdmins) {
if(!JSON.stringify(dataGp[0].ausentes).includes(sender)) return reply("*ᴠᴏᴄᴇ ɴᴀᴏ ʀᴇɢɪsᴛʀᴏᴜ ᴀ sᴜᴀ ᴀᴜsᴇɴᴄɪᴀ.. 🤷‍♂️*")
dataGp[0].ausentes.splice(dataGp[0].ausentes.map(x => x.id).indexOf(sender), 1)
setGp(dataGp)
reply("*ᴏᴋᴀʏ, ᴀᴄᴀʙᴇɪ ᴅᴇ ᴛɪʀᴀʀ sᴜᴀ ᴍᴇɴsᴀɢᴇᴍ ᴅᴇ ᴀᴜsᴇɴᴄɪᴀ ᴅᴇ ᴍᴇᴜs ʀᴇɢɪsᴛʀᴏs, ʙᴇᴍ ᴠɪɴᴅᴏ(ᴀ) ᴅᴇ ᴠᴏʟᴛᴀ 🙇‍♂️*")
}
break

case 'ausente': case 'off': case 'afk':
if(!isGroupAdmins && !SoDono) return reply("*sᴏᴍᴇɴᴛᴇ ᴍᴇᴜ ᴅᴏɴᴏ ᴏᴜ ᴀᴅᴍs ᴘᴏᴅᴇᴍ ᴜsᴀʀ ᴇssᴇ ᴄᴍᴅ 🤷‍♂️*")
if(DonoOficial) {
msgtmp = moment.tz('America/Sao_Paulo').format('HH:mm:ss');
fs.writeFileSync(`./DADOS DO YUTA/func/afk/afk-@${setting.ownerNumber.replace(new RegExp("[()+-/ +/]", "gi"), "")}.json`, JSON.stringify({Ausente_Desde: msgtmp, Motivo_Da_Ausência: q}, null, 2));
reply(`*ᴍᴇɴsᴀɢᴇᴍ ᴅᴇ ᴀᴜsᴇɴᴄɪᴀ ᴄʀɪᴀᴅᴀ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙅‍♂️*\n\n> ᴄᴀsᴏ ǫᴜᴇɪʀᴀ ᴛɪʀᴀʀ ᴜsᴇ ᴏ ᴄᴏᴍᴀɴᴅᴏ『 ${prefix}on 』`)
} else if(isGroupAdmins) {
if(!q.trim()) return reply(`*ᴇxᴇᴍᴘʟᴏ: ${prefix}ᴀᴜsᴇɴᴛᴇ ᴇsᴛᴏᴜ ᴊᴏɢᴀɴᴅᴏ ᴍɪɴᴇᴄʀᴀғᴛ 🙇‍♂️*`)
if(!JSON.stringify(dataGp[0].ausentes).includes(sender)) {
dataGp[0].ausentes.push({id: sender, msg: q.trim()})
setGp(dataGp)
reply(`*ᴍᴇɴsᴀɢᴇᴍ ᴅᴇ ᴀᴜsᴇɴᴄɪᴀ ᴄʀɪᴀᴅᴀ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙅‍♂️*\n\n> ᴄᴀsᴏ ǫᴜᴇɪʀᴀ ᴛɪʀᴀʀ ᴜsᴇ ᴏ ᴄᴏᴍᴀɴᴅᴏ『 ${prefix}on 』`)
} else {
dataGp[0].ausentes[dataGp[0].ausentes.map(i => i.id).indexOf(sender)].msg = q.trim()
setGp(dataGp)
reply(`*ᴍᴇɴsᴀɢᴇᴍ ᴅᴇ ᴀᴜsᴇɴᴄɪᴀ ᴄʀɪᴀᴅᴀ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙅‍♂️*\n\n> ᴄᴀsᴏ ǫᴜᴇɪʀᴀ ᴛɪʀᴀʀ ᴜsᴇ ᴏ ᴄᴏᴍᴀɴᴅᴏ『 ${prefix}on 』`)
}
} else {
return reply("*ᴇsᴛᴇ ᴄᴏᴍᴀɴᴅᴏ ᴇ ᴀᴘᴇɴᴀs ᴘᴀʀᴀ ᴏ ᴅᴏɴᴏ ᴇ ᴀᴅᴍs.. 🤷‍♂️*")
}
break

case 'addvip': 
if(!SoDono) return reply(mess.onlyOwner())
barra = q.replace(" /", "/").replace("/ ", "/").replace(" / ", "/")
var [nmr, tempo50] = barra.split('/')
if(!nmr || !tempo50) return await mention(`Você esqueceu de colocar o número do indivíduo e a quantidade de dias que o(a) usuário(a) como vip.\n• Segue o exemplo de uso correto do comando: *${prefix+command} @${nmrdn.split('@')[0]}/30*\n–––\n• Para colocar o usuário sem duração de expiração do vip, você usa o *0* como quantidade de dias.`)
usur = nmr.includes('@') ? nmr.split('@')[1] + "@s.whatsapp.net" : nmr + "@s.whatsapp.net"
mega = Number(tempo50) > 0 ? false : true
dvip = moment.tz('America/Sao_Paulo').format('DD')
bla = JSON.stringify(vip).includes(usur)
if(bla) {
AB = vip.map(i => i.id).indexOf(usur)
if(vip[AB].infinito == true) return reply(`Não é possível adicionar + dias ao usuário, por motivos que ele contém o vip infinito.`)
vip[AB].dias += Number(tempo50)
fs.writeFileSync('./DADOS DO YUTA/usuarios/vip.json', JSON.stringify(vip))
await yuta.sendMessage(from, {text: `${tempo50} dia${Number(tempo50) > 1 ? `s` : ``} fo${Number(tempo50) > 1 ? `ram` : `i`} adicionado${Number(tempo50) > 1 ? `s` : ``} ao usuário @${usur.split("@")[0]}`, mentions: [usur]}, {quoted: selo})
} else {
vip.push({id: usur, dias: Number(tempo50), save: Number(dvip), infinito: mega})
fs.writeFileSync('./DADOS DO YUTA/usuarios/vip.json', JSON.stringify(vip))
await yuta.sendMessage(from, {text: `${Number(tempo50) > 0 ? `@${usur.split("@")[0]} foi adicionado à lista vip com sucesso!` : `@${usur.split("@")[0]} foi agraciado com o benefício do vip infinito!`}`, mentions: [usur]}, {quoted: selo})
}
break

case 'delvip':
if(!SoDono) return reply(mess.onlyOwner())
if(!marc_tds) return reply(`Marque o usuário que deseja remover da lista vip.️`)
if(!JSON.stringify(vip).includes(marc_tds)) return reply("Este número não está incluso atualmente na lista de usuários vip(s)..")
AB = vip.map(i => i.id).indexOf(marc_tds)
vip.splice(AB, 1)
fs.writeFileSync('./DADOS DO YUTA/usuarios/vip.json', JSON.stringify(vip))
await yuta.sendMessage(from, {text: `@${marc_tds.split("@")[0]} foi removido da lista vip com sucesso!`, mentions: [marc_tds]}, {quoted: selo})
break


case 'deletar': case 'delete': case 'del':  case 'd':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins());
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());
if(!menc_prt) return reply("Marque a mensagem do usuário que deseja apagar, do bot ou de alguém.")
await yuta.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.message.extendedTextMessage.contextInfo.stanzaId, participant: menc_prt}})
break


case 'limitarcmd': case 'limitarcomando': case 'limitecmd':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
dataGp[0].Limitar_CMD = !dataGp[0].Limitar_CMD
setGp(dataGp);
reply(dataGp[0]?.Limitar_CMD ? "Limitador de comandos ativado com sucesso no grupo: "+groupName : "Limitador de comandos desativado no grupo: "+groupName)
break

case 'tempocmd':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!q.trim()) return reply(`Exemplo: ${prefix+command} 120\n60 = 1 minuto\nExemplo que coloquei, com o : ${prefix}limitarcmd ativo, só podera usar comandos a cada 2 minutos\nBoa sorte.`)
dataGp[0].Limit_tempo = q.trim()
setGp(dataGp)
reply(`Tempo limite definido para: ${TimeCount(q.trim())} a cada comando.`)
break


case 'blockuser':
if(!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(mess.onlyOwner())
if(!q.length > 6) return reply("Marque o @ do usuário que deseja bloquear de ele utilizar os comandos, ou o número da fórma que copiar...")
var blcp = q.replace(new RegExp("[()+-/ @+/]", "gi"), "")+"@s.whatsapp.net"
var numblc = ban.indexOf(blcp)
if(numblc >= 0) return reply('*Esse número já esta incluso na lista de bloqueio.*')
ban.push(blcp)
fs.writeFileSync('./DADOS DO YUTA/usuarios/banned.json', JSON.stringify(ban))
await yuta.sendMessage(from, {text: mess.bannedMessage(blcp), mentions: [blcp]})
break

case 'unblockuser':
if(!SoDono  && !isnit && !issupre && !ischyt && !info.key.fromMe) return reply(mess.onlyOwner())
if(!q.length > 6) return reply("Marque o @ do usuário que deseja desbloquear pra ele utilizar os comandos, ou o número da fórma que copiar...")
var blcp = q.replace(new RegExp("[()+-/ @+/]", "gi"), "")+"@s.whatsapp.net"
var numbl = ban.indexOf(blcp)
if(numbl < 0) return reply('*Esse número não está incluso na lista de bloqueados.*')
pesquisar = blcp
processo = ban.indexOf(pesquisar)
while(processo >= 0){
ban.splice(processo, 1)
processo = ban.indexOf(pesquisar)
}
fs.writeFileSync('./DADOS DO YUTA/usuarios/banned.json', JSON.stringify(ban))
await yuta.sendMessage(from, {text: mess.unbannedMessage(blcp), mentions: [blcp]})
break

case 'addcmdvip':
if(!SoDono) return reply(mess.onlyOwner())
tp = args.join(" ")
if(tp.includes("addcmdvip addcmdvip") || (tp.includes("addcmdvip  addcmdvip"))) return reply(`Tá louco maluco? Não tem como adicionar o mesmo comando.`)
if(isCmdVip.includes(args[0])) return reply('Este comando já está incluso na lista de comandos vip, verifique.')
isCmdVip.push(args[0])
fs.writeFileSync('./INFO_YUTA/media/nescessario.json', JSON.stringify(nescessario, null, 2))
reply(`O comando *${args[0]}* foi adicionado na lista de comandos vip.`)
break

case 'delcmdvip':
if(!SoDono) return reply(mess.onlyOwner())
tp = args.join(" ")
if(tp.includes("delcmdvip delcmdvip") || (tp.includes("delcmdvip  delcmdvip"))) return reply(`Tá louco maluco? Não tem como deletar o mesmo comando.`)  
if(!isCmdVip.includes(args[0])) return reply('Este comando já está excluído da lista de comandos vip.')
var i = isCmdVip.indexOf(args[0])
isCmdVip.splice(i, 1)
fs.writeFileSync('./INFO_YUTA/media/nescessario.json', JSON.stringify(nescessario, null, 2))
reply(`O comando *${args[0]}* foi tirado da lista de comandos vip.`)
break

case 'listacmdvip': case 'cmdviplist':
tkks = `[Total: *${isCmdVip.length}*] - Comandos que foram adicionados para uso Vip:\n–\n`
tkks += isCmdVip.map((v, index) =>  `\t• [ *N° ${index+1}* ] - Comando: ${prefix+v}`).join('\n–\n')
await yuta.sendMessage(from, {text: tkks.trim()}, {quoted: selo})
break

case 'blocklist':
if(ban.length == 0) return reply(`Existe *0* user(s) bloqueado(s), ou seja, não existe ninguém.`)
tkks = `[Total: *${ban.length}*] - Lista de Usuários bloqueados pelo julgamento do(s) donos(as):\n–\n`
tkks += ban.map((v, index) =>  `\t• [ *N° ${index+1}* ] - Usuário: @${v.split('@')[0]}`).join('\n–\n')
await yuta.sendMessage(from, {text: tkks.trim(), mentions: ban}, {quoted: selo})
break

case 'blockcmdgp':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
tp = args.join(" ")
if(tp.includes("blockcmd blockcmd") || (tp.includes("blockcmd  blockcmd"))) return reply(`Tá louco maluco?, Quer banir o comando de bloquear comando?`)
if(getComandoBlock(from).includes(args[0]))return reply('Este comando já está bloqueado.')
await addComandos(from, args[0])
reply(`O comando *${args[0]}* foi bloqueado no grupo com sucesso.`)
break

case 'unblockcmdgp':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
tp = args.join(" ")
if(tp.includes("blockcmd unblockcmd") || (tp.includes("blockcmd  unblockcmd"))) return reply(`Tá louco maluco?, Quer banir o comando de desbloquear comando?`)  
if(!getComandoBlock(from).includes(args[0])) return reply('Este comando já está desbloqueado.')
await deleteComandos(from, args[0])
reply(`O comando *${args[0]}* foi desbloqueado com sucesso no grupo.`)
break

case 'listblockcmdgp': case 'listbcmdgp':
if(!isGroup) return reply(mess.onlyGroup());
if(getComandoBlock(from).length == 0) return reply("Não existe ainda nenhum *comando bloqueado* neste grupo.");
tkks = `[Total: *${getComandoBlock(from).length}*] - Comandos bloqueados pelo adminstrador(s) do grupo:\n–\n`
tkks += getComandoBlock(from).map((v, index) =>  `\t• [ *N° ${index+1}* ] - Comando: ${prefix + getComandoBlock(from)[v]}`).join('\n–\n')
await yuta.sendMessage(from, {text: tkks.trim()}, {quoted: selo})
break

case 'blockcmdg':
if(!SoDono) return reply(mess.onlyOwner())
tp = args.join(" ")
if(tp.includes("blockcmdg blockcmdg") || (tp.includes("blockcmdg  blockcmdg"))) return reply(`Tá louco maluco? Não tem como adicionar o mesmo comando.`)
if(isblockCmdG.includes(args[0])) return reply('Este comando já está incluso na lista de *comandos bloqueados global*.')
isblockCmdG.push(args[0])
fs.writeFileSync('./INFO_YUTA/media/nescessario.json', JSON.stringify(nescessario, null, 2))
reply(`O comando *${args[0]}* foi adicionado na lista de comandos bloqueados global.`)
break

case 'unblockcmdg':
if(!SoDono) return reply(mess.onlyOwner())
tp = args.join(" ")
if(tp.includes("unblockcmdg unblockcmdg") || (tp.includes("unblockcmdg  unblockcmdg"))) return reply(`Tá louco maluco? Não tem como desbloquear o mesmo comando.`)  
if(!isblockCmdG.includes(args[0])) return reply('Este comando não está incluso na lista de *cmds bloqueados global*.')
var ab = isblockCmdG.indexOf(args[0])
isblockCmdG.splice(ab, 1)
fs.writeFileSync('./INFO_YUTA/media/nescessario.json', JSON.stringify(nescessario, null, 2))
reply(`O comando *${args[0]}* foi tirado da lista de cmds bloqueados global.`)
break

case 'listbcmdglobal':
if(isblockCmdG.length == 0) return reply("Não existe nenhum *comando bloqueado* na lista.")
tkks = `[Total: *${isblockCmdG.length}*] - Lista de comandos bloqueados pelo(s) meus proprietários:\n–\n`
tkks += isblockCmdG.map((v, index) =>  `\t• [ *N° ${index+1}* ] - Comando: ${prefix+v}`).join('\n–\n')
await yuta.sendMessage(from, {text: tkks.trim()}, {quoted: selo})
break

case 'getquoted': 
case 'getinfo': 
case 'get': 
case 'mek':
reply(JSON.stringify(info, null, 3))
break

case 'autorizar': case 'aceitar': case '✅': {
    if(!isGroupAdmins && !SoDono) return reply(mess.onlyAdmins()) // NKZIN AMA A HARU
    if(!isBotGroupAdmins) return reply(enviar.msg.Badmin)
    const req = await yuta.groupRequestParticipantsList(from)//queria ser bom na programação, estou preete a desistir.
    let totalRequest = req.length
if (req == 0) return reply(`*ɴᴀᴏ ᴛᴇᴍ ɴᴇɴʜᴜᴍᴀ sᴏʟɪᴄɪᴛᴀᴄᴀᴏ ɴᴏ ɢʀᴜᴘᴏ 💁‍♂️*`)
    for (var i of req) {
        i.jid.replace += `Sujeito: @${i.jid.replace("@s.whatsapp.net", "")}\nNúmero solicitante: ${i.jid.replace("@s.whatsapp.net", "")}\n`;
        await yuta.groupRequestParticipantsUpdate(from, [i.jid.replace("@s.whatsapp.net", "")+"@s.whatsapp.net"], "approve")
    }
    reply('*sᴏʟɪᴄɪᴛᴀᴄᴏᴇs ᴀᴄᴇɪᴛᴀs!!🙇‍♂️*')
}
break;//AMO ELA

case 'recusar': case '❌': {
    if (!isGroupAdmins && !SoDono) return reply(mess.onlyAdmins()) // Verifica se o usuário é admin
    if (!isBotGroupAdmins) return reply(enviar.msg.Badmin) // Verifica se o bot é admin

    const req = await yuta.groupRequestParticipantsList(from) // Obtém a lista de solicitações pendentes
    let totalRequest = req.length

    if (totalRequest == 0) return reply(`*ɴᴀᴏ ᴛᴇᴍ ɴᴇɴʜᴜᴍᴀ sᴏʟɪᴄɪᴛᴀᴄᴀᴏ ɴᴏ ɢʀᴜᴘᴏ 💁‍♂️*`)

    for (let i of req) {
        let userJid = i.jid // Pega o JID do usuário solicitante
        await yuta.groupRequestParticipantsUpdate(from, [userJid], "reject") // Rejeita a solicitação do usuário
    }
    
    reply('*sᴏʟɪᴄɪᴛᴀᴄᴏᴇs ʀᴇᴄᴜsᴀᴅᴀs!!🙇‍♂️*')
}
break

case 'solicitacao':
case 'soli':
if (!isGroup) return reply(mess.onlyAdmins());
if (!isGroupAdmins) return reply(mess.onlyGroup());
const solAll = await yuta.groupRequestParticipantsList(from);
if (solAll == false) return reply('Sem solicitações pendentes.');
let formattedString = solAll.map(item => `• Usuário: *@${item.jid.replace('@s.whatsapp.net', '')}*\n• Método de Requisição: *${item.request_method}*\n• Tempo: *${moment.unix(item.request_time).format('LLL')}*`).join('\n———\n');
mention(`[⚠️] - *SOLICITAÇÕES PENDENTES:*\n${formattedString}\n–\n• Caso queira aceitar use o comando ${prefix}autorizar`);
awaitMessage({chatJid: from, sender: sender, expectedMessages: ["sim", "nao", "não", "all", "noall", "exit"], filter: (info) => info?.message?.extendedTextMessage?.text || info?.message?.conversation}, yuta)
.then(async(collected) => {
const AutoResp = collected?.message?.extendedTextMessage?.text || collected?.message?.conversation;
const lowerCaseAutoResp = AutoResp.toLowerCase(); // Convert the user's input to lowercase
if (/sim/gi.test(lowerCaseAutoResp)) {
await yuta.groupRequestParticipantsUpdate(from, [solAll[0].jid], 'approve');
} else if (/não|nao/gi.test(lowerCaseAutoResp)) {
await yuta.groupRequestParticipantsUpdate(from, [solAll[0].jid], 'reject');
} else if (/noall/gi.test(lowerCaseAutoResp)) {
for (let i = 0; i < solAll.length; i++) {
await yuta.groupRequestParticipantsUpdate(from, [solAll[i].jid], 'reject');
}
} else if (/all/gi.test(lowerCaseAutoResp)) {
for (let i = 0; i < solAll.length; i++) {
await yuta.groupRequestParticipantsUpdate(from, [solAll[i].jid], 'approve');
}
}
}).catch(async (err) => {
console.log(err)
});
break;

case 'antiddd-list':
if(!isGroup) return await reply(mess.onlyGroup())
if(!isAntiDDD) return await reply(`Para usar este comando, você deve ativar o comando: antiddd\nExemplo: ${prefix}antiddd 1.`)
if(dataGp[0].ANTI_DDD.listaProibidos.length < 1) return await reply(`[!] Não existe nenhum ddd proibido neste grupo. Para adicionar à lista, use: ${prefix}add_ddd 21, por exemplo.`);
await reply(`Aqui está a lista de DDD proibidos no grupo: '${groupName}':\n• *[Total: ${dataGp[0].ANTI_DDD.listaProibidos.length}]* - ${dataGp[0].ANTI_DDD.listaProibidos.map((v, index) => v).join(", ")}`);
break

case 'add_ddd':
if(!isGroup) return await reply(mess.onlyGroup())
if(!isGroupAdmins) return await reply(mess.onlyAdmins())
if(!isAntiDDD) return await reply(`Para usar este comando, você deve ativar o comando: antiddd\nExemplo: ${prefix}antiddd 1.`)
if(!q.trim()) return await reply("Determine o DDD que você deseja adicionar na lista, não pode conter espaço vázio.")
if(q.trim() === 2) return await reply(`Um DDD possuí 2 dígitos numéricos, por exemplo: 81 (Este DDD pertence à Pernambuco).`)
if(dataGp[0].ANTI_DDD.listaProibidos.indexOf(q.trim()) >= 0) return await reply(`Esse DDD já se encontra incluso, procure ver na lista dos DDDs banidos no grupo, use: '${prefix}antiddd-list'`)
if(arrayDDDs.indexOf(q.trim()) >= 0) return await reply('O DDD preenchido é inválido, não existe nenhum número com este DDD atualmente.');
dataGp[0].ANTI_DDD.listaProibidos.push(q.trim())
setGp(dataGp)
await reply(`• O DDD '${q.trim()}' foi adicionado com sucesso à blacklist, agora os números que tiver o DDD de ${extractStateFromDDD(q.trim())} será imediatamente banido do grupo.`)
break

case 'delete_ddd': case 'del_ddd': case 'rm_ddd':
if(!isGroup) return await reply(mess.onlyGroup())
if(!isGroupAdmins) return await reply(mess.onlyAdmins())
if(!isAntiDDD) return await reply(`Para usar este comando, você deve ativar o comando: antiddd\nExemplo: ${prefix}antiddd 1.`) 
if(!q.trim()) return await reply("Determine o DDD que você deseja remover da lista, não pode conter espaço vázio.")
if(q.trim() === 2) return await reply(`Calma, só pode ser removido um DDD por vez.\n• Exemplo: ${prefix+command} 84, aí o bot não vai mais remover os DDDs pertencentes à Rio Grande do Sul.`)
if(dataGp[0].ANTI_DDD.listaProibidos.indexOf(q.trim()) < 0) return await reply(`Este DDD não está incluso, procure ver na lista dos DDDs excluídos para este grupo. Use: ${prefix}antiddd-list`)
if(dataGp[0].ANTI_DDD.listaProibidos.length == 0) return await reply("A lista atualmente está vázia, então não tem como remover nenhum DDD, adicione pelo menos um.")
dataGp[0].ANTI_DDD.listaProibidos.splice(dataGp[0].ANTI_DDD.listaProibidos.indexOf(q.trim()), 1)
setGp(dataGp)
await reply(`O DDD '${q.trim()}' tirado com sucesso da lista de DDDs excluídos do grupo com sucesso, agora o bot não irá mais impedir à entrada deles.`);
break

case 'prefixos':
if(!isGroup) return reply(mess.onlyGroup())
if(!isMultiP) return reply(`*ᴏ ᴍᴜʟᴛɪᴘʀᴇғɪx ᴘʀᴇᴄɪsᴀ ᴇsᴛᴀ ᴀᴛɪᴠᴏ 🤷‍♂️*`) 
if(dataGp[0].prefixos.length < 1) return reply("*ᴏᴘᴀ, ɴᴀᴏ ᴄᴏɴᴛᴇᴍ ɴᴇɴʜᴜᴍ ᴘʀᴇғɪxᴏ ᴀᴅɪᴄɪᴏɴᴀᴅᴏ ɴᴇssᴇ ɢʀᴜᴘᴏ.. 🤷‍♂️*")
reply(`*ᴛᴏᴛᴀʟ ᴅᴇ ᴘʀᴇғɪxᴏs:『 ${dataGp[0].prefixos.length} 』🍂*\n${dataGp[0].prefixos.map((v, index) => `「 ${v} 」\n`).join("")}`)
break

case 'add_prefixo':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isMultiP) return reply(`*ᴏ ᴍᴜʟᴛɪᴘʀᴇғɪx ᴘʀᴇᴄɪsᴀ ᴇsᴛᴀ ᴀᴛɪᴠᴏ 🤷‍♂️*`) 
if(ANT_LTR_MD_EMJ(q)) return reply("*ᴏᴘᴀ, ᴄᴀʟᴍᴀ ᴀɪ ᴘᴀɪᴢᴀᴜᴍ, ɴᴀᴅᴀ ᴅᴇ ʟᴇᴛʀᴀ ᴍᴏᴅɪғɪᴄᴀᴅᴀ ᴏᴜ ᴇᴍᴏᴊɪ 🙅‍♂️*")
if(!q.trim()) return reply("*ǫᴜᴀʟ ᴘʀᴇғɪxᴏ ᴠᴏᴄᴇ ᴅᴇsᴇᴊᴀ ᴄᴏʟᴏᴄᴀʀ? 🤷‍♂️*")
if(q.trim() > 1) return reply(`*ᴄᴀʟᴍᴀ ᴀɪ ᴘᴀɪᴢᴀᴜᴍ, ᴏ ᴘʀᴇғɪxᴏ sᴏ ᴘᴏᴅᴇ sᴇʀ ᴀᴅɪᴄɪᴏɴᴀᴅᴏ ᴜᴍ ᴅᴇ ᴄᴀᴅᴀ ᴠᴇᴢ 🙅‍♂️*`)
if(dataGp[0].prefixos.indexOf(q.trim()) >= 0) return reply(`*ᴇsᴛᴇ ᴘʀᴇғɪxᴏ ɴᴀᴏ ᴇsᴛᴀ ɪɴᴄʟᴜsᴏ 🙆‍♂️*`)
dataGp[0].prefixos.push(q.trim())
setGp(dataGp)
reply(`*ᴏ ᴘʀᴇғɪxᴏ『 ${q.trim()} 』ғᴏɪ ᴀᴅɪᴄɪᴏɴᴀᴅᴏ ᴀ ʟɪsᴛᴀ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*`)
break

case 'tirar_prefixo':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isMultiP) return reply(`*ᴏ ᴍᴜʟᴛɪᴘʀᴇғɪx ᴘʀᴇᴄɪsᴀ ᴇsᴛᴀ ᴀᴛɪᴠᴏ 🤷‍♂️*`)  
if(ANT_LTR_MD_EMJ(q)) return reply("*ᴏᴘᴀ, ᴄᴀʟᴍᴀ ᴀɪ ᴘᴀɪᴢᴀᴜᴍ, ɴᴀᴅᴀ ᴅᴇ ʟᴇᴛʀᴀ ᴍᴏᴅɪғɪᴄᴀᴅᴀ ᴏᴜ ᴇᴍᴏᴊɪ 🙅‍♂️*")
if(!q.trim()) return reply("*ǫᴜᴀʟ ᴘʀᴇғɪxᴏ ᴠᴏᴄᴇ ᴅᴇsᴇᴊᴀ ᴛɪʀᴀʀ? 🤷‍♂️*")
if(q.trim() > 1) return reply(`*ᴄᴀʟᴍᴀ ᴀɪ ᴘᴀɪᴢᴀᴜᴍ, ᴏ ᴘʀᴇғɪxᴏ sᴏ ᴘᴏᴅᴇ sᴇʀ ᴛɪʀᴀᴅᴏ ᴜᴍ ᴅᴇ ᴄᴀᴅᴀ ᴠᴇᴢ 🙅‍♂️*`)
if(dataGp[0].prefixos.indexOf(q.trim()) < 0) return reply(`*ᴇsᴛᴇ ᴘʀᴇғɪxᴏ ɴᴀᴏ ᴇsᴛᴀ ɪɴᴄʟᴜsᴏ 🙆‍♂️*`)
if(dataGp[0].prefixos.length == 1) return reply("*ᴀᴅɪᴄɪᴏɴᴇ ᴏᴜᴛʀᴏ ᴘʀᴇғɪxᴏ ᴘᴀʀᴀ ᴘᴏᴅᴇʀ ᴛɪʀᴀʀ ᴇssᴇ... 🤷‍♂️*")
dataGp[0].prefixos.splice(dataGp[0].prefixos.indexOf(q.trim()), 1)
setGp(dataGp)
reply(`*ᴏ ᴘʀᴇғɪxᴏ『 ${q.trim()} 』ғᴏɪ ᴛɪʀᴀᴅᴏ ᴅᴀ ʟɪsᴛᴀ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*`)
break

case 'multiprefixo': case 'multiprefix':  
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins && !SoDono) return reply(mess.onlyAdmins())
if(!isMultiP) {
dataGp[0].multiprefix = true
setGp(dataGp)
reply('*ᴏ ʀᴇᴄᴜʀsᴏ ᴍᴜʟᴛɪ ᴘʀᴇғɪxᴏ ғᴏɪ ᴀᴛɪᴠᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙇‍♂️*')
}
if(isMultiP) {
dataGp[0].multiprefix = false
setGp(dataGp)
   reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*')
}
break

case 'ephemeral': case 'msgtemp':
if (!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if (!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
getInfoG = await yuta.groupMetadata(from); /* Pegar as informações total do grupo! */
if (getInfoG.ephemeralDuration == undefined) {
reply(`As mensagens temporárias no grupo foram ativadas com sucesso.`)
await yuta.sendMessage(from, { disappearingMessagesInChat: WA_DEFAULT_EPHEMERAL})
} else if (getInfoG.ephemeralDuration > 1) {
reply(`As mensagens temporárias no grupo foram desativadas com sucesso.`)
await yuta.sendMessage(from, { disappearingMessagesInChat: false})
}
break

case 'rmphotogp': case 'rmfotogroup':
if (!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if (!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
reply(`A foto do grupo foi removida com sucesso.`)
await yuta.removeProfilePicture(from)
break



case 'legendabv':  
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(args.length < 1) return reply('*ᴄᴀᴅᴇ ᴀ ᴍᴇɴsᴀɢᴇᴍ? 🤷‍♂️*')
teks = body.slice(11)
if(isWelkom) {
dataGp[0].wellcome[0].legendabv = teks
setGp(dataGp)
reply('*ʟᴇɢᴇɴᴅᴀ ᴅᴇ ʙᴏᴀs ᴠɪɴᴅᴀs ᴀᴛᴜᴀʟɪᴢᴀᴅᴀ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*')
} else {
reply(`*ᴀᴛɪᴠᴇ ᴏ ${prefix}ʙᴇᴍᴠɪɴᴅᴏ 🤷‍♂️*`)
}
break

case 'legendabv2':  
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(args.length < 1) return reply('*ᴄᴀᴅᴇ ᴀ ᴍᴇɴsᴀɢᴇᴍ? 🤷‍♂️*')
teks = body.slice(12)
if(isWelkom2) {
dataGp[0].wellcome[1].legendabv = teks
setGp(dataGp)
reply('*ʟᴇɢᴇɴᴅᴀ ᴅᴇ ʙᴏᴀs ᴠɪɴᴅᴀs ᴀᴛᴜᴀʟɪᴢᴀᴅᴀ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*')
} else {
reply(`*ᴀᴛɪᴠᴇ ᴏ ${prefix}ʙᴇᴍᴠɪɴᴅᴏ2 🤷‍♂️*`)
}
break

case 'legendasaiu':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(args.length < 1) return reply('*ᴄᴀᴅᴇ ᴀ ᴍᴇɴsᴀɢᴇᴍ? 🤷‍♂️*')
teks = body.slice(13)
if(isWelkom) {
dataGp[0].wellcome[0].legendasaiu = Number(teks) === 0 ? 0 : teks
setGp(dataGp)
reply('*ʟᴇɢᴇɴᴅᴀ ᴅᴇ sᴀɪᴅᴀ ᴀᴛᴜᴀʟɪᴢᴀᴅᴀ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*')
} else {
reply(`*ᴀᴛɪᴠᴇ ᴏ ${prefix}ʙᴇᴍᴠɪɴᴅᴏ 🤷‍♂️*`)
}
break

case 'legendasaiu2':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(q.length < 1) return reply('*ᴄᴀᴅᴇ ᴀ ᴍᴇɴsᴀɢᴇᴍ? 🤷‍♂️*')
if(isWelkom2) {
dataGp[0].wellcome[1].legendasaiu = Number(teks) === 0 ? 0 : q
setGp(dataGp)
reply('*ʟᴇɢᴇɴᴅᴀ ᴅᴇ sᴀɪᴅᴀ ᴀᴛᴜᴀʟɪᴢᴀᴅᴀ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*')
} else {
reply(`*ᴀᴛɪᴠᴇ ᴏ ${prefix}ʙᴇᴍᴠɪɴᴅᴏ2 🤷‍♂️*`)
}
break

case 'legenda_estrangeiro':
case 'legenda_estrangeiros': 
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(args.length < 1) return reply('*ᴄᴀᴅᴇ ᴀ ᴍᴇɴsᴀɢᴇᴍ? 🤷‍♂️*')
if(isAntifake) {
dataGp[0].legenda_estrangeiro = q
setGp(dataGp)
reply('*Mensagem de remoção de estrangeiros definida com sucesso!*')
} else {
reply(`Ative o antifake primeiro para definir uma legenda, com: ${prefix}antifake 1`)
}
break

case 'legenda_video': 
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(args.length < 1) return reply('*Escreva a mensagem de remoção no antivideo*')
if(isAntiVid) {
dataGp[0].legenda_video = q
setGp(dataGp)
reply('*Mensagem de remoção de video definida com sucesso!*')
} else {
reply(`Ative o antivideo primeiro para definir uma legenda, com: ${prefix}antivideo`)
}
break

case 'legenda_imagem': 
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(args.length < 1) return reply('*Escreva a mensagem de remoção no antiimg*')
if(isAntiImg) {
dataGp[0].legenda_imagem = q
setGp(dataGp)
reply('*Mensagem de remoção de imagem definida com sucesso!*')
} else {
reply(`Ative o anti-imagem primeiro para definir uma legenda, com: ${prefix}antiimg`)
}
break

case 'legenda_documento': 
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(args.length < 1) return reply('*Escreva a mensagem de remoção no antidoc*')
if(Antidoc) {
dataGp[0].legenda_documento = q
setGp(dataGp)
reply('*Mensagem de remoção de documento definida com sucesso!*')
} else {
reply(`Ative o antidoc primeiro para definir uma legenda, com: ${prefix}antidoc 1`)
}
break

case 'addautorm':
case 'addautoban':
case 'listanegra':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins && !SoDono) return reply('Precisa ser Dono ou Adm')
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());
if(!mrc_ou_numero) return reply("Marque a mensagem do usuário com o comando ou utilize o comando com o número do usuário que deseja adicionar na lista negra..")
if(dataGp[0].listanegra.includes(mrc_ou_numero)) return reply('*Esse Número ja esta incluso*')
dataGp[0].listanegra.push(mrc_ou_numero)
setGp(dataGp)
reply(`*Número adicionado a lista de autoban*`)
break

case 'autobang':
case 'listanegrag':
if(!SoDono) return reply(mess.onlyOwner())
if(!mrc_ou_numero) return reply("Marque a mensagem do usuário com o comando ou utilize o comando com o número do usuário que deseja adicionar na lista negra Global..")
if(listanegraG.includes(mrc_ou_numero)) return reply('*Esse Número ja esta incluso*')
listanegraG.push(mrc_ou_numero)
fs.writeFileSync('./INFO_YUTA/media/nescessario.json', JSON.stringify(nescessario, null, '\t'))
reply(`*Número adicionado a lista de autoban*`)
break




case 'tirardalistag':
if(!SoDono) return reply(mess.onlyOwner())
if(!mrc_ou_numero) return reply("Marque a mensagem do usuário com o comando ou utilize o comando com o número do usuário que deseja tirar da lista negra..")
if(!listanegraG.includes(mrc_ou_numero)) return reply('*Esse Número não esta incluso*')
var i = listanegraG.indexOf(mrc_ou_numero)
listanegraG.splice(i, 1)
fs.writeFileSync('./INFO_YUTA/media/nescessario.json', JSON.stringify(nescessario, null, '\t'))
reply(`*Número foi removido da lista negra*`)
break

case 'delremover':
case 'delautorm':  
case 'delautoban': 
case 'tirardalista':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins && !SoDono) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(!mrc_ou_numero) return reply("Marque a mensagem do usuário com o comando ou utilize o comando com o número do usuário que deseja tirar da lista negra..")
if(!dataGp[0].listanegra.includes(mrc_ou_numero)) return reply('*Esse Número não esta incluso*')
var i = dataGp[0].listanegra.indexOf(mrc_ou_numero)
dataGp[0].listanegra.splice(i, 1)
setGp(dataGp)
reply(`*Número foi removido da lista de autoban*`)
break

case 'listban':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(dataGp[0].listanegra.length < 1) return reply('*Nenhum Número não foi adicionado*')
teks = '*Números que vou moer na porrada se voltar:*\n ‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎'
for(i=0;i<dataGp[0].listanegra.length;++i) {teks += `*${dataGp[0].listanegra[i].split('@')[0]}*\n`}
teks += '*Esses ai vou descer meu martelo do ban.*'
reply(teks)
break

case 'listbang':
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isGroupAdmins) return reply(mess.onlyAdmins());
    if(!SoDono) return reply(mess.onlyOwner());
    if (listanegraG.length < 1) return reply('*Nenhum Número foi adicionado à lista negra global*');
    
    teks = '*Números que vou moer na porrada se voltar: 😡😡*\n ‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎‏‎';
    for (let i = 0; i < listanegraG.length; ++i) {
        teks += `*${listanegraG[i].split('@')[0]}*\n`;
    }
    teks += '*Esses que eu deito na porrada se passar por aqui 🤷‍♂️*';
    reply(teks);
    break;
    

case 'desmute': case 'desmutar':
if(!isGroup) return reply(mess.onlyGroup());
if(!isGroupAdmins) return reply(mess.onlyAdmins());
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());
if(!menc_os2) return reply(`🎯 Por favor, mencione o usuário ou marque a mensagem do alvo que você deseja desmutar.`);
if(!muted[muted.map(i => i.grupo).indexOf(from)].usus.includes(menc_os2)) return mention(`O participante: '@${menc_os2.split("@")[0]}' não está na lista de mutados do grupo.`);
//// REMOVE O USUÁRIO DA LISTA:
mention(`O participante '@${menc_os2.split("@")[0]}' foi desmutado com sucesso pelo adminstrador(a): '@${sender.split("@")[0]}'.`);
muted[muted.map(i => i.grupo).indexOf(from)].usus.splice(menc_os2);
fs.writeFileSync("./DADOS DO YUTA/usuarios/muted.json", JSON.stringify(muted, null, 2));
break

//===========[ FIM CMD DONO/ADM'S ]=============\\

//=============[ ATIVACOES ]=========\\
case 'ativic':
    try {
        if (!isGroup) return reply(mess.onlyGroup());
        if (!isGroupAdmins) return reply(mess.onlyAdmins());
        if (!isBotGroupAdmins) return reply(mess.onlyBotAdmin());

        const todosAtivos = dataGp[0].jogos && 
             dataGp[0]['antilink'] && 
             dataGp[0]['antilinkhard'] && 
             dataGp[0].wellcome[1].bemvindo2 && 
             dataGp[0].x9 && 
             dataGp[0].antifake &&
             dataGp[0].antilinkgp;

        if (todosAtivos) {
            dataGp[0].jogos = false;
            dataGp[0]['antilink'] = false;
            dataGp[0]['antilinkhard'] = false;
            dataGp[0].wellcome[1].bemvindo2 = false;
            dataGp[0].x9 = false;
            dataGp[0].antifake = false;
            dataGp[0].antilinkgp = false;
            setGp(dataGp);
            reply('*ᴛᴏᴅᴏs ᴏs ᴄᴏᴍᴀɴᴅᴏs ɴᴇsᴄᴇssᴀʀɪᴏ ғᴏʀᴀᴍ ᴅᴇsᴀᴛɪᴠᴀᴅᴏs 🙅‍♂️*');
        } else {           
            dataGp[0].jogos = true;
            dataGp[0]['antilink'] = true;
            dataGp[0]['antilinkhard'] = true;
            dataGp[0].wellcome[1].bemvindo2 = true;
            dataGp[0].x9 = true;
            dataGp[0].antifake = true;
            dataGp[0].antilinkgp = true;
            setGp(dataGp);
            reply('*ᴛᴏᴅᴏs ᴏs ᴄᴏᴍᴀɴᴅᴏs ɴᴇsᴄᴇssᴀʀɪᴏ ғᴏʀᴀᴍ ᴀᴛɪᴠᴀᴅᴏs 🙇‍♂️*');
        }
    } catch (error) {
        console.error(error);
        reply('*ᴏᴄᴏʀʀᴇᴜ ᴜᴍ ᴇʀʀᴏ ᴀᴏ ᴇғᴇᴛᴜᴀʀ ᴏ ᴄᴏᴍᴀɴᴅᴏ ⚠*');
    }
    break;

case 'so_dono':
case 'bot':
if(!SoDono) return reply(mess.onlyOwner())
if(!isBotoff) {
nescessario.botoff = true
setNes(nescessario)
reply('*ᴏ ʙᴏᴛ ғᴏɪ ᴅᴇsʟɪɢᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ᴘʀᴀ ᴜsᴏ ᴅᴇ ᴍᴇᴍʙʀᴏs ᴇ ᴀᴅᴍs ᴅᴇ ɢʀᴜᴘᴏs 🙅‍♂️*');
} else if(isBotoff) {
nescessario.botoff = false
setNes(nescessario)
reply(`*ᴀᴛɪᴠᴀɴᴅᴏ ᴛᴏᴅᴏs ᴏs ғᴜɴᴄɪᴏɴᴀᴍᴇɴᴛᴏs ᴅᴏ ʙᴏᴛ ɴᴏᴠᴀᴍᴇɴᴛᴇ 🙇‍♂️*`)
}
break

case 'limitecaracteres':
case 'limiteflood':  
if (!isGroup) return reply(mess.onlyGroup());
if (!isGroupAdmins) return reply(mess.onlyAdmins());
if (!isBotGroupAdmins) return reply(mess.onlyBotAdmin());

if (isAntiFlood) {
    dataGp[0].limitec.active = false;
    setGp(dataGp);
    reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
} else {
    dataGp[0].limitec.active = true;
    setGp(dataGp);
    reply('*ᴏ ʀᴇᴄᴜʀsᴏ ʟɪᴍɪᴛᴇ ғʟᴏᴏᴅ ғᴏɪ ᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴇssᴇ ɢʀᴜᴘᴏ 🙇‍♂️*');
}
break;

case 'modocoins':
if (!isGroup) return reply(mess.onlyGroup());
if (!isGroupAdmins) return reply(mess.onlyAdmins());
if (!isBotGroupAdmins) return reply(mess.onlyBotAdmin());

if (isModoCoins) {
    dataGp[0].isModoCoins = false;
    setGp(dataGp);
    reply(`*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*`);
} else {
    dataGp[0].isModoCoins = true;
    setGp(dataGp);
    reply(`*ᴏ ʀᴇᴄᴜʀsᴏ N-ᴄᴏɪɴs ғᴏɪ ᴀᴛɪᴠᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴇssᴇ ɢʀᴜᴘᴏ 🙇‍♂️*`);
}
break;


case 'antiligar':
case 'antiligacao':  
case 'antiligação':  
if(!SoDono) return reply(mess.onlyOwner())
if(!isAnticall) {
nescessario.anticall = true
setNes(nescessario)
reply(`*ᴏ ʀᴇᴄᴜʀsᴏ ᴀɴᴛɪ ʟɪɢᴀʀ ғᴏɪ ᴀᴛɪᴠᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*`)
} else if(isAnticall) {
nescessario.anticall = false
setNes(nescessario)
reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
}
break

case 'simih':
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isGroupAdmins) return reply(mess.onlyAdmins());
    if (!isBotGroupAdmins) return reply(mess.onlyBotAdmin());
if (isSimi) {
    dataGp[0].simi1 = false; // Desativa o modo simi
    setGp(dataGp);
    reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
} else {
    dataGp[0].simi1 = true; // Ativa o modo simi
    setGp(dataGp);
    reply('*ᴏ ʀᴇᴄᴜʀsᴏ ᴍᴏᴅᴏ sɪᴍɪʜ ғᴏɪ ᴀᴛɪᴠᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*');
}
break;


case 'verificado-global':
case 'verificado':
try {
if(!SoDono) return reply(mess.onlyOwner())

	if (!nescessario.verificado) {

		nescessario.verificado = true;

		fs.writeFileSync(`./INFO_YUTA/media/nescessario.json`, JSON.stringify(nescessario, null, 2) + "\n");

		reply(`*ᴏ ʀᴇᴄᴜʀsᴏ ᴠᴇʀɪғɪᴄᴀᴅᴏ ɢʟᴏʙᴀʟ ғᴏɪ ᴀᴛɪᴠᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*`)
	} else if (nescessario.verificado) {

		nescessario.verificado = false

		fs.writeFileSync(`./INFO_YUTA/media/nescessario.json`, JSON.stringify(nescessario, null, 2) + "\n");

		reply(`*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙅‍♂️*`)
	}
} catch (e) {
	console.error(e);
	reply("Houve um erro no comando!");
}
break;

case 'console': 
if(!SoDono) return reply(mess.onlyOwner())
if(!isConsole) {
obrigadoEXT.consoleoff = true
setObg(obrigadoEXT)
reply(`*ᴍᴏᴅᴏ ᴄᴏɴsᴏʟᴇ ᴀᴛɪᴠᴏ, ᴀɢᴏʀᴀ ɪʀᴇɪ ᴄᴏɴsᴇɢᴜɪʀ ᴠᴇʀ ᴛᴏᴅᴏ ᴛɪᴘᴏ ᴅᴇ ᴍᴇɴsᴀɢᴇᴍ 🙇‍♂️*`) 
} else if(isConsole) {
obrigadoEXT.consoleoff = false
setObg(obrigadoEXT)
reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙅‍♂️*');
}
break

case 'audio-menu': 
if(!SoDono) return reply(mess.onlyOwner())
if(!isAudioMenu) {
obrigadoEXT.menu_audio = true
setObg(obrigadoEXT)
reply(`*ᴄᴇʀᴛᴏ ᴍᴇꜱᴛʀᴇ ᴀᴄᴀʙᴇɪ ᴅᴇ ᴀᴛɪᴠᴀʀ ᴏ ᴀᴜᴅɪᴏ-ᴍᴇɴᴜ 🙇‍♂️*`)
} else if(isAudioMenu) {
obrigadoEXT.menu_audio = false
setObg(obrigadoEXT)
reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙅‍♂️*');
}
break

case 'antipv':  
if(!SoDono) return reply(mess.onlyOwner())
if(!isAntiPv) {
nescessario.antipv = true
setNes(nescessario)
reply(`*ᴏ ʀᴇᴄᴜʀsᴏ ᴀɴᴛɪᴘᴠ ғᴏɪ ᴀᴛɪᴠᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*`)
} else if(isAntiPv) {
nescessario.antipv = false
setNes(nescessario)
reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙅‍♂️*');
}
break

case 'antipv2':
if(!SoDono) return reply(mess.onlyOwner())
if(!isAntiPv2) {
nescessario.antipv2 = true
setNes(nescessario)
reply("*ᴏ ʀᴇᴄᴜʀsᴏ ᴀɴᴛɪᴘᴠ2 ғᴏɪ ᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*")
} else if(isAntiPv2) {
nescessario.antipv2 = false
setNes(nescessario)
reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙅‍♂️*');
}
break

case 'antipv3':
if(!SoDono) return reply(mess.onlyOwner())
if(!isAntiPv3) {
nescessario.antipv3 = true
setNes(nescessario)
reply("*ᴏ ʀᴇᴄᴜʀsᴏ ᴀɴᴛɪᴘᴠ3 ғᴏɪ ᴀᴛɪᴠᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*")
} else if(isAntiPv3) {
nescessario.antipv3 = false
setNes(nescessario)
reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙅‍♂️*');
}
break

case 'visualizarmsg':
if(!SoDono) return reply(mess.onlyOwner())
if(!isVisualizar) {
nescessario.visualizarmsg = true
setNes(nescessario)
reply("*ᴏ ʀᴇᴄᴜʀsᴏ ᴅᴇ ᴠɪᴢᴜᴀʟɪᴢᴀʀ ᴍsɢ ғᴏɪ ᴀᴛɪᴠᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*")
} else if(isVisualizar) {
nescessario.visualizarmsg = false
setNes(nescessario)
reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙅‍♂️*');
}
break

case 'antipalavrão':
case 'antipalavrao':  
case 'antipalavra':    
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isGroupAdmins) return reply(mess.onlyAdmins());
    if (!isBotGroupAdmins) return reply(mess.onlyBotAdmin());
    
    // Alterna o estado do recurso de anti palavrão
    if (isPalavrao) {
        dataGp[0].antipalavrao.active = !dataGp[0].antipalavrao.active; // Inverte o estado atual
        setGp(dataGp);
        if (dataGp[0].antipalavrao.active) {
            reply('*ᴏ ʀᴇᴄᴜʀsᴏ ᴀɴᴛɪ ᴘᴀʟᴀᴠʀᴀᴏ ғᴏɪ ᴀᴛɪᴠᴀᴅᴏ ᴠʟᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙇‍♂️*');
        } else {
            reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
        }
    } else {
        dataGp[0].antipalavrao.active = true; // Se ainda não tiver configurado, ativa por padrão
        setGp(dataGp);
        reply('*ᴏ ʀᴇᴄᴜʀsᴏ ᴀɴᴛɪ ᴘᴀʟᴀᴠʀᴀᴏ ғᴏɪ ᴀᴛɪᴠᴀᴅᴏ ᴠʟᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙇‍♂️*');
    }
    
break;

case 'antinotas':
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isGroupAdmins) return reply(mess.onlyAdmins());
    if (!isBotGroupAdmins) return reply(mess.onlyBotAdmin());

    // Alternar o estado de antnotas
    dataGp[0].antinotas = !dataGp[0].antinotas;
    setGp(dataGp);

    if (dataGp[0].antinotas) {
        reply('*ᴏ ʀᴇᴄᴜʀsᴏ ᴀɴᴛɪɴᴏᴛᴀs ғᴏɪ ᴀᴛɪᴠᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙇‍♂️*');
    } else {
        reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
    }
    break;
 
  case 'modobn':  case 'modobrincadeira': case 'modobrincadeiras':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(isModobn) {
    dataGp[0].jogos = false
    setGp(dataGp)
    reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
} else {
    dataGp[0].jogos = true
    setGp(dataGp)
    reply('*ᴏ ʀᴇᴄᴜʀsᴏ ᴍᴏᴅᴏ ʙʀɪɴᴄᴀᴅᴇɪʀᴀ ғᴏɪ ᴀᴛɪᴠᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙇‍♂️*')
}
break

case 'autorepo':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(isAutorepo) {
    dataGp[0].autoresposta = false
    setGp(dataGp)
    reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
} else {
    dataGp[0].autoresposta = true
    setGp(dataGp)
    reply('*ᴏ ʀᴇᴄᴜʀsᴏ ᴀᴜᴛᴏʀᴇᴘᴏ ғᴏɪ ᴀᴛɪᴠᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙇‍♂️*')
}
break

case 'autofigu': case 'autosticker':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(isAutofigu) {
    dataGp[0].autosticker = false
    setGp(dataGp)
    reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
} else {
    dataGp[0].autosticker = true
    setGp(dataGp)
    reply('*ᴏ ʀᴇᴄᴜʀsᴏ ᴀᴜᴛᴏғɪɢᴜʀɪɴʜᴀs ғᴏɪ ᴀᴛɪᴠᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*')
}
break

case 'bangp':
case 'unbangp':
if(!isGroup) return reply(mess.onlyGroup())
if(!SoDono) return reply(mess.onlyOwner())
if(command == 'bangp'){
if(isBanchat) return reply(`*ᴏ ɢʀᴜᴘᴏ ᴊᴀ ᴇsᴛᴀ ʙᴀɴɪᴅᴏ sᴇɴʜᴏʀ(ᴀ) 🤷‍♂️*`)
dataGp[0].bangp = true
setGp(dataGp)
reply(`*ᴏ ɢʀᴜᴘᴏ ғᴏɪ ʙᴀɴɪᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ, ᴀɢᴏʀᴀ ɴɪɴɢᴜᴇᴍ ᴘᴏᴅᴇʀᴀ ᴜsᴀʀ ᴍᴇᴜs ᴄᴏᴍᴀɴᴅᴏs 🙇‍♂️*`)
} else {
if(!isBanchat) return reply(`*ᴇsᴛᴇ ɢʀᴜᴘᴏ ᴊᴀ ᴇsᴛᴀ ᴅᴇsʙᴀɴɪᴅᴏ sᴇɴʜᴏʀ(ᴀ) 🤷‍♂️*`)
dataGp[0].bangp = false
setGp(dataGp)
reply(`*ᴏ ɢʀᴜᴘᴏ ғᴏɪ ᴅᴇsʙᴀɴɪᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ sᴇɴʜᴏʀ(ᴀ), ᴀɢᴏʀᴀ ᴛᴏᴅᴏs ᴅᴇssᴇ ɢʀᴜᴘᴏ ᴘᴏᴅᴇ ᴜsᴀʀ ᴍᴇᴜs ᴄᴏᴍᴀɴᴏs 🙇‍♂️*`)
}
break
  
case 'gppv':
    if(!isGroup) return reply(mess.onlyGroup())
    if(!isGroupAdmins) return reply(mess.onlyAdmins())
    if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
    reply(`*ᴊᴀ ᴇsᴛᴏᴜ ᴇɴᴠɪᴀɴᴅᴏ ᴏ ʟɪɴᴋ ɴᴏ sᴇᴜ ᴘᴠ ${isCargo} 🙅‍♂️*`)
 linkgc = await yuta.groupInviteCode(from)
yuta.sendMessage(sender, { text: 'https://chat.whatsapp.com/' + linkgc}, {quoted: selo})
 break          
                          
case 'antilinkgp':
    if(!isGroup) return reply(mess.onlyGroup())
    if(!isGroupAdmins) return reply(mess.onlyAdmins())
    if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())

    // Verifica o estado atual do antilink
    if(isAntilinkgp) {
        // Se já estiver ativado, desativa
        dataGp[0].antilinkgp = false
        setGp(dataGp)
        reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
    } else {
        // Se estiver desativado, ativa
        dataGp[0].antilinkgp = true
        setGp(dataGp)
        reply('*ᴏ ʀᴇᴄᴜʀsᴏ ᴀɴᴛɪʟɪɴᴋ ғᴏɪ ᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙇‍♂️*')
    }
break

case 'antidocumento':
case 'antidoc':
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isGroupAdmins) return reply(mess.onlyAdmins());
    if (!isBotGroupAdmins) return reply(mess.onlyBotAdmin());

    // Alterna automaticamente o estado do antidoc
    if (dataGp[0].antidoc) {
        dataGp[0].antidoc = false;
        setGp(dataGp);
        reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
    } else {
        dataGp[0].antidoc = true;
        setGp(dataGp);
        reply('*ᴏ ʀᴇᴄᴜʀsᴏ ᴀɴᴛɪᴅᴏᴄᴜᴍᴇɴᴛᴏ ғᴏɪ ᴀᴛɪᴠᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙇‍♂️*');
    }
break;

case 'antictt':
case 'anticontato':
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isGroupAdmins) return reply(mess.onlyAdmins());
    if (!isBotGroupAdmins) return reply(mess.onlyBotAdmin());

    // Alterna automaticamente o estado do antictt
    if (dataGp[0].antictt) {
        dataGp[0].antictt = false;
        setGp(dataGp);
        reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
    } else {
        dataGp[0].antictt = true;
        setGp(dataGp);
        reply('*ᴏ ʀᴇᴄᴜʀsᴏ ᴀɴᴛɪ ᴄᴏɴᴛᴀᴛᴏ ғᴏɪ ᴀᴛɪᴠᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙇‍♂️*');
    }
break;

case 'antiddd':
case 'anti_ddd':
case 'anti-ddd':
    if (!isGroup) return await reply(mess.onlyGroup());
    if (!isGroupAdmins) return await reply(mess.onlyAdmins());
    if (!isBotGroupAdmins) return await reply(mess.onlyBotAdmin());

    // Alterna automaticamente o estado do antiDDD
    if (dataGp[0].ANTI_DDD.active) {
        dataGp[0].ANTI_DDD.active = false;
        setGp(dataGp);
        await reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
    } else {
        dataGp[0].ANTI_DDD.active = true;
        setGp(dataGp);
        await reply('*ᴏ ʀᴇᴄᴜʀsᴏ ᴀɴᴛɪᴅᴅᴅ ғᴏɪ ᴀᴛɪᴠᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙇‍♂️*');
    }
break;

case 'antiloc':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(isAntiLoc) {
    dataGp[0].antiloc = false
    setGp(dataGp)
    reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
} else {
    dataGp[0].antiloc = true
    setGp(dataGp)
    reply('*ᴏ ʀᴇᴄᴜʀsᴏ ᴀɴᴛɪ ʟᴏᴄᴀʟɪᴢᴀᴄᴀᴏ ғᴏɪ ᴀᴛɪᴠᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*')
}
break

case 'antiporn':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(isAntiPorn) {
    dataGp[0].antiporn = false
    setGp(dataGp)
    reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
} else {
    dataGp[0].antiporn = true
    setGp(dataGp)
    reply('*ᴏ ʀᴇᴄᴜʀsᴏ ᴀɴᴛɪᴘᴏʀɴᴏɢʀᴀғɪᴀ ғᴏɪ ᴀᴛɪᴠᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙇‍♂️*')
}
break

case 'antifake':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins && !SoDono) return reply(mess.onlyAdmins())
if(isAntifake) {
    dataGp[0].antifake = false
    setGp(dataGp)
    reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
} else {
    dataGp[0].antifake = true
    setGp(dataGp)
    reply('*ᴏ ʀᴇᴄᴜʀsᴏ ᴀɴᴛɪғᴀᴋᴇ ғᴏɪ ᴀᴛɪᴠᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙇‍♂️*')
}
break

case 'anticatalogo':
case 'anticatalg':  
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isGroupAdmins) return reply(mess.onlyAdmins());
    if (!isBotGroupAdmins) return reply(mess.onlyBotAdmin());

    if (isAnticatalogo) {
        dataGp[0].anticatalogo = false;
        setGp(dataGp);
        reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
    } else {
        dataGp[0].anticatalogo = true;
        setGp(dataGp);
        reply('*ᴏ ʀᴇᴄᴜʀsᴏ ᴀɴᴛɪᴄᴀᴛᴀʟᴀɢᴏ ғᴏɪ ᴀᴛɪᴠᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*');
    }
    break;

case 'bemvindo':
case 'welcome':
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isGroupAdmins && !SoDono) return reply(mess.onlyAdmins());
    if (!isBotGroupAdmins) return reply(mess.onlyBotAdmin());

    if (isWelkom) {
        dataGp[0].wellcome[0].bemvindo1 = false;
        setGp(dataGp);
        reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
    } else {
        dataGp[0].wellcome[0].bemvindo1 = true;
        setGp(dataGp);
        reply('*ᴏ ʀᴇᴄᴜʀsᴏ ʙᴇᴍᴠɪɴᴅᴏ ғᴏɪ ᴀᴛɪᴠᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*');
    }
    break;
    
    case 'antiaudio':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(isAntiAudio) {
    dataGp[0].antiaudio = false
    setGp(dataGp)
    reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
} else {
    dataGp[0].antiaudio = true
    setGp(dataGp)
    reply('*ᴏ ʀᴇᴄᴜʀsᴏ ᴀɴᴛɪ ᴀᴜᴅɪᴏ ғᴏɪ ᴀᴛɪᴠᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙇‍♂️*')
}
break

case 'antisticker':
    if(!isGroup) return reply(mess.onlyGroup())
    if(!isGroupAdmins) return reply(mess.onlyAdmins())
    if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())

    // Alternar o estado de antisticker
    dataGp[0].antisticker = !dataGp[0].antisticker;
    setGp(dataGp);

    if(dataGp[0].antisticker) {
        reply('*ᴀᴛɪᴠᴏᴜ ᴄᴏᴍ sᴜᴄᴇssᴏ ᴏ ʀᴇᴄᴜʀsᴏ ᴀɴᴛɪ sᴄᴛɪᴄᴋᴇʀ 🙇‍♂️*');
    } else {
        reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
    }
    break;


case 'antiimg':
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isGroupAdmins) return reply(mess.onlyAdmins());
    if (!isBotGroupAdmins) return reply(mess.onlyBotAdmin());

    // Alternar o estado de antiimagem
    dataGp[0].antiimg = !dataGp[0].antiimg;
    setGp(dataGp);

    if (dataGp[0].antiimg) {
        reply('*ᴀᴛɪᴠᴏᴜ ᴄᴏᴍ sᴜᴄᴇssᴏ ᴏ ʀᴇᴄᴜʀsᴏ ᴀɴᴛɪ ɪᴍᴀɢᴇᴍ ɴᴏ ɢʀᴜᴘᴏ 🙇‍♂️*');
    } else {
        reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
    }
    break;

case 'antivideo':
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isGroupAdmins) return reply(mess.onlyAdmins());
    if (!isBotGroupAdmins) return reply(mess.onlyBotAdmin());

    // Alternar o estado de antivídeo
    dataGp[0].antivideo = !dataGp[0].antivideo;
    setGp(dataGp);

    if (dataGp[0].antivideo) {
        reply('*ᴀᴛɪᴠᴏᴜ ᴄᴏᴍ sᴜᴄᴇssᴏ ᴏ ʀᴇᴄᴜʀsᴏ ᴀɴᴛɪ ᴠɪᴅᴇᴏ ɴᴏ ɢʀᴜᴘᴏ 🙇‍♂️*');
    } else {
        reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
    }
    break;
    
    case 'x9adm':
    case 'x9':
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isGroupAdmins) return reply(mess.onlyAdmins());
    if (!isBotGroupAdmins) return reply(mess.onlyBotAdmin());

    // Alternar o estado de x9
    dataGp[0].x9 = !dataGp[0].x9;
    setGp(dataGp);

    if (dataGp[0].x9) {
        reply('*ᴀᴛɪᴠᴏᴜ ᴄᴏᴍ sᴜᴄᴇssᴏ ᴏ ᴄᴏᴍᴀɴᴅᴏ x9 ᴀᴅɪᴍɪɴ 🙇‍♂️*');
    } else {
        reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
    }
    break;

case 'antilink':
case 'antilinkhard':
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isGroupAdmins) return reply(mess.onlyAdmins());
    if (!isBotGroupAdmins) return reply(mess.onlyBotAdmin());

    // Alternar o estado de antilink e antilinkhard
    dataGp[0]['antilink'] = !dataGp[0]['antilink'];
    dataGp[0]['antilinkhard'] = dataGp[0]['antilink']; // Sincroniza antilinkhard com antilink
    setGp(dataGp);

    if (dataGp[0]['antilink']) {
        reply('*ᴏ ʀᴇᴄᴜʀsᴏ ᴀɴᴛɪʟɪɴᴋʜᴀʀᴅ ғᴏɪ ᴀᴛɪᴠᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*');
    } else {
        reply('*ᴏ ʀᴇᴄᴜʀsᴏ ᴀɴᴛɪʟɪɴᴋʜᴀʀᴅ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
    }
    break;
    
    
    case 'bemvindo2':  
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isGroupAdmins && !SoDono) return reply(mess.onlyAdmins());

    // Alternar o estado de bemvindo2
    dataGp[0].wellcome[1].bemvindo2 = !dataGp[0].wellcome[1].bemvindo2;
    setGp(dataGp);

    if (dataGp[0].wellcome[1].bemvindo2) {
        reply('*ᴏ ʀᴇᴄᴜʀsᴏ ʙᴇᴍᴠɪɴᴅᴏ2 ғᴏɪ ᴀᴛɪᴠᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*');
    } else {
        reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
    }
    break;

case 'x9visuunica':
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isGroupAdmins) return reply(mess.onlyAdmins());
    if (!isBotGroupAdmins) return reply(mess.onlyBotAdmin());

    // Alternar o estado de x9visuunica
    dataGp[0].X9VisuUnica = !dataGp[0].X9VisuUnica;
    setGp(dataGp);

    if (dataGp[0].X9VisuUnica) {
        reply('*ᴀᴛɪᴠᴏᴜ ᴄᴏᴍ sᴜᴄᴇssᴏ ᴏ ʀᴇᴄᴜʀsᴏ x9ᴠɪᴢᴜᴜɴɪᴄᴀ 🙇‍♂️*');
    } else {
        reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
    }
    break;

case 'so_adm':
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isGroupAdmins) return reply(mess.onlyAdmins());
    if (!isBotGroupAdmins) return reply(mess.onlyBotAdmin());

    // Alternar o estado de so_adm
    dataGp[0].soadm = !dataGp[0].soadm;
    setGp(dataGp);

    if (dataGp[0].soadm) {
        reply('*ᴀᴛɪᴠᴏᴜ ᴄᴏᴍ sᴜᴄᴇssᴏ ᴏ ʀᴇᴄᴜʀsᴏ sᴏ ᴀᴅᴍ ɴᴏ ɢʀᴜᴘᴏ 🙇‍♂️*');
    } else {
        reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
    }
    break;

case 'odelete':
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isGroupAdmins && !SoDono) return reply(mess.onlyAdmins());
    if (!isBotGroupAdmins) return reply(mess.onlyBotAdmin());

    // Alternar o estado de odelete
    nescessario.Odelete = !nescessario.Odelete;
    setNes(nescessario);

    if (nescessario.Odelete) {
        reply('*ᴀᴛɪᴠᴏᴜ ᴄᴏᴍ sᴜᴄᴇssᴏ ᴏ ʀᴇᴄᴜʀsᴏ ᴏᴅᴇʟᴇᴛᴇ ɴᴏs ɢʀᴜᴘᴏs 🙇‍♂️*');
    } else {
        reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏs ɢʀᴜᴘᴏs 🙅‍♂️*');
    }
    break;

case 'antilinkeasy':
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isGroupAdmins) return reply(mess.onlyAdmins());
    if (!isBotGroupAdmins) return reply(mess.onlyBotGroupAdmins());

    // Alternar o estado de antilinkeasy
    dataGp[0].antilinkeasy = !dataGp[0].antilinkeasy;
    setGp(dataGp);

    if (dataGp[0].antilinkeasy) {
        reply('*ᴀᴛɪᴠᴏᴜ ᴄᴏᴍ sᴜᴄᴇssᴏ ᴏ ᴀɴᴛɪʟɪɴᴋᴇᴀsʏ ɴᴏ ɢʀᴜᴘᴏ 🙇‍♂️*');
    } else {
        reply('*ᴏ ʀᴇᴄᴜʀsᴏ ғᴏɪ ᴅᴇsᴀᴛɪᴠᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ɴᴏ ɢʀᴜᴘᴏ 🙅‍♂️*');
    }
    break; 
    
    
//===============[ FIM DAS ATIVACOES ]============\\   

//============[ RANDOM CMD ]=============\\

case 'stickerinfo': case 'stmetadata': 
if(!isQuotedSticker) return reply('Por favor, é nescessário mencionar um sticker para obter sucesso à execução do comando.');
try {
  extractBuffer = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker')
  stickerMetadata = await extractMetadata(extractBuffer);
  await yuta.sendMessage(from, {image: extractBuffer, caption: `• Emojis: *${stickerMetadata?.emojis?.join(' ') || '❌'}*\n• ID do Pacote: *${stickerMetadata['sticker-pack-id'] || '❌'}*\n• Nome do Pacote: *${stickerMetadata['sticker-pack-name'] || '❌'}*\n• Autor do Pacote:  *${stickerMetadata['sticker-pack-publisher'] || stickerMetadata['sticker-author-name'] || '❌'}*\n• Sticker Maker _(Android 🚀)_: *${stickerMetadata['Android 🚀-app-store-link'] || '❌'}*\n• Sticker Maker _(iOS)_: *${stickerMetadata['ios-app-store-link']|| '❌'}*`}, {quoted: selo});
} catch(error) {
  return reply('[#] Ocorreu um erro ao obter a metadata do sticker, tente com outro...')
};
break


case 'anotar':
case 'tirar_nota':
case 'rmnota':
if(!isGroup) return reply(`Só em grupo pode utilizar este comando.`)
if(!isGroupAdmins) return reply(`Só adm pode utilizar este tipo de comando.`)
if(command == "anotar") {
var [q5, q10] = q.trim().split("|")
if(!q5 || !q10 || !q.includes("|")) return reply(`Digite o título da anotação e o texto que deseja anotar..\nExemplo: ${prefix}anotar Cachorro|Cachorros são bom pra comer na Venezuela...`)
if(JSON.stringify(anotar).includes(from)) {  
var i2 = anotar.map(i => i.grupo).indexOf(from)  
if(JSON.stringify(anotar[i2].puxar).includes(q5)) {
var i3 = anotar[i2].puxar.map(i => i.nota).indexOf(q5)  
if(anotar[i2].puxar[i3].nota == q5) return reply(`Esta anotação já está inclusa, utilize outro título.. Ou você pode tirar com\n${prefix}tirar_nota ${q5}`)
}
}
if(!JSON.stringify(anotar).includes(from)) {
anotar.push({grupo: from, puxar: [{nota: q5, anotacao: q10}]})
fs.writeFileSync("./DADOS DO YUTA/func/anotar.json", JSON.stringify(anotar))
reply("Anotação registrada com sucesso...")
} else {
anotar[i2].puxar.push({nota: q5, anotacao: q10})
fs.writeFileSync("./DADOS DO YUTA/func/anotar.json", JSON.stringify(anotar))
reply("Anotação registrada com sucesso...")  
}
} else {
if(!q) return reply("Digite qual anotação deseja tirar pelo título..")
if(JSON.stringify(anotar).includes(from)) {  
var i2 = anotar.map(i => i.grupo).indexOf(from)  
if(JSON.stringify(anotar[i2].puxar).includes(q)) {
var i3 = anotar[i2].puxar.map(i => i.nota).indexOf(q)  
}
}
if(0 > anotar[i2].puxar.map(i => i.nota).indexOf(q)) return reply("Esta nota não está inclusa, verifique com atenção...")
anotar[i2].puxar.splice(i3, 1)
fs.writeFileSync("./DADOS DO YUTA/func/anotar.json", JSON.stringify(anotar))
reply(`Anotação ${q} tirada com sucesso...`)
}
break

case 'anotacao':
case 'anotacoes':  
case 'nota':
case 'notas':
if(!isGroup) return reply(`Só em grupo pode utilizar este comando.`)
if(command == "anotacao" || command == "nota") {
if(!q) return reply("Digite o título da anotação que deseja puxar..")
if(!JSON.stringify(anotar).includes(from)) return reply("Este grupo não tem nenhuma anotação...")
var i2 = anotar.map(i => i.grupo).indexOf(from)  
if(!JSON.stringify(anotar[i2].puxar).includes(q)) return reply("Não contém nenhuma anotação com este título.")
var i3 = anotar[i2].puxar.map(i => i.nota).indexOf(q)  
mentions(`〈 ${anotar[i2].puxar[i3].anotacao} 〉`)
} else {
var i2 = anotar.map(i => i.grupo).indexOf(from)    
if(anotar[i2].puxar.length == 0) return reply("Este grupo não tem nenhuma anotação...")    
var i2 = anotar.map(i => i.grupo).indexOf(from) 
var antr = anotar[i2].puxar 
txtin = `Aqui está todas as anotações registradas em minha DADOS DO YUTA do grupo: *[ ${groupName} ]*\n`
for ( i = 0; i < antr.length; i++) {
txtin += `\n↝ Anotação: ⟮ ${anotar[i2].puxar[i].nota} ⟯ - 〈 ${anotar[i2].puxar[i].anotacao} 〉\n`
}
txtin += ""
reply(txtin)
}
break

case 'download-link':
if(q.includes("video") || q.includes("mp4")) {
await yuta.sendMessage(from, {video: {url: q}, mimetype: 'video/mp4'}, {quoted: selo}).catch(async(e) => {
reply("Erro, visualize se este link é válido...")
})
} else if(q.includes("webp") || q.includes("jpg")) {
await yuta.sendMessage(from, {image: {url: q}}, {quoted: selo}).catch(async(e) => {
reply("Erro, visualize se este link é válido...")
})
}
break


case 'figurinhas':
  if (!q) return reply("Por favor, informe a quantidade de figurinhas que deseja que eu envie!");
//if (q) return reply(`Enviando ${q} figurinhas Aguarde...`);
  if (!Number(q.trim()) || Number(q.trim()) > 5) return reply("Digite a quantidade de figurinhas desejada, sendo no máximo 5.");
async function figfig() {
yuta.sendMessage(from, { sticker: { url: `https://jeff-apis.tech/figurinhas?apikey=${API_KEY_JEFF}` }
});
}
for (let i = 0; i < q; i++) {
await sleep(680);
figfig();
}
break;


case 'criador':
await reagir(from, "😼")
  try {
    const thumbnail = await getBuffer(`https://files.catbox.moe/9y6t3v.mp4`);
    if (!thumbnail) throw new Error("Thumbnail não carregado");

    await yuta.sendMessage(from, {
      video: thumbnail,
      caption: `https://Wa.me/${ownerNumber}?text=Estou%20querendo%20alugar%20por%2015%20dias%20✅\n\n*ᴠᴏᴄᴇ ǫᴜᴇʀ ғᴀʟᴀʀ ᴄᴏᴍ ᴍᴇᴜ ᴄʀɪᴀᴅᴏʀ ❓*\n\n*ᴄʟɪǫᴜᴇ ᴀʟɪ ᴇᴍ ᴄɪᴍᴀ ǫᴜᴇ ɪʀᴀ ᴅɪʀᴇᴛᴀᴍᴇɴᴛᴇ ᴀᴛᴇ ᴇʟᴇ 🙇‍♂️*\n\n*ɴɪᴄᴋ ᴅᴇʟᴇ - ${ownerName}*\n\n${NomeDoBot}`,
      gifPlayback: true,
      contextInfo: {
      forwardingScore: 1,
isForwarded: true,
forwardedNewsletterMessageInfo: {
newsletterJid: `${setting.channelnk}`, 
newsletterName: `${NomeDoBot}` 
        }
      }
    }, { quoted: selo });
  } catch (e) {
    console.error("Erro ao executar o comando:", e);
    await yuta.sendMessage(from, { text: "Desculpe, ocorreu um erro ao tentar carregar o vídeo." }, { quoted: selo });
  }
  break;


case 'destrava':
await yuta.sendMessage(from, {text: destrava(prefix)}, {quoted: selo})
break 

case 'perfil':
    try {
        var ppimg = await yuta.profilePictureUrl(sender, "image");
    } catch (e) {
        var ppimg = "https://telegra.ph/file/b5427ea4b8701bc47e751.jpg";
        console.log("Erro ao obter imagem de perfil:", e);
    }

    let status;
    try {
        status = (await yuta.fetchStatus(sender)).status;
    } catch {
        status = "Não consegui";
    }

    const conselho = (advices.commonAdvices && advices.commonAdvices.length > 0)
        ? advices.commonAdvices[Math.floor(Math.random() * advices.commonAdvices.length)]
        : "Sem conselho disponível.";

    const nivel = Array.from({ length: 9 }, (_, i) => (i + 1).toString());
    const nivelgador = nivel[Math.floor(Math.random() * nivel.length)];
    const nivelgado2r = nivel[Math.floor(Math.random() * nivel.length)];
    const putar = nivel[Math.floor(Math.random() * nivel.length)];
    const putar2 = nivel[Math.floor(Math.random() * nivel.length)];
    const gostosurar = nivel[Math.floor(Math.random() * nivel.length)];
    const gostosurar2 = nivel[Math.floor(Math.random() * nivel.length)];
    const gayr = nivel[Math.floor(Math.random() * nivel.length)];
    const gayr2 = nivel[Math.floor(Math.random() * nivel.length)];
    const linder = nivel[Math.floor(Math.random() * nivel.length)];
    const linder2 = nivel[Math.floor(Math.random() * nivel.length)];
    const gadop = `${Math.floor(Math.random() * 100)}`;
    const programa = Math.ceil(Math.random() * 10000);

    try {
        await yuta.sendMessage(from, {
            image: { url: ppimg }, 
            caption: `╔═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╗
║ 〽️ 𝐃𝐀𝐃𝐎𝐒 𝐃𝐎 𝐔𝐒𝐄𝐑 〽️
╚═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╝
║
╔═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╗
║✰︎💗⋗ 𝐍𝐈𝐂𝐊 - ${pushname}
║★💞⋗ 𝐍𝐔𝐌𝐄𝐑𝐎 - ${sender.split("@")[0]}
║✰🏮⋗ 𝐁𝐈𝐎 - ${status}
║★🌹⋗ 𝐕𝐈𝐏 - ${isChVip}
║✰✨⋗ 𝐂𝐀𝐑𝐆𝐎 - ${isCargo}
╚═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╝
║
╔═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╗
║ ⚠ 𝐏𝐄𝐑𝐒𝐎𝐍𝐀𝐋𝐈𝐃𝐀𝐃𝐄 ⚠️
╚═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╝
║
╔═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╗
║★🐂⋗ 𝐍𝐈𝐕𝐄𝐋-𝐆𝐀𝐃𝐎 - ${nivelgador}${nivelgado2r}%
║✰🔞⋗ 𝐍𝐈𝐕𝐄𝐋-𝐏𝐔𝐓𝐀 - ${putar}${putar2}%
║★😋⋗ 𝐍𝐈𝐕𝐄𝐋-𝐆𝐎𝐒𝐓𝐎𝐒𝐔𝐑𝐀 - ${gostosurar}${gostosurar2}%
║★🏳️‍🌈⋗ 𝐍𝐈𝐕𝐄𝐋-𝐆𝐀𝐘 - ${gayr}${gayr2}%
║✰😻⋗ 𝐍𝐈𝐕𝐄𝐋-𝐋𝐈𝐍𝐃𝐎(𝐀) - ${linder}${linder2}%
║★😈⋗ 𝐏𝐑𝐎𝐆𝐑𝐀𝐌𝐀 - R$${programa}
╚═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╝
🧸『 𝐂𝐎𝐍𝐒𝐄𝐋𝐇𝐎 』↴\n\n• ${conselho}\n\n${NomeDoBot}`
        }, { quoted: selo });
    } catch (e) {
        console.log("Erro ao enviar mensagem:", e);
    }
    break;
    

case 'ping':
    const speedConverted = (Date.now() / 1000) - info.messageTimestamp;
    const allGroups = await yuta.groupFetchAllParticipating();
    const groupList = Object.values(allGroups);
    const sortedGroups = [...groupList];    
    sortedGroups.sort((a, b) => a.length - b.length); 
    const groupNome = isGroup ? groupMetadata.subject : '';
    let timestamp = speed();
    let latensi = speed() - timestamp;
    hora1 = moment.tz('America/Sao_Paulo').format('HH:mm:ss');
    data1 = moment.tz("America/Sao_Paulo").format("DD/MM/YY");
reply(`✨ *ᴠᴇʟᴏᴄɪᴅᴀᴅᴇ* ↝ ${String(speedConverted.toFixed(3))} *sᴇɢᴜɴᴅᴏs*
🌟 *ʟᴀᴛᴇɴᴄɪᴀ* ↝ ${latensi.toFixed(3)} ᴍs
🖥️ *sɪsᴛᴇᴍᴀ ᴏᴘᴇʀᴀᴄɪᴏɴᴀʟ* ↝ ${os.type()}
📌 *ᴠᴇʀsᴀᴏ* ↝ ${os.release()}
📆 *ᴅᴀᴛᴀ* ↝ ${data1}
⏳ *ʜᴏʀᴀ* ↝ ${hora1}
  -
📉 *ᴍᴇᴍᴏʀɪᴀ ʀᴀᴍ ʟɪᴠʀᴇ* ↝ ${(os.freemem()/Math.pow(1024, 3)).toFixed(2)}/MB
📁 *ᴍᴇᴍᴏʀɪᴀ ʀᴀᴍ ᴛᴏᴛᴀʟ* ↝ ${(os.totalmem()/Math.pow(1024, 3)).toFixed(2)}/MB
👾 *ᴠᴇʀsᴀᴏ NᴏᴅᴇJs* ↝ ${process.version}
  -
🤖 *ᴇsᴛᴏᴜ ᴏᴘᴇʀᴀɴᴅᴏ ᴇᴍ* ↝ ${sortedGroups.length} *ɢʀᴜᴘᴏs*
⏰ *ᴛᴇᴍᴘᴏ ᴏɴʟɪɴᴇ* ↝ ${TimeCount(process.uptime())}
  -
${NomeDoBot}`)
break

case 'tabela':
await yuta.sendMessage(from, {text: tabela(prefix, NomeDoBot)}, {quoted: selo})
break 

case 'destrava2':
await yuta.sendMessage(from, {text: destrava2 (prefix)}, {quoted: selo})
break   

case 'gerarcpf':
cp1 = `${Math.floor(Math.random() * 300) + 600}`
cp2 = `${Math.floor(Math.random() * 300) + 600}`
cp3 = `${Math.floor(Math.random() * 300) + 600}`
cp4 = `${Math.floor(Math.random() * 30) + 60}`
cpf = `${cp1}.${cp2}.${cp3}-${cp4}`
await yuta.sendMessage(from, {text: `CPF gerado com sucesso: ${cpf}`}, {quoted: selo})
break

case 'ddd':
if(args.length < 1) return reply(`Use ${prefix + command} 81`)
ddd = body.slice(5)
ddds = await axios.get(`https://brasilapi.com.br/api/ddd/v1/${ddd}`)
dddlist = `Lista de Cidades de ${ddds.data.state} com este DDD ${q}>\n\n`
for (let i = 0; i < ddds.data.cities.length; i++) { dddlist += `${i + 1} ⪧ *${ddds.data.cities[i]}*\n` }
await yuta.sendMessage(from, {text: dddlist}, {quoted: selo})	
break

case 'gethtml':
if(!q || !isUrl(args[0])) return reply(`Modo de uso: ${prefix+command} link do site`)
try {
await replyWithReaction(`*ᴇɴᴠɪᴀɴᴅᴏ ᴇᴍ sᴇᴜ ᴘᴠ 🙇‍♂️*`, {react: {text: '✅', key: info.key}});
axios.get(args[0], { headers: {"user-agent": "Mozilla/5.0 (Linux; Android 10) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.136 Mobile Safari/537.36"}}).then(async (res) => {
let htmlData = typeof res.data === 'object' ? JSON.stringify(res.data, null, 2) : res.data
htmlData = htmlData.replace(/    /g, '').replace(/></g, '>\n<').replace(/> </g, '>\n<')
await yuta.sendMessage(sender, {document: Buffer.from(htmlData), fileName: q+`.html`, mimetype: 'text/html'}, {quoted: selo})}).catch(e => {return reply(mess.error())})
} catch (e) {
console.log(e)
reply(mess.error())
}
break

case 'revelar':
case 'rvisu':
case 'open':
    await reagir(from, "👀");

    if (JSON.stringify(info).includes("videoMessage")) {
        var Xoxota = info.message?.extendedTextMessage?.contextInfo?.quotedMessage;
        var video = Xoxota?.videoMessage || info.message?.videoMessage || 
                    Xoxota?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessageV2?.message?.videoMessage || 
                    info.message?.viewOnceMessage?.message?.videoMessage || Xoxota?.viewOnceMessage?.message?.videoMessage;

        if (video) {
            video.viewOnce = false;
            video.video = { url: video.url };
            video.caption += " ";
            yuta.sendMessage(from, video, { quoted: info });
        }
    } else if (JSON.stringify(info).includes("imageMessage")) {
        var Xoxota = info.message?.extendedTextMessage?.contextInfo?.quotedMessage;
        var image = Xoxota?.imageMessage || info.message?.imageMessage || 
                    Xoxota?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessageV2?.message?.imageMessage || 
                    info.message?.viewOnceMessage?.message?.imageMessage || Xoxota?.viewOnceMessage?.message?.imageMessage;

        if (image) {
            image.viewOnce = false;
            image.image = { url: image.url };
            image.caption += " ";
            yuta.sendMessage(from, image, { quoted: info });
        }
    } else if (JSON.stringify(info).includes("audioMessage") || info.message?.extendedTextMessage?.contextInfo?.quotedMessage?.viewOnceMessageV2Extension?.message?.audioMessage) {
        var audio = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage;
        
        if (audio) {
            if (!audio.mimetype) return;

            let buffAudio = await getFileBuffer(audio, 'audio');
            let audioFile = getRandom('.mp3');
            fs.writeFileSync(audioFile, buffAudio);

            let audioBuffer = fs.readFileSync(audioFile);
            yuta.sendMessage(from, { audio: audioBuffer, mimetype: 'audio/mpeg', ptt: false }, { quoted: info });

            fs.rmSync(audioFile);
        }
    } else {
        reply("• Marque uma Imagem, video ou áudio em visualização única.");
    }
    break;


case 'calculadora':
case 'calcular':  
case 'calc':
rsp = q.replace("x", "*").replace('"', ":").replace(new RegExp("[()abcdefghijklmnopqrstwuvxyz]", "gi"), "").replace("÷", "/")
return reply(JSON.stringify(eval(rsp, null,'\t')))
break 
 


case 'ptvmsg':
if (!isQuotedVideo && !info.message.videoMessage) return reply('Marque um vídeo/gif que você deseja converter para mensagem de vídeo.');
await yuta.relayMessage(from, {ptvMessage: isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage }, {})
break



case 'avalia': {
    try {
        // Verifica se é um grupo
        if (!isGroup) return reply(Res_SoGrupo);

        // Obtém os membros do grupo
        const groupMetadata = await yuta.groupMetadata(from);
        const members = groupMetadata.participants;

        // Seleciona um membro aleatório
        const randomMember = members[Math.floor(Math.random() * members.length)];

        // Obtém a foto de perfil do membro
        const profilePictureUrl = await yuta.profilePictureUrl(randomMember.id, 'image');

        // Avaliação personalizada
        const evaluations = [
            "Uma ótima escolha de foto de perfil!",
            "Essa foto mostra sua personalidade!",
            "Adorei a vibe dessa imagem!",
            "Você parece estar se divertindo nessa foto!",
            "Essa foto reflete bem quem você é!",
            "que lindo essa foto, ameiii!!"
        ];

        const randomEvaluation = evaluations[Math.floor(Math.random() * evaluations.length)];

        // Monta o objeto para enviar a mensagem
        const messageContent = {
            image: { url: profilePictureUrl }, 
            caption: `𝐔𝐒𝐔𝐀𝐑𝐈𝐎 🎶:『@${randomMember.id.split("@")[0]}』\n*𝐆𝐑𝐔𝐏𝐎 🧸*: ${groupName}\n*𝐂𝐄𝐋𝐔𝐋𝐀𝐑 💁‍♂️*: ${info.key.id.length > 21 ? 'ᴀɴᴅʀᴏɪᴅ 🤓' : info.key.id.substring(0, 2) == '3A' ? 'ɪᴏs 🙆‍♂️' : 'ᴢᴀᴘ ᴢᴀᴘ ᴡᴇʙ 🧏‍♂️'}\n*𝐂𝐎𝐍𝐓𝐄𝐌 𝐕𝐈𝐏 👻*: ${isChVip}\n\n*${randomEvaluation}*`, 
            mentions: [randomMember.id]
        };

        // Envia a mensagem no grupo
        yuta.sendMessage(from, messageContent);
    } catch (e) {
        console.error(e); // Log do erro para depuração
        return reply("Erro ao tentar avaliar a foto de perfil.");
    }
    break;
}

case 'getquoted':
reply(JSON.stringify(info.message.extendedTextMessage.contextInfo, null, 3))
break
    
case 'admins':
case 'listadmins':  
case 'listaadmins':   
if(!isGroup) return reply(mess.onlyGroup())
ytb = `Lista de admins do grupo *${groupMetadata.subject}*\n*Total de Adminstradores:* ${groupAdmins.length}\n-\n`
no = 0
for (let admon of groupAdmins) {
no += 1
ytb += `( ${no.toString()} ) - @${admon.split('@')[0]}\n`
}
await mentions(ytb, groupAdmins, true)
break

case 'consultar_vip':
if(!JSON.stringify(vip).includes(sender)) return reply("Você não está incluso atualmente na lista de usuários vip(s)..")
AB = vip.map(i => i.id).indexOf(sender)
await mention(`Usuário: @${vip[AB].id.split('@')[0]}\n• Expiração: ${vip[AAB].infinito == false ? `*Seu vip irá expirar em ${vip[AB].dias} dia${vip[AB].dias > 1 ? `s` : ``}.*` : `*Não existe um dia de expiração do seu vip.*`}`)
break

case 'viplist':
if(vip.length == 0) return reply(`Existe *0* user(s) vip(s), ou seja, não existe ninguém.`)
tkks = `[Total: *${vip.length}*] - Lista de usuário(s) vip temporário(s)/infinito(s):\n–\n`
tkks += vip.map((v, index) =>  `*[${index+1}]* - Usuário: @${v.id.split('@')[0]}\n• Expiração: ${v.infinito == false ? `*O vip do usuário expira em ${v.dias} dia${v.dias > 1 ? `s` : ``}.*` : `*Não existe um dia de expiração do vip do usuário.*`}`).join('\n––\n')
await mention(tkks)
break


case 'envpv':
case 'pv':{
if(!isGroup) return reply("*sᴏᴍᴇɴᴛᴇ ᴇᴍ ɢʀᴜᴘᴏs 🙇‍♂️*")
if(!menc_prt) return reply("*ᴍᴀʀǫᴜᴇ ᴀ ᴍsɢ ᴏᴜ ᴀ ᴍɪᴅɪᴀ ǫᴜᴇ ᴠᴏᴄᴇ ǫᴜᴇʀ ǫᴜᴇ ᴇᴜ ᴍᴀɴᴅᴇ ɴᴏ ᴘᴠ sᴇɴʜᴏʀ(ᴀ) 🙇‍♂️*")
var DFC = "";
var rsm = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var pink = isQuotedImage ? rsm?.imageMessage: info.message?.imageMessage
var blue = isQuotedVideo ? rsm?.videoMessage: info.message?.videoMessage
var purple = isQuotedDocument ? rsm?.documentMessage: info.message?.documentMessage
var yellow = isQuotedDocW ? rsm?.documentWithCaptionMessage?.message?.documentMessage: info.message?.documentWithCaptionMessage?.message?.documentMessage
var aud_d = isQuotedAudio ? rsm.audioMessage : ""
var figu_d = isQuotedSticker ? rsm.stickerMessage : ""
var red = isQuotedMsg && !aud_d && !figu_d && !pink && !blue&& !purple && !yellow? rsm.conversation: info.message?.conversation
var green = rsm?.extendedTextMessage?.text || info?.message?.extendedTextMessage?.text
if(pink && !aud_d && !purple) {
var DFC = pink
pink.caption = q.length > 1 ? "*ᴘʀᴏɴᴛᴏ sᴇɴʜᴏʀ(ᴀ) 🙇‍♂️*" :pink.caption.replace(new RegExp(prefix+command, "gi"), `*ᴘʀᴏɴᴛᴏ sᴇɴʜᴏʀ(ᴀ) 🙇‍♂️*`)
pink.image = {url: pink.url}
} else if(blue && !aud_d && !purple) {
var DFC = blue  
blue.caption = q.length > 1 ? "*ᴘʀᴏɴᴛᴏ sᴇɴʜᴏʀ(ᴀ) 🙇‍♂️*"+q.trim() :blue.caption.replace(new RegExp(prefix+command, "gi"), `*ᴘʀᴏɴᴛᴏ sᴇɴʜᴏʀ(ᴀ) 🙇‍♂️*`).trim()
blue.video = {url: blue.url}
} else if(red && !aud_d && !purple) {
black = {}
black.text = red.replace(new RegExp(prefix+command, "gi"), `*ᴘʀᴏɴᴛᴏ sᴇɴʜᴏʀ(ᴀ) 🙇‍♂️*`).trim()
var DFC = black
} else if(!aud_d && !figu_d && green && !purple && !purple) {
brown = {}
brown.text = green.replace(new RegExp(prefix+command, "gi"), `*ᴘʀᴏɴᴛᴏ sᴇɴʜᴏʀ(ᴀ) 🙇‍♂️*`).trim()
var DFC = brown
} else if(purple) {
var DFC = purple
purple.document = {url: purple.url}
} else if(yellow && !aud_d) {
var DFC = yellow 
yellow.caption = q.length > 1 ? "*ᴘʀᴏɴᴛᴏ sᴇɴʜᴏʀ(ᴀ) 🙇‍♂️*"+q.trim() :yellow.caption.replace(new RegExp(prefix+command, "gi"), `*ᴘʀᴏɴᴛᴏ sᴇɴʜᴏʀ(ᴀ) 🙇‍♂️*`).trim()
yellow.document = {url: yellow.url}
} else if(figu_d && !aud_d) {
var DFC = figu_d
figu_d.sticker = {url: figu_d.url}
} else if(aud_d) {
var DFC = aud_d
aud_d.audio = {url: aud_d.url}
aud_d.ptt = true
}
reply("*ᴏʟʜᴀ ᴏ ᴍᴇᴜ ᴘᴠ sᴇɴʜᴏʀ(ᴀ).💞*")
await yuta.sendMessage(sender, DFC, {quoted: selo}).catch(e => {
console.log(e)
})
}
break


case 'doc':
case 'docfake':
try {
sprd = "|"
if(!q) return reply(`${prefix + command} exemplo${sprd}500${sprd}apk\n-\nOs tipos aceitos por enquanto são: pdf > xml > zip > jpg > ppt > apk > txt > aac > pptx > aac > m4a > mp4 > mp3 > svg > png`)
kls = args.join(' ')
let nomedoc = kls.split(sprd)[0] || `${setting.NomeDoBot}`
let peso = kls.split(sprd)[1] * 1000000 || '1000000'
let mimetyp = kls.split(sprd)[2].replace(" ", "") || 'gif'
let thumbc = kls.split(sprd)[3] || 'https://google.com/'
if(mimetyp.toLowerCase() == 'pdf') mimetyp = 'application/pdf'
if(mimetyp.toLowerCase() == 'apk') mimetyp = 'application/vnd.Android 🚀.package-archive'
if(mimetyp.toLowerCase() == 'aac') mimetyp = 'audio/aac'
if(mimetyp.toLowerCase() == 'xml') mimetyp = 'application/xml'
if(mimetyp.toLowerCase() == 'zip') mimetyp = 'application/zip'
if(mimetyp.toLowerCase() == 'jpg') mimetyp = 'image/jpeg'
if(mimetyp.toLowerCase() == 'ppt') mimetyp = 'application/vnd.ms-powerpoint'
if(mimetyp.toLowerCase() == 'pptx') mimetyp = 'application/vnd.openxmlformats-officedocument.presentationml.presentation'
if(mimetyp.toLowerCase() == 'mp4') mimetyp = 'video/mp4'
if(mimetyp.toLowerCase() == 'm4a') mimetyp = 'audio/mpeg'
if(mimetyp.toLowerCase() == 'mp3') mimetyp = 'audio/mpeg'
if(mimetyp.toLowerCase() == 'gif') mimetyp = 'image/gif'
if(mimetyp.toLowerCase() == 'png') mimetyp = 'image/png'
if(mimetyp.toLowerCase() == 'svg') mimetyp = 'image/svg+xml'
if(mimetyp.toLowerCase() == 'txt') mimetyp = 'text/plain'
let Messagemdoc = {document: fs.readFileSync('./DADOS DO YUTA/data/docf.txt'), mimetype: mimetyp, jpegThumbnail: await getBuffer(thumbc), fileName: nomedoc, fileLength: peso, headerType: 4, contextInfo:{forwardingScore:999,isForwarded:true}}
await yuta.sendMessage(from, Messagemdoc, {quoted: selo})
} catch (err) {
console.log(err)
reply(mess.error())
}
break

case 'sender':
bla = isGroup ? info.key.participant : info.key.remoteJid
reply(bla)
break


case 'qc':
if(!q) return reply(`- Exemplo: ${prefix+command} ${NomeDoBot}`)
reply(mess.teste());
const text = `${q}`
const username2 = `${pushname}`
try {
ppimg = await yuta.profilePictureUrl(sender, 'image')
} catch {
ppimg = 'https://telegra.ph/file/cde0d7f5862fb5a6d8f24.jpg'
}
const { writeExifImg } = require('./INFO_YUTA/lib/exif')
yuta.sendImageAsSticker = async (jid, path, options = {}) => {
        let buff = Buffer.isBuffer(path) ? path : /^data:.*?\/.*?;base64,/i.test(path) ? Buffer.from(path.split`,`[1], 'base64') : /^https?:\/\//.test(path) ? await (await getBuffer(path)) : fs.existsSync(path) ? fs.readFileSync(path) : Buffer.alloc(0)
        let buffer
        if (options && (options.packname || options.author)) {
            buffer = await writeExifImg(buff, options)
        } else {
            buffer = await imageToWebp(buff)
        }
        await yuta.sendMessage(jid, { sticker: { url: buffer }, ...options})
        return buffer
    }
const avatar = `${ppimg}`
const json = {
  "type": "quote",
  "format": "png",
  "backgroundColor": "#000000",
  "width": 512,
  "height": 768,
  "scale": 2,
  "messages": [
    {
      "entities": [],
      "avatar": true,
      "from": {
        "id": 1,
        "name": username2,
        "photo": {
          "url": avatar
        }
      },
      "text": text,
      "replyMessage": {}
    }
  ]
};
 response = axios.post('https://bot.lyo.su/quote/generate', json, {
        headers: {'Content-Type': 'application/json'}
}).then(res => {
    const buffer = Buffer.from(res.data.result.image, 'base64')
        yuta.sendImageAsSticker(from, buffer, { packname: `${pushname}`, author: `${NomeDoBot}` })
       })
break

case 'cep':
try {
if(!q.trim()) return reply("digite o CEP que deseja buscar informações..");
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/consultacep?cep=51240230&apikey=${API_KEY_BRONXYS}`)
reply(`Cep: ${ABC.cep}\nRua: ${ABC.rua}\nComplemento: ${ABC.complemento}\nBairro: ${ABC.vizinhança}\nCidade: ${ABC.cidade}\nEstado: ${ABC.estado}\nGia: ${ABC.gia}\nIbge: ${ABC.ibge}\nddd: ${ABC.ddd}\nSiafi: ${ABC.siafi}`)
} catch (e) {
return reply(mess.error())
}
break

case 'infogp2':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins())
try {
var ppUrl = await yuta.profilePictureUrl(from, 'image')
} catch {
var ppUrl = `https://telegra.ph/file/6ca032835ed7a16748b6f.jpg`
}
var puxarInfo = await yuta.groupMetadata(from)
var ANC_INFO = puxarInfo.announce
var returnAnnounce = ANC_INFO === false ? "Não." : ANC_INFO === true ? "Sim." : undefined
var RST_INFO = puxarInfo.restrict 
var returnRestrict = RST_INFO === false ? "Sim." : RST_INFO === true ? "Não." : undefined
var infoCreator = puxarInfo.subjectOwner || "Não Encontrado"
infoGroup = `• Nome do Grupo: *${puxarInfo.subject}*\n• ID: *${puxarInfo.id}*\n-\n• Este grupo foi criado por: *@${infoCreator.replace("@s.whatsapp.net", "")}*\n• Data/hora de criação do grupo: *${moment(`${puxarInfo.creation}` * 1000).tz('America/Sao_Paulo').format('DD/MM/YYYY HH:mm:ss')}*\n• Horário e data da última alteração no grupo: *${moment(`${puxarInfo.subjectTime}` * 1000).format('DD/MM/YYYY HH:mm:ss')}*\n-\n• Quantidade de adminstradores: *${groupAdmins.length}*\n• Quantidade de membros: *${somembros.length}*\n• Soma total de membros e admins do grupo: *${puxarInfo.participants.length} participantes*\n-\n• Este grupo está fechado no momento? *${returnAnnounce}*\n• As informações do grupo podem ser alteradas por membros? *${returnRestrict}*\n-\n• Para ver as atividades dos participantes, use: *${prefix}atividade*\n• Para ver os membros inativos no grupo, use: *${prefix}inativos [quantidade de mensagens]*, ex: ${prefix}inativos 10`
await yuta.sendMessage(from, {image: {url: ppUrl}, caption: infoGroup, mentions: [infoCreator]}, {quoted: selo})
break

case 'grupoinfo':
            case 'infogrupo':
            case 'infogp':
            case 'gpinfo':
            case 'regras':
                if (!isGroup) return reply(`*Somente em grupos🙇‍♂️*`)
                ppUrl = await yuta.profilePictureUrl(from, 'image')
                const meetadata = await yuta.groupMetadata(from)
                yuta.sendMessage(from, { image: { url: ppUrl }, caption: `*>───⇌•:🌹: •⇋───<<*\n    𝐈𝐍𝐅𝐎 𝐆𝐑𝐔𝐏𝐎\n*>───⇌•:🌹: •⇋───<<*\n\n\n𝐍𝐎𝐌𝐄 : ${groupName}\n\n\n𝐌𝐄𝐌𝐁𝐑𝐎𝐒 : ${groupMembers.length}\n\n\n𝐀𝐃𝐌𝐒 : ${groupAdmins.length}\n\n\n𝐃𝐄𝐒𝐂𝐑𝐈𝐂𝐀𝐎 : ${meetadata.desc}`, thumbnail: null }, { quoted: selo })
                break

case 'encurtalink': case 'tinyurl':
if(args.length < 1) return reply(`❌️ *Forma incorreta, use está como exemplo:* ${prefix + command} https://instagram.com/yutabot.wpp`)
anu = await axios.get(`https://tinyurl.com/api-create.php?url=${q}`)
reply(`*Link encurtado com sucesso, aqui está:* ${anu.data}`).catch(async(error) => {
reply(mess.error())
})
break

case 'ata':
		        try {
		            if (!isUrl(q)) return reply("• Insira o link de acesso para a api!");
		            await fetchJson(q.trim()).then(data => {
		                reply(JSON.stringify(data, null, 2));
		            })
		            .catch((err) => {
		                console.error(err);
		                reply("Falha ao obter resultados...");
		            });
		        } catch (e) {
		            console.error(e);
		            reply("Falha ao obter resultados...");
		        }
		        break;



case 'bam':
if(!isGroup) return reply(`somente em grupos ne bb`)
yuta.sendMessage(from, {text: `*ᴄᴇʀᴛᴏ ᴀᴄᴀʙᴇɪ ᴅᴇ ʀᴇᴍᴏᴠᴇʀ ᴏ(ᴀ) @${menc_os2.split("@")[0]} ᴘᴏʀ ᴍᴏᴛɪᴠᴏs ᴊᴜsᴛᴏs 🙇‍♂️*`, mentions: [menc_os2]}, {quoted: selo})
break;


case 'lermais': case 'morechat': case 'spoiler':
var [text1_a, text2_b] = q.split("/"); // Separador
if (!text1_a) text1_a = ""; // Caso o texto1 esteja vazio, vai retornar vázio o parâmetro.
if (!text2_b) text2_b = ""; // Caso o texto2 esteja vazio, vai retornar vázio o parâmetro.
reply(text1_a + String.fromCharCode(8206).repeat(4001) + text2_b); // Enviar o spoiler.
break

case 'obesidade': case 'obeso':
if(!q.includes("/")) return reply(`Ex.: *${prefix+command} peso/altura*`)
var [peso, altura] = q.split("/");
var resultado = await obeso(peso, altura)
if (resultado <= 17 || resultado <= 18.4) {
await replyWithReaction(`• Seu índice de massa corporal é de: *${resultado}* -> Você está abaixo do peso.`, {react: {text: '😸', key: info.key}});
} else if (resultado <= 18.5 || resultado <= 24.9) {
await replyWithReaction(`• Seu índice de massa corporal é: *${resultado}* -> Você está no peso ideal.`, {react: {text: '👍', key: info.key}});
} else if (resultado <= 25 || resultado <= 29.9) {
await replyWithReaction(`• Seu índice de massa corporal é: *${resultado}* -> Você está com sobrepeso.`, {react: {text: '🫤', key: info.key}});
} else if (resultado <= 30 || resultado <= 39.9) {
await replyWithReaction(`• Seu índice de massa corporal é: *${resultado}* -> Em situção de Obesidade.`, {react: {text: '🤨', key: info.key}});
} else if (resultado > 40) {
await replyWithReaction(`• Seu índice de massa corporal é: *${resultado}* -> Obesidade mórbida!`, {react: {text: `😵`, key: info.key}});
}
break

case 'contardias': case 'countdays':
if(!q.includes("/")) return reply(`Você esqueceu da */* para separar os campos.. Exemplo: *31/03/2024*`)
if(q.length < 10) return reply(`Deve conter a data completa *(dia/mês/ano)* após o comando!\n• Exemplo: *${prefix+command} 31/03/2024*`)
try {
var tomp = await timeDate('DD/MM/YYYY')
countDay = await countDays(q.split("/"), tomp.split("/"))
reply(`*${countDay}* dia(s).`)
} catch(error) {
return reply(mess.error())
}
break


case 'idade':
  if (!q) return reply(`- Exemplo: ${prefix}idade 23/12/2007`)
  try {
    let txt; // Declare txt aqui
    const regexData = /^(\d{2})\/(\d{2})\/(\d{4})$/
    if (!regexData.test(q)) return reply(`- Exemplo: ${prefix}idade 23/12/2007`)
    const [dia, mes, ano] = q.split('/').map(Number)
    const dataNascimento = new Date(ano, mes - 1, dia)
    const hoje = new Date()
    if (dataNascimento > hoje || isNaN(dataNascimento)) {
      return reply(`*ᴄᴏʟᴏǫᴜᴇ ᴅᴀ ғᴏʀᴍᴀ ᴄᴇʀᴛᴀ ʙᴀɪᴛᴏʟᴀ 😡*`)
    }
    const diffMs = hoje - dataNascimento
    const idadeData = new Date(diffMs)
    const anos = idadeData.getUTCFullYear() - 1970
    const meses = idadeData.getUTCMonth()
    const dias = idadeData.getUTCDate() - 1
    const diasVividos = Math.floor(diffMs / (1000 * 60 * 60 * 24))
    const horasVividas = diasVividos * 24
    const minutosVividos = horasVividas * 60
    const proximoAniversario = new Date(hoje.getFullYear(), mes - 1, dia)
    if (proximoAniversario <= hoje) proximoAniversario.setFullYear(hoje.getFullYear() + 1)
    const diasParaAniversario = Math.ceil((proximoAniversario - hoje) / (1000 * 60 * 60 * 24))
    txt = `
    *🧮 ᴅᴀᴛᴀ ᴅᴇ ɴᴀsᴄɪᴍᴇɴᴛᴏ: ${q}*\n*🌟 ɪᴅᴀᴅᴇ: ${anos} ᴀɴᴏs, ${meses} ᴍᴇsᴇs ᴇ ${dias} ᴅɪᴀs*\n\n*📌 𝑬𝑺𝑻𝑨𝑻𝑰𝑺𝑻𝑰𝑪𝑨𝑺 𝑫𝑬 𝑽𝑰𝑫𝑨*\n\n*🩸 ${diasVividos} ᴅɪᴀs ᴠɪᴠɪᴅᴏs*\n*⏰ ${horasVividas} ʜᴏʀᴀs ᴠɪᴠɪᴅᴀs*\n*⏱ ${minutosVividos} ᴍɪɴᴜᴛᴏs ᴠɪᴠɪᴅᴏs*\n*📍ғᴀʟᴛᴀᴍ ${diasParaAniversario} ᴅɪᴀs ᴘᴀʀᴀ ᴏ ᴘʀᴏxɪᴍᴏ ᴀɴɪᴠᴇʀsᴀʀɪᴏ*\n\n> ${NomeDoBot}`.trim()
   yuta.sendMessage(from, {video: {url: 'https://files.catbox.moe/5iknjk.mp4'}, gifPlayback: true, caption: txt}, {quoted: selo})
  } catch (e) {
    console.log(e)
  }
  break


case 'qrcode': case 'gerarqr':
if (!q) return reply('Insira um link ou texto para que eu possa gerar o qr code..')
try {
await yuta.sendMessage(from, {image: {url: `https://api.qrserver.com/v1/create-qr-code/?size=500x500&data=${q}`}, caption: `💫| 𝐒𝐞𝐮 𝐪𝐫 𝐜𝐨𝐝𝐞 𝐟𝐨𝐢 𝐠𝐞𝐫𝐚𝐝𝐨 𝐜𝐨𝐧𝐭𝐞𝐧𝐝𝐨 𝐨 𝐭𝐞𝐱𝐭𝐨/𝐮𝐫𝐥 𝐞𝐬𝐩𝐞𝐜𝐢𝐟𝐢𝐜𝐚𝐝𝐨 𝐚𝐨 𝐥𝐚𝐝𝐨: *${q}*`}, {quoted: selo})
} catch (e) {
return reply(mess.error());
}
break

case 'gitclone':
let regex1 = /(?:https|git)(?::\/\/|@)github\.com[\/:]([^\/:]+)\/(.+)/i
if (!q) return reply(`Exemplo: ${prefix}gitclone https://github.com/whiskeysockets/baileys`);
reply(mess.wait())
let [user, repo] = args[0].match(regex1) || []
repo = repo.replace(/.git$/, '')
let filename = (await fetch(url, {method: 'HEAD'})).headers.get('content-disposition').match(/attachment; filename=(.*)/)[1]
await yuta.sendMessage(from, {document: {url: `https://api.github.com/repos/${user}/${repo}/zipball`}, fileName: filename+'.zip', mimetype: 'application/zip' }, {quoted: selo}).catch(async(error) => {
return reply(mess.error());
})
break

case 'perfil2': { //Criado por Lm
    try {
        
        /** Pega a menção */
        const mentionMessage = info.message?.extendedTextMessage?.contextInfo?.mentionedJid?.[0] || info.message?.extendedTextMessage?.contextInfo?.participant || null;
        
        if (mentionMessage) {
        
            await reply("*Gerando um personalidade aleatória dessa pessoa, aguarde um momento... 🤗*");
            
            /** Função para pegar palavras aleatoriamente */
            const randomFromArray = (array) => array[Math.floor(Math.random() * array.length)];
            
            /** Pega a imagem */
            const getProfileUrl = await yuta.profilePictureUrl(mentionMessage, 'image').catch(() => "https://telegra.ph/file/b5427ea4b8701bc47e751.jpg");
            
            /** Pode add mais... */
            const types = {
                genders: ["Gay 🏳️‍🌈", "Masculino 💪", "Feminino 🦋", "Trans 🏳️‍⚧️", "Lésbica 👩‍❤️‍👩"],
                hobbies: ["Cozinhar 🍜", "Ler livros 📚", "Estudar 🎒", "Praticar esportes ⛹️", "Correr 🏃", "Ouvir música 🎧", "Dançar 💃", "Cantar 🎤", "Viajar 🛫", "Jogar video-gamer 🎮"],
                professions: ["Médico", "Engenheiro", "Professor", "Artista", "Designer", "Programador", "Músico", "Escritor", "Puta"],
                favoriteTimesOfDay: ["Manhã 🌤", "Tarde 🌅", "Noite 🌌", "Madrugada 🌃"],
                favoriteMusicGenres: ["Rock", "Pop", "Jazz", "Sertanejo", "Funk", "Clássica", "Eletrônica"],
                favoriteTemperatura: ["Frio 🥶", "Quente 🥵", "Morno 🙂‍↕"]
            };
            
            /** Função para criar um resultado da personalidade */
            function getResults() {
                return {
                    genero: randomFromArray(types.genders),
                    hobbie: randomFromArray(types.hobbies),
                    job: randomFromArray(types.professions),
                    clima: randomFromArray(types.favoriteTimesOfDay),
                    estilo_musical: randomFromArray(types.favoriteMusicGenres),
                    temperatura: randomFromArray(types.favoriteTemperatura)
                }
            }
            
            /** Retonarndo resultado akkaka */
            const b = getResults();
            await yuta.sendMessage(from, {
                image: {
                    url: getProfileUrl,
                }, 
                caption: `   • 𝐑𝐄𝐒𝐔𝐋𝐓𝐀𝐃𝐎𝐒 𝐃𝐀 𝐏𝐄𝐑𝐒𝐎𝐍𝐀𝐋𝐈𝐃𝐀𝐃𝐄 𝐃𝐄  @${mentionMessage.split("@")[0]} ✨ ↴\n-\n ░⃟⃛ ➮𝐄𝐒𝐓𝐀 𝐏𝐄𝐒𝐒𝐎𝐀 𝐏𝐄𝐒𝐒𝐎𝐀𝐋𝐌𝐄𝐍𝐓𝐄 𝐄: *${b.genero}*\n ░⃟⃛ ➮𝐆𝐎𝐒𝐓𝐄 𝐃𝐄: *${b.hobbie}*\n ░⃟⃛ ➮𝐒𝐔𝐀 𝐏𝐑𝐎𝐅𝐈𝐒𝐒𝐀𝐎: *${b.job}*\n ░⃟⃛ ➮𝐀 𝐇𝐎𝐑𝐀 𝐅𝐀𝐕𝐎𝐑𝐈𝐓𝐀 𝐃𝐎 𝐃𝐈𝐀 𝐄:́ *${b.clima}*\n ░⃟⃛ ➮𝐒𝐄𝐔 𝐄𝐒𝐓𝐈𝐋𝐎 𝐃𝐄 𝐌𝐔𝐒𝐈𝐂𝐀 𝐄:́ *${b.estilo_musical}*\n ░⃟⃛ ➮𝐓𝐄𝐌𝐏𝐄𝐑𝐀𝐓𝐔𝐑𝐀 𝐅𝐀𝐕 𝐄:́ *${b.temperatura}*\n-\n\n  • 𝐄𝐒𝐏𝐄𝐑𝐎 𝐓𝐄𝐑 𝐀𝐂𝐄𝐑𝐓𝐀𝐃𝐎 𝐏𝐄𝐋𝐎 𝐌𝐄𝐍𝐎𝐒 𝐔𝐌𝐀 𝐇𝐄𝐈𝐍 @${mentionMessage.split("@")[0]} 👀`,
                mentions: [mentionMessage, sender]
            }, {
                quoted: selo
            });
        }
        else {
            reply("Mencione o '@' ou a mensagem de alguém...");
        }
    } catch (err) {
        console.error(err);
        reply("*Ops! Algo inesperado aconteceu. ❌*");
    }
    break;
}

case 'dinextenso': 
if(!q.includes(".")) return reply(`❌️ - Coloque apenas números para realizar a transformação de digitos numérico para números em extenso.\nPor exemplo: *${prefix}dinextenso 500.00 ou 756.50*, tudo que você colocar os valores deve colocar um ponto(.) para converter os valores.`)
try {
data = await fetchJson(`https://api.invertexto.com/v1/number-to-words?token=${API_KEY_INVERTEXTO}&number=${q}&language=pt&currency=BRL`);
reply(`*${q}* : ${capitalizeFirstLetter(data.text)}`);
} catch(error) {
reply(mess.error())
}
break

case 'validarcpf': case 'validarcnpj':
if(command === "validarcpf") {
if(!q) return reply("Digite um CPF para realizar a verificação se é válido ou inválido...")
if(q.length < 11) return reply("Você digitou um cpf que não tem 11 dígitos, verifique se colocou pontuação, se estiver retire.")
try {
data = await fetchJson(`https://api.invertexto.com/v1/validator?token=${API_KEY_INVERTEXTO}&value=${q}`)
if(data.valid == true) return reply("Válido.")
if(data.valid == false) return reply("Inválido.")
} catch(error) {reply(mess.error())}
} else if(command === "validarcnpj") {
if(!q) return reply("Digite um CNPJ para realizar a verificação se é válido ou inválido!")
if(q.length < 14) return reply("Você digitou um CNPJ que não tem 14 dígitos, verifique se colocou pontuação, se estiver retire.")
try {
data = await fetchJson(`https://api.invertexto.com/v1/validator?token=${API_KEY_INVERTEXTO}&value=${q}`)
if(data.valid == true) return reply("Válido.")
if(data.valid == false) return reply("Inválido.")
} catch(error) {reply(mess.error())}
}
break

case 'createimg': case 'texttoimage': case 'imagine':
if(!q) return reply(`O que você deseja criar amiguinho? Coloque após o comando o que você deseja criar... Por exemplo: ${prefix+command} macaco dirigindo uma bmw`);
try {
await replyWithReaction('Olá, estou criando a imagem a partir de seu questionamento, aguarde senhor(a)...', {react: {text: '🎨', key: info.key}});
dataResultAI = await fetchJson(`https://hercai.onrender.com/v3/text2image?prompt=${q}`);
  await yuta.sendMessage(from, {image: {url: dataResultAI.url}}, {quoted: selo});
} catch(error) {
await replyWithReaction(mess.error(), {react: {text: '❌', key: info.key}});
}
break

case 'emoji': case 'semoji':
try {
if (!q.trim()) return reply(`Você está usando o comando de forma errada, use: *${prefix+command} [emj]/[pltf]*\n—\n• *Plataformas disponíveis:* whatsapp, facebook, google, samsung, twitter, apple, microsoft, mesengger, joypixels, openmoji, emojidex, htc, lg, mozilla, softbank, au_kddi`)
if (!q.includes("/")) return reply(`Está faltando a */*, para separar o emoji e plataforma.\n• Por exemplo: ${prefix+command} 🏃‍♂️/apple`);
reply(mess.wait());
var [emojiInput, platform] = q.split("/");
var { emojisData } = await emoji(emojiInput);
if (emojisData && emojisData[platform.toLowerCase()]) {
await sendStickerFromUrl(from, emojisData[platform.toLowerCase()]);
} else {
return reply(`Emoji '${emojiInput}' não encontrado!`);
}
} catch(error) {
reply(mess.error())
}
break

case 'figfundo':
case 'figvideo':
case 'figusemfundo': 
case 'sfundo':  
if((isMedia && !info.message.videoMessage || isQuotedImage) && !q.length <= 1) {
rafa = isQuotedImage ? info.message.extendedTextMessage.contextInfo.quotedMessage.imageMessage : info.message.imageMessage
reply(mess.wait())
buff = await getFileBuffer(rafa, 'image')
bas64 = `data:image/jpeg;base64,${buff.toString('base64')}`
anu = args.join(' ').split('|')
satu = anu[0] !== '' ? anu[0] : `${NomeDoBot}`
sd = `↳  Feito pelo(a) usuário(a): ${pushname}`
dua = typeof anu[1] !== 'undefined' ? anu[1] : `${sd}`
var mantap = await convertSticker(bas64, `${dua}`, `${satu}`)
var sti = new Buffer.from(mantap, 'base64');
await yuta.sendMessage(from, {sticker: sti}, {quoted: selo})
} else {
return reply(`So imagem amigo(a)!`)
}
break

case 'rbale':  
if(!isQuotedSticker) return reply('Marque uma figurinha...')
encmediats = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker')
reply(mess.wait())
bas64 = `data:image/jpeg;base64,${encmediats.toString('base64')}`
var mantap = await convertSticker(bas64, `↳  Feito pelo(a) usuário(a): ${pushname}`, `${NomeDoBot}`)
var sti = new Buffer.from(mantap, 'base64');
await yuta.sendMessage(from, {sticker: sti}, {quoted: selo}).catch(async(error) => {
reply(mess.error()); 
})
break


case 'fstiker':
case 'fsticker':
case 'f':
var RSM = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var boij = RSM?.imageMessage || info.message?.imageMessage || RSM?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessage?.message?.imageMessage || RSM?.viewOnceMessage?.message?.imageMessage
var boij2 = RSM?.videoMessage || info.message?.videoMessage || RSM?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessage?.message?.videoMessage || RSM?.viewOnceMessage?.message?.videoMessage  
if(boij) {
var packnameStk = `${pushname}`
var authorSticker = `${NomeDoBot}`
reply(mess.wait())
owgi = await getFileBuffer(boij, 'image')
let ENC_MEDIA1 = await sendImageAsSticker(yuta, from, owgi, selo, {packname: packnameStk, author: authorSticker})
await DLT_FL(ENC_MEDIA1)
} else if(boij2 && boij2?.seconds < 11) {
var packnameStk = `${pushname}`
var authorSticker = `${NomeDoBot}`
reply(mess.wait())
owgi = await getFileBuffer(boij2, 'video')
let ENC_MEDIA2 = await sendVideoAsSticker(yuta, from, owgi, selo, {packname: packnameStk, author: authorSticker})
await DLT_FL(ENC_MEDIA2)
} else {
reply(`Envie uma imagem, vídeo ou gif com legenda: ${prefix}sticker (duração do adesivo de vídeo de 1 a 10 segundos)`)
}
break

case 'st':
case 'stk':
case 'sticker':
case 's':
var RSM = info.message?.extendedTextMessage?.contextInfo?.quotedMessage
var boij2 = RSM?.imageMessage || info.message?.imageMessage || RSM?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessageV2?.message?.imageMessage || info.message?.viewOnceMessage?.message?.imageMessage || RSM?.viewOnceMessage?.message?.imageMessage
var boij = RSM?.videoMessage || info.message?.videoMessage || RSM?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessageV2?.message?.videoMessage || info.message?.viewOnceMessage?.message?.videoMessage || RSM?.viewOnceMessage?.message?.videoMessage
if(boij2) {
var pack = `➪ ·֗٬̤⃟🌹ᴄʀɪᴀᴅᴀ ᴘᴏʀ\n❒᭄〭 ${NomeDoBot}\n\n➪ ·֗٬̤⃟🩸ɴɪᴄᴋ ᴅᴏɴᴏ\n❒᭄〭 ${ownerName}⁩`
var author2 = `➪ ·֗٬̤⃟🥀ғᴇɪᴛᴀ ᴘᴏʀ:\n❒᭄〭 ${pushname}\n\n➪ ·֗٬̤⃟ 🌆ɢʀᴜᴘᴏ:\n❒᭄〭 ${isGroup ? groupName : "privado"}`
owgi = await getFileBuffer(boij2, 'image')
let encmediaa = await sendImageAsSticker2(yuta, from, owgi, selo, { packname:pack, author:author2})
await DLT_FL(encmediaa)
} else if(boij && boij.seconds < 11){
var pack = `➪ ·֗٬̤⃟🌹ᴄʀɪᴀᴅᴀ ᴘᴏʀ\n❒᭄〭 ${NomeDoBot}\n\n➪ ·֗٬̤⃟🩸ɴɪᴄᴋ ᴅᴏɴᴏ\n❒᭄〭 ${ownerName}⁩`
var author2 = `➪ ·֗٬̤⃟🥀ғᴇɪᴛᴀ ᴘᴏʀ:\n❒᭄〭 ${pushname}\n\n➪ ·֗٬̤⃟ 🌆ɢʀᴜᴘᴏ:\n❒᭄〭 ${isGroup ? groupName : "privado"}`
owgi = await getFileBuffer(boij, 'video')
let encmedia = await sendVideoAsSticker2(yuta, from, owgi, selo, { packname:pack, author:author2})
await DLT_FL(encmedia)
} else {
reply(`*ᴍᴀʀǫᴜᴇ ᴜᴍᴀ ɪᴍᴀɢᴇᴍ ᴏᴜ ᴠɪᴅᴇᴏ ᴄᴏᴍ ᴏ ᴍɪɴɪᴍᴏ ᴅᴇ 9.9 ꜱᴇɢᴜɴᴅᴏꜱ 🙇‍♂️*`)
}
break

case 'toimg':
if(!isQuotedSticker) return reply('Por favor, *mencione um sticker* para executar o comando.')
try {
buff = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, 'sticker')
await yuta.sendMessage(from, {image: buff}, {quoted: selo}).catch(async(error) => {
reply(mess.error())
})
} catch(error) {
console.log(error)
}
break

case 'togif': 
if(!isQuotedSticker) return reply('Por favor, atribua uma figurinha animada à mensagem para realizar a conversão para vídeo/gif.');
try {
if((isMedia && !info.message.videoMessage || isQuotedSticker) && !q.length <= 1) {
const { FiguMp4OuGif } = require('./ARQUIVES/funcoes/togif.js');
getBufferWebP = await getFileBuffer(info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage, "sticker");
fs.writeFileSync("./DADOS DO YUTA/data/media/sticker/convert.webp", getBufferWebP);
outputFile = "./DADOS DO YUTA/data/media/sticker/convert.webp";
convertWebP = await FiguMp4OuGif(outputFile);
await yuta.sendMessage(from, {video: {url: convertWebP}, gifPlayback: true, fileName: 'sticker-sb.gif'}, {quoted: selo}).catch(async(error) => {
    await reply(mess.error()); // Notificar ao usuário que ocorreu um erro ao enviar o resultado da conversão do WebP para MP4.
    await DLT_FL(outputFile); // Apagar o arquivo, caso ocorrer um erro na conversão entre eles.
    console.log(error)
});
}
} catch(error) {
    await reply(mess.error()); // Notificar ao usuário que ocorreu um erro ao realizar a conversão do WebP para MP4.
    console.log(error)
};
break


case 'conselhobiblico': case 'conselhosbiblico': case 'conselhosb': case 'conselhob':
/* [Reagir a mensagem + enviar mensagem pré-definida] -> */ await replyWithReaction(advices.biblicalAdvice[Math.floor(Math.random() * advices.biblicalAdvice.length)], {react: {text: '😌', key: info.key}}).catch(async(error) => {
/* [Reagir a mensagem + enviar mensagem pré-definida] -> */ await replyWithReaction(mess.error(), {react: {text: '😿', key: info.key}});
});
break

case 'conselhos': case 'conselho':
/* [Reagir a mensagem + enviar mensagem pré-definida] -> */ await replyWithReaction(advices.commonAdvices[Math.floor(Math.random() * advices.commonAdvices.length)], {react: {text: '😌', key: info.key}}).catch(async(error) => {
/* [Reagir a mensagem + enviar mensagem pré-definida] -> */ await replyWithReaction(mess.error(), {react: {text: '😿', key: info.key}});
});
break
 
case 'cantadas': case 'cantada':
/* [Reagir a mensagem + enviar mensagem pré-definida] -> */ await replyWithReaction(tools.Cantadas[Math.floor(Math.random() * tools.Cantadas.length)], {react: {text: '😼', key: info.key}}).catch(async(error) => {
/* [Reagir a mensagem + enviar mensagem pré-definida] -> */ await replyWithReaction(mess.error(), {react: {text: '😿', key: info.key}});
});
break

case 'fatos': case 'curiosidades':
/* [Reagir a mensagem + enviar mensagem pré-definida] -> */ await replyWithReaction(tools.curiousFacts[Math.floor(Math.random() * tools.curiousFacts.length)], {react: {text: '🙀', key: info.key}}).catch(async(error) => {
/* [Reagir a mensagem + enviar mensagem pré-definida] -> */ await replyWithReaction(mess.error(), {react: {text: '😿', key: info.key}});
});
break


case 'mencionar':
if (!q) return reply(`Você usou o comando de forma incorreta, use a correta: ${prefix}mencionar corno`);
if (!isGroup) return reply(`Esta brincadeira só funciona em grupos.`);
if(!isModobn) return reply(mess.onlyGroupFun(prefix));
await mention(`Estou mencionando o *${q}* do grupo: *@${groupMembers[Math.floor(Math.random() * groupMetadata.participants.length)].id.split('@')[0]}*`);
break


case 'yuta':
await yuta.sendMessage(from, {audio: fs.readFileSync(`./DADOS DO YUTA/data/media/audios/yuta.mp3`), mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
  { quoted: selo });
break;


case 'convite':
if(!budy.includes("chat.whatsapp.com")) return reply("Cadê o link do grupo que você deseja que eu entre?")  
cnvt = args.join(" ")
reply(`O convite para o bot entrar em seu grupo, foi enviado, espere o dono aceitar..`)
await yuta.sendMessage(nmrdn, {text: mess.groupInvitation(sender, cnvt, prefix)}, {quoted: selo})
break

case 'recusar_convite':
if(!SoDono) return reply(mess.onlyOwner());
await yuta.sendMessage(`${q}@s.whatsapp.net`, {text: `Olá amigo(a), sinto muito dizer, mas seu convite foi recusado.`}, {quoted: selo});
break


case 'sip': case 'ip': 
if (!q) return reply(`Informe o ip que você deseja! *Exemplo:* ${prefix+command} 8.8.8.8`)
try {
ip = await axios.get(`https://ipwhois.app/json/${encodeURIComponent(q)}`);
await yuta.sendMessage(from, {image: {url: `https://maps.googleapis.com/maps/api/streetview?size=1400x1400&location=${ip.data.latitude},%20${ip.data.longitude}&sensor=false&key=AIzaSyB41DRUbKWJHPxaFjMAwdrzWzbVKartNGg`}, caption: mess.searchIpAdress(ip)}, {quoted: selo});
await yuta.sendMessage(from, {location: {degreesLatitude: ip.data.latitude,degreesLongitude: ip.data.longitude, addrees: ''}}, {quoted: selo});
} catch(error) {
reply(mess.error())
}
break

case 'mytag':  
inff = `${pushname}`
yuta.sendMessage(from, {text: inff}, {quoted: selo})
break

case 'getbio':
 if (!menc_os2) return reply('Marque o usuário que você quer puxar a bio/status, a mensagem ou o @');
 try {
 let bio = await yuta.fetchStatus(`${menc_os2.split('@')[0]}@c.us`);
 if (bio && bio.status) {
 reply(`${bio.status}`);
 } else {
 reply(`O usuário não possui biografia configurado.`);
 }
 } catch (error) {
 console.error(error);
 reply(`❌ Não foi possível pegar a biografia do usuário ❌`);
 }
 break;

case 'getperfil':
if(!menc_os2) return reply(`Marque o usuário que você quer puxar a foto de perfil, a mensagem ou o @`)
try { ppimg = await yuta.profilePictureUrl(`${menc_os2.split('@')[0]}@c.us`, 'image')
} catch { return mention(`❌ não foi possível pegar a foto de perfil do usuário ❌`) }
sendImage(from, ppimg, ``, selo)
break

case 'doc':
case 'docfake':
try {
sprd = "|"
if(!q) return reply(`${prefix + command} exemplo${sprd}500${sprd}apk\n-\nOs tipos aceitos por enquanto são: pdf > xml > zip > jpg > ppt > apk > txt > aac > pptx > aac > m4a > mp4 > mp3 > svg > png`)
kls = args.join(' ')
let nomedoc = kls.split(sprd)[0] || `${setting.NomeDoBot}`
let peso = kls.split(sprd)[1] * 1000000 || '1000000'
let mimetyp = kls.split(sprd)[2].replace(" ", "") || 'gif'
let thumbc = kls.split(sprd)[3] || 'https://google.com/'
if(mimetyp.toLowerCase() == 'pdf') mimetyp = 'application/pdf'
if(mimetyp.toLowerCase() == 'apk') mimetyp = 'application/vnd.Android 🚀.package-archive'
if(mimetyp.toLowerCase() == 'aac') mimetyp = 'audio/aac'
if(mimetyp.toLowerCase() == 'xml') mimetyp = 'application/xml'
if(mimetyp.toLowerCase() == 'zip') mimetyp = 'application/zip'
if(mimetyp.toLowerCase() == 'jpg') mimetyp = 'image/jpeg'
if(mimetyp.toLowerCase() == 'ppt') mimetyp = 'application/vnd.ms-powerpoint'
if(mimetyp.toLowerCase() == 'pptx') mimetyp = 'application/vnd.openxmlformats-officedocument.presentationml.presentation'
if(mimetyp.toLowerCase() == 'mp4') mimetyp = 'video/mp4'
if(mimetyp.toLowerCase() == 'm4a') mimetyp = 'audio/mpeg'
if(mimetyp.toLowerCase() == 'mp3') mimetyp = 'audio/mpeg'
if(mimetyp.toLowerCase() == 'gif') mimetyp = 'image/gif'
if(mimetyp.toLowerCase() == 'png') mimetyp = 'image/png'
if(mimetyp.toLowerCase() == 'svg') mimetyp = 'image/svg+xml'
if(mimetyp.toLowerCase() == 'txt') mimetyp = 'text/plain'
let Messagemdoc = {document: fs.readFileSync('./DADOS DO YUTA/data/docf.txt'), mimetype: mimetyp, jpegThumbnail: await getBuffer(thumbc), fileName: nomedoc, fileLength: peso, headerType: 4, contextInfo:{forwardingScore:999,isForwarded:true}}
await yuta.sendMessage(from, Messagemdoc, {quoted: selo})
} catch (err) {
console.log(err)
reply(mess.error())
}
break

//=============[ FIM RANDOM CMD ]=========\\

//===========[ HENTAI E PLAQS ]=============\\

case 'loli':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { loli } = require('./DADOS DO YUTA/nsfw/animes.js')
var totalnsfw = loli[Math.floor(Math.random() * loli.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'trap':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { trap } = require('./DADOS DO YUTA/nsfw/animes.js')
var totalnsfw = trap[Math.floor(Math.random() * trap.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'ass':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { ass } = require("./DADOS DO YUTA/nsfw/nsfw.js")
var totalnsfw = ass[Math.floor(Math.random()*ass.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'ahegao':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { ahegao } = require("./DADOS DO YUTA/nsfw/nsfw.js")
var totalnsfw = ahegao[Math.floor(Math.random()*ahegao.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'bdsm':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { bdsm } = require("./DADOS DO YUTA/nsfw/nsfw.js")
var totalnsfw = bdsm[Math.floor(Math.random()*bdsm.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'blowjob':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { blowjob } = require("./DADOS DO YUTA/nsfw/nsfw.js")
var totalnsfw = blowjob[Math.floor(Math.random()*blowjob.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'cuckold':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { cuckold } = require("./DADOS DO YUTA/nsfw/nsfw.js")
var totalnsfw = cuckold[Math.floor(Math.random()*cuckold.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'cum':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { cum } = require("./DADOS DO YUTA/nsfw/nsfw.js")
var totalnsfw = cum[Math.floor(Math.random()*cum.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'ero':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { ero } = require("./DADOS DO YUTA/nsfw/nsfw.js")
var totalnsfw = ero[Math.floor(Math.random()*ero.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'femdom':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { femdom } = require("./DADOS DO YUTA/nsfw/nsfw.js")
var totalnsfw = femdom[Math.floor(Math.random()*femdom.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'foot':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { foot } = require("./DADOS DO YUTA/nsfw/nsfw.js")
var totalnsfw = foot[Math.floor(Math.random()*foot.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'gangbang':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { gangbang } = require("./DADOS DO YUTA/nsfw/nsfw.js")
var totalnsfw = gangbang[Math.floor(Math.random()*gangbang.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'ganbganb':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { ganbganb } = require('./DADOS DO YUTA/nsfw/animes.js')
var totalnsfw = ganbganb[Math.floor(Math.random() * ganbganb.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'glasses':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { glasses } = require("./DADOS DO YUTA/nsfw/nsfw.js")
var totalnsfw = glasses[Math.floor(Math.random()*glasses.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'hentai':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { hentai } = require("./DADOS DO YUTA/nsfw/nsfw.js")
var totalnsfw = hentai[Math.floor(Math.random()*hentai.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'hentai2':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { hentai2 } = require('./DADOS DO YUTA/nsfw/animes.js')
var totalnsfw = hentai2[Math.floor(Math.random() * hentai2.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'nekos': {
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { neko2 } = require('./DADOS DO YUTA/nsfw/animes.js')
var totalnsfw = neko2[Math.floor(Math.random() * neko2.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
}
break

case 'neko2': {
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { neko2 } = require('./DADOS DO YUTA/nsfw/hentai.js')
var totalnsfw = neko2[Math.floor(Math.random() * neko2.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
}
break

case 'jahy':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { jahy } = require("./DADOS DO YUTA/nsfw/nsfw.js")
var totalnsfw = jahy[Math.floor(Math.random()*jahy.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'masturbation':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { masturbation } = require("./DADOS DO YUTA/nsfw/nsfw.js")
var totalnsfw = masturbation[Math.floor(Math.random()*masturbation.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'orgy':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { orgy } = require("./DADOS DO YUTA/nsfw/nsfw.js")
var totalnsfw = orgy[Math.floor(Math.random()*orgy.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'panties':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { panties } = require("./DADOS DO YUTA/nsfw/nsfw.js")
var totalnsfw = panties[Math.floor(Math.random()*panties.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'pussy':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { pussy } = require("./DADOS DO YUTA/nsfw/nsfw.js")
var totalnsfw = pussy[Math.floor(Math.random()*pussy.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'boobs':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { boobs } = require("./DADOS DO YUTA/nsfw/nsfw.js")
var totalnsfw = boobs[Math.floor(Math.random()*boobs.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'tentacles':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { tentacles } = require("./DADOS DO YUTA/nsfw/nsfw.js")
var totalnsfw = tentacles[Math.floor(Math.random()*tentacles.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'thighs':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { thighs } = require("./DADOS DO YUTA/nsfw/nsfw.js")
var totalnsfw = thighs[Math.floor(Math.random()*thighs.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'yuri':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { yuri } = require("./DADOS DO YUTA/nsfw/nsfw.js")
var totalnsfw = yuri[Math.floor(Math.random()*yuri.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'zettai':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { zettai } = require("./DADOS DO YUTA/nsfw/nsfw.js")
var totalnsfw = zettai[Math.floor(Math.random()*zettai.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

case 'kasedaiki':
if(isGroup)
setTimeout(() => {reagir(from, "😈")}, 300)
reply(`${isGroup ? "*Olha o pv...*" : "Enviando"} 😈`)
const { kasedaiki } = require("./DADOS DO YUTA/nsfw/nsfw.js")
var totalnsfw = kasedaiki[Math.floor(Math.random()*kasedaiki.length)]
yuta.sendMessage(sender, {image: {url: totalnsfw}, caption: `*Aqui está* ${pushname} 😳🔥`}, {quoted: selo})
break

// fim dos hentai 

case 'plaq': 
if(!isGroup)
if (args.length < 1) return reply('❕Ei humano, cadê o texto?')
if (q.length > 25) return reply('❗O texto é longo, o máximo é 25 caracteres.')
reagir(from, "🕒")
buffer = await getBuffer(`https://raptibef.sirv.com/images%20(3).jpeg?text.0.text=${q}&text.0.position.gravity=center&text.0.position.x=19%25&text.0.size=45&text.0.color=000000&text.0.opacity=55&text.0.font.family=Crimson%20Text&text.0.font.weight=300&text.0.font.style=italic&text.0.outline.opacity=21`)
sendMsg = yuta.sendMessage(sender, {image: buffer}, {quoted: selo}),
reply(`Eai, ${pushname}, preparado(a)? Enviando agora verifique seu pv... 😈🔥`)
break

case 'plaq1':
if(!isGroup)
if (args.length < 1) return reply('❕Ei humano, cadê o texto?')
if (q.length > 25) return reply('❗O texto é longo, o máximo é 25 caracteres.')
reagir(from, "🕒")
buffer = await getBuffer(`https://raptibef.sirv.com/images%20(1).jpeg?profile=Zanga%202.0&text.0.text=${q}`)
sendMsg = yuta.sendMessage(sender, {image: buffer}, {quoted: selo}),
reply(`Eai, ${pushname}, preparado(a)? Enviando agora verifique seu pv... 😈🔥`)
break

case 'plaq2':
if(!isGroup)
if (args.length < 1) return reply('❕Ei humano, cadê o texto?')
if (q.length > 25) return reply('❗O texto é longo, o máximo é 25 caracteres.')
reagir(from, "🕒")
buffer = await getBuffer(`https://raptibef.sirv.com/images.jpeg?profile=Zanga%203.0&text.0.text=${q}&text.0.outline.blur=63`)
sendMsg = yuta.sendMessage(sender, {image: buffer}, {quoted: selo}),
reply(`Eai, ${pushname}, preparado(a)? Enviando agora verifique seu pv... 😈🔥`)
break

case 'plaq3':
if(!isGroup)
if (args.length < 1) return reply('❕Ei humano, cadê o texto?')
if (q.length > 25) return reply('❗O texto é longo, o máximo é 25 caracteres.')
reagir(from, "🕒")
buffer = await getBuffer(`https://umethroo.sirv.com/Torcedora-da-sele%C3%A7%C3%A3o-brasileira-nua-mostrando-a-bunda-236x300.jpg?text.0.text=${q}&text.0.position.x=-64%25&text.0.position.y=-39%25&text.0.size=25&text.0.color=1b1a1a&text.0.font.family=Architects%20Daughter`) //api
plaq = ` *Plaquinha feita ✓* `
sendMsg = yuta.sendMessage(sender, {image: buffer}, {quoted: selo}),
reply(`Eai, ${pushname}, preparado(a)? Enviando agora verifique seu pv... 😈🔥`)
break

case 'plaq4':
if(!isGroup)
if (args.length < 1) return reply('❕Ei humano, cadê o texto?')
if (q.length > 25) return reply('❗O texto é longo, o máximo é 25 caracteres.')
reagir(from, "🕒")
buffer = await getBuffer(`https://umethroo.sirv.com/peito1.jpg?text.0.text=${q}&text.0.position.x=-4%25&text.0.position.y=-6%25&text.0.size=14&text.0.color=000000&text.0.font.family=Shadows%20Into%20Light&text.0.font.weight=700`)
sendMsg = yuta.sendMessage(sender, {image: buffer}, {quoted: selo}),
reply(`Eai, ${pushname}, preparado(a)? Enviando agora verifique seu pv... 😈🔥`)
break

case 'plaq5':
if(!isGroup)
if (args.length < 1) return reply('❕Ei humano, cadê o texto?')
if (q.length > 25) return reply('❗O texto é longo, o máximo é 25 caracteres.')
buffer = await getBuffer(`https://lerrewor.sirv.com/Teste/images%20(1)%20(6).jpeg?text.0.text=${q}&text.0.position.x=-17%25&text.0.position.y=-20%25&text.0.size=41&text.0.color=000000&text.0.opacity=59&text.0.font.family=PT%20Mono&text.0.outline.blur=10" width="463" height="662" alt="" />`,`https://lerrewor.sirv.com/Teste/images%20(1)%20(12).jpeg?text.0.text=${q}&text.0.position.x=-20%25&text.0.position.y=-35%25&text.0.size=41&text.0.color=000000&text.0.font.family=Playball&text.0.background.opacity=16&text.0.outline.color=ff0000&text.0.outline.blur=24" width="225" height="225" alt="" />`)
sendMsg = yuta.sendMessage(sender, {image: buffer}, {quoted: selo}),
reply(`Eai, ${pushname}, preparado(a)? Enviando agora verifique seu pv... 😈🔥`)
break

case 'plaq6':
if(!isGroup)
if (args.length < 1) return reply('❕Ei humano, cadê o texto?')
if (q.length > 25) return reply('❗O texto é longo, o máximo é 25 caracteres.')
buffer = await getBuffer(`https://lerrewor.sirv.com/Teste/images%20(1)%20(5).jpeg?text.0.text=${q}&text.0.position.x=-45%25&text.0.position.y=-29%25&text.0.size=36&text.0.color=000000&text.0.opacity=65&text.0.font.family=PT%20Sans%20Narrow" width="479" height="640" alt="" />`)
sendMsg = yuta.sendMessage(sender, {image: buffer}, {quoted: selo}),
reply(`Eai, ${pushname}, preparado(a)? Enviando agora verifique seu pv... 😈🔥`)
break

case 'plaq7':
if(!isGroup)
if (args.length < 1) return reply('❕Ei humano, cadê o texto?')
if (q.length > 25) return reply('❗O texto é longo, o máximo é 25 caracteres.')
buffer = await getBuffer(`https://lerrewor.sirv.com/Teste/images%20(1)%20(10).jpeg?text.0.text=${q}&text.0.position.y=-25%25&text.0.size=41&text.0.color=000000&text.0.font.family=Vollkorn&text.0.background.opacity=100" width="193" height="261" alt="" />`)
sendMsg = yuta.sendMessage(sender, {image: buffer}, {quoted: selo}),
reply(`Eai, ${pushname}, preparado(a)? Enviando agora verifique seu pv... 😈🔥`)
break

case 'plaq8':
if(!isGroup)
if (args.length < 1) return reply('❕Ei humano, cadê o texto?')
if (q.length > 25) return reply('❗O texto é longo, o máximo é 25 caracteres.')
buffer = await getBuffer(`https://lerrewor.sirv.com/Teste/images%20(1)%20(9).jpeg?text.0.text=${q}&text.0.position.x=-49%25&text.0.position.y=-19%25&text.0.size=45&text.0.color=000000&text.0.opacity=97&text.0.font.family=Patrick%20Hand" width="250" height="333" alt="" />`)
sendMsg = yuta.sendMessage(sender, {image: buffer}, {quoted: selo}),
reply(`Eai, ${pushname}, preparado(a)? Enviando agora verifique seu pv... 😈🔥`)
break

case 'plaq9': 
if(!isGroup)
if (args.length < 1) return reply('❕Ei humano, cadê o texto?')
if (q.length > 25) return reply('❗O texto é longo, o máximo é 25 caracteres.')
buffer = await getBuffer(`https://lerrewor.sirv.com/Teste/images%20(1)%20(8).jpeg?text.0.text=${q}&text.0.position.x=-28%25&text.0.position.y=-41%25&text.0.size=41&text.0.color=000000&text.0.opacity=99&text.0.font.family=Signika" width="225" height="225" alt="" />`)
sendMsg = yuta.sendMessage(sender, {image: buffer}, {quoted: selo}),
reply(`Eai, ${pushname}, preparado(a)? Enviando agora verifique seu pv... 😈🔥`)
break

//==============[ FIM PLAQS E HENTAI ]============\\


//==========[ DOWNLOADS DO YUTA ]==============\\
case 'gerarnick': case 'fazernick': case 'nick':
try {
if(!q.trim()) return reply(`- Exemplo: ${prefix+command} ${NomeDoBot}`);
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/gerar_nick?nick=${encodeURI(q)}&apikey=${API_KEY_BRONXYS}`)
AB = `Lista com base no Nick informado, para encontrar melhor fonte para utilizar:\n\n`;
for ( i of ABC) {
AB += `${i}\n\n`;
}
reply(AB);
} catch (e) {
return reply("Erro..");
}
break

case 'attp': case 'attp2':
try {
if(!q.trim()) return reply(`Exemplo: ${prefix+command} Yuta`);
reply("*ᴀɢᴜᴀʀᴅᴇ ᴜᴍ ᴍᴏᴍᴇɴᴛᴏ......🙇‍♂️*")
var Fontes = command === "attp2" ? "Roboto" : "Noto Emoji, Noto Sans Mono"
yuta.sendMessage(from, {sticker: {url: `https://api.bronxyshost.com.br/api-bronxys/attp_edit?texto=${encodeURIComponent(q)}&fonte=${Fontes}&apikey=${API_KEY_BRONXYS}`}}, {quoted: selo}).catch(() => {
return reply(mess.error());
})
} catch (e) {
return reply(mess.error());
}
break;

case 'play-api': 
case 'p':
if(!q) return reply(mess.syntaxDownloadMusic());
try {
reply(mess.teste());
await yuta.sendMessage(from,{audio: {url: `https://carisys.online/api/downloads/youtube/play_audio?query=${encodeURIComponent(q)}` },mimetype: "audio/mpeg",      
contextInfo: {
forwardingScore: 1,
isForwarded: true,
forwardedNewsletterMessageInfo: {
newsletterJid: `${setting.channelnk}`, 
newsletterName: `${NomeDoBot}` 
        }
      }
    }, { quoted: selo });        
} catch (erro) {
console.log(erro)
return reply(mess.error())
}//Carisys && NexFuture
break

case 'playapi':
try {
if(!q) return reply(mess.syntaxDownloadMusic());
reply(mess.teste());
let play2 = await fetchJson(`https://carisys.online/api/pesquisas/youtube?query=${encodeURIComponent(q)}`);
await yuta.sendMessage(from,
{audio: {url:`https://carisys.online/api/downloads/youtube/mp3-2?url=${play2.resultado.url}`},
fileName: play2.resultado.titulo + '.mpeg',
mimetype: "audio/mpeg", 
contextInfo: { externalAdReply: {
title: play2.resultado.titulo,
body: `⌗ ᴄᴀʀɪsʏs  ᴀ  ᴍᴇʟʜᴏʀ ⌗`,
mediaType: 1, reviewType: "PHOTO",
thumbnailUrl: play2.resultado.imagem,
showAdAttribution: true,
renderLargerThumbnail: true,
},
},
}, {quoted: sasah});
} catch (error) {
console.log(error) 
return reply(mess.error())
}
break;

/*
case 'playstoredl':
if(!q) return reply(`Deposite um link de um aplicativo da PlayStore, você pode obter usando o comando 'playstore' ou copiando-o manualmente diretamente do aplicativo ou site oficial do Google Play.`);
if(q.includes('play.google.com')) return reply('Não é um link da PlayStore.');
try {
  dataResult = await fetchJson(`https://rest-api.akuari.my.id/downloader/apkdownloader2?package=${q}`);
     await yuta.sendMessage(from, {document: {url: dataResult.respon.downloadapk},
      caption: `• Nome: *${dataResult.respon.title}*\n• Quantidade de instalações: *${dataResult.respon.install}*\n• Classificação: *${dataResult.respon.score}°*\n• Avaliação:  (${dataResult.respon.reviews})`,
      mimetype: "application/vnd.Android 🚀.package-archive",
      fileName: `${dataResult.respon.title}.apk`
     }, {
      quoted: selo
     });
} catch(e) {
  return reply(mess.error());
}
break
*/

case 'metadinha2':
                case 'metadinha3':
                    // if (!isGroup) return reply(resposta.grupo)
                    anuu = await fetchJson('https://raw.githubusercontent.com/iamriz7/kopel_/main/kopel.json')

                    random = anuu[Math.floor(Math.random() * anuu.length)]
                    let buttonssMessssage = {
                        image: { url: random.male },
                        caption: `MASCULINA`,
                        footer: `${NomeDoBot}`,
                        headerType: 4
                    }
                    await yuta.sendMessage(from, buttonssMessssage, { quoted: selo }).catch(err => {
                        return ('Error!')
                    })
                    let buttonssMesssage = {
                        image: { url: random.female },
                        caption: `FEMININA`,
                        footer: `${NomeDoBot}`,
                        headerType: 4
                    }
                    await yuta.sendMessage(from, buttonssMesssage, { quoted: selo }).catch(err => {
                        return ('Error!')
                    })
                    break



case 'cria': 
if (args.length < 1) return reply("Cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`*ɢᴇʀᴀɴᴅᴏ ᴀ sᴜᴀ ʟᴏɢᴏ, ᴀɢᴜᴀʀᴅᴇ 🙇‍♂️*`)
Nkzin = await getBuffer(`https://lollityp.sirv.com/venom_api.jpg?text.0.text=${teks}&text.0.color=000000&text.0.font.family=Pacifico&text.0.font.weight=600&text.0.background.color=ffffff&text.0.outline.color=ffffff&text.0.outline.width=10&text.0.outline.blur=17`)
yuta.sendMessage(from, { image: Nkzin }, { quoted: selo })
break

case 'anime1':
if (args.length < 1) return reply("Cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`*ɢᴇʀᴀɴᴅᴏ ᴀ sᴜᴀ ʟᴏɢᴏ, ᴀɢᴜᴀʀᴅᴇ 🙇‍♂️*`)
Nkzin = await getBuffer(`https://lollityp.sirv.com/venom_apis2.jpg?text.0.text=${teks}&text.0.position.gravity=center&text.0.position.x=1%25&text.0.position.y=16%25&text.0.size=80&text.0.color=ff2772&text.0.opacity=67&text.0.font.family=Bangers&text.0.font.style=italic&text.0.background.opacity=50&text.0.outline.width=6`)
yuta.sendMessage(from, { image: Nkzin }, { quoted: selo })
break

case 'ff1':
if (args.length < 1) return reply("Cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`*ɢᴇʀᴀɴᴅᴏ ᴀ sᴜᴀ ʟᴏɢᴏ, ᴀɢᴜᴀʀᴅᴇ 🙇‍♂️*`)
Nkzin = await getBuffer(`https://lollityp.sirv.com/venom_apis3.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=59%25&text.0.size=89&text.0.color=000000&text.0.opacity=71&text.0.font.family=Changa%20One&text.0.font.style=italic&text.0.background.opacity=10&text.0.outline.color=ffffff&text.0.outline.width=3`)
yuta.sendMessage(from, { image: Nkzin }, {quoted: selo })
break	

case 'game':
if (args.length < 1) return reply("Cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`*ɢᴇʀᴀɴᴅᴏ ᴀ sᴜᴀ ʟᴏɢᴏ, ᴀɢᴜᴀʀᴅᴇ 🙇‍♂️*`)
Nkzin = await getBuffer(`https://lollityp.sirv.com/venom_apis5.jpg?text.0.text=${teks}&text.0.position.gravity=center&text.0.position.x=1%25&text.0.position.y=22%25&text.0.align=left&text.0.size=59&text.0.font.family=Permanent%20Marker&text.0.outline.color=df00ff&text.0.outline.width=2&text.0.outline.blur=18`)
yuta.sendMessage(from, { image: Nkzin }, { quoted: selo })
break

case 'ff2':
if (args.length < 1) return reply("Cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`*ɢᴇʀᴀɴᴅᴏ ᴀ sᴜᴀ ʟᴏɢᴏ, ᴀɢᴜᴀʀᴅᴇ 🙇‍♂️*`)
Nkzin = await getBuffer(`https://lollityp.sirv.com/venom_apis6.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.x=1%25&text.0.position.y=50%25&text.0.size=68&text.0.color=464646&text.0.opacity=51&text.0.font.family=Sigmar%20One&text.0.background.opacity=2&text.0.outline.color=ffffff&text.0.outline.width=2&text.0.outline.opacity=61`)
yuta.sendMessage(from, { image: Nkzin }, { quoted: selo })
break	

case 'anime2':
if (args.length < 1) return reply("Cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`*ɢᴇʀᴀɴᴅᴏ ᴀ sᴜᴀ ʟᴏɢᴏ, ᴀɢᴜᴀʀᴅᴇ 🙇‍♂️*`)
Nkzin = await getBuffer(`https://lollityp.sirv.com/venom_apis7.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.x=1%25&text.0.position.y=58%25&text.0.size=69&text.0.color=00ffea&text.0.opacity=37&text.0.font.family=Bangers&text.0.background.opacity=77&text.0.outline.color=ffffff&text.0.outline.width=2&text.0.outline.blur=20`)
yuta.sendMessage(from, { image: Nkzin }, { quoted: selo })
break

case 'entardecer':
if (args.length < 1) return reply("Cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`*ɢᴇʀᴀɴᴅᴏ ᴀ sᴜᴀ ʟᴏɢᴏ, ᴀɢᴜᴀʀᴅᴇ 🙇‍♂️*`)
Nkzin = await getBuffer(`https://lollityp.sirv.com/venom_apis9.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=50%25&text.0.size=68&text.0.color=ffffff&text.0.opacity=61&text.0.font.family=Tangerine&text.0.font.style=italic&text.0.background.opacity=61&text.0.outline.color=ff6f00&text.0.outline.width=9`)
yuta.sendMessage(from, { image: Nkzin }, { quoted: selo })
break

case 'indian':
if (args.length < 1) return reply("Cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`*ɢᴇʀᴀɴᴅᴏ ᴀ sᴜᴀ ʟᴏɢᴏ, ᴀɢᴜᴀʀᴅᴇ 🙇‍♂️*`)
Nkzin = await getBuffer(`https://lollityp.sirv.com/venom_apis10.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=62%25&text.0.size=63&text.0.color=004124&text.0.opacity=99&text.0.font.family=Permanent%20Marker&text.0.font.style=italic&text.0.background.color=feff00&text.0.outline.color=ffe8a3&text.0.outline.width=9&text.0.outline.blur=21`)
yuta.sendMessage(from, { image: Nkzin }, { quoted: selo })
break 

case 'ffrose':
if (args.length < 1) return reply("Cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`*ɢᴇʀᴀɴᴅᴏ ᴀ sᴜᴀ ʟᴏɢᴏ, ᴀɢᴜᴀʀᴅᴇ 🙇‍♂️*`)
Nkzin = await getBuffer(`https://lollityp.sirv.com/venom_apis12.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=65%25&text.0.size=61&text.0.color=ff00e6&text.0.opacity=32&text.0.font.family=Chewy&text.0.font.style=italic&text.0.outline.width=6`)
yuta.sendMessage(from, { image: Nkzin }, { quoted: selo })
break	

case 'ffgren':
if (args.length < 1) return reply("Cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`*ɢᴇʀᴀɴᴅᴏ ᴀ sᴜᴀ ʟᴏɢᴏ, ᴀɢᴜᴀʀᴅᴇ 🙇‍♂️*`)
Nkzin = await getBuffer(`https://lollityp.sirv.com/venom_apis13.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=63%25&text.0.size=68&text.0.color=ffffff&text.0.opacity=92&text.0.font.family=Permanent%20Marker&text.0.font.weight=800&text.0.outline.color=5dff00&text.0.outline.width=13&text.0.outline.blur=21`)
yuta.sendMessage(from, { image: Nkzin }, { quoted: selo })
break		

case 'chufuyu':
if (args.length < 1) return reply("Cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`*ɢᴇʀᴀɴᴅᴏ ᴀ sᴜᴀ ʟᴏɢᴏ, ᴀɢᴜᴀʀᴅᴇ 🙇‍♂️*`)
Nkzin = await getBuffer(`https://lollityp.sirv.com/venom_apis14.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=68%25&text.0.size=60&text.0.color=ffffff&text.0.font.family=Sigmar%20One&text.0.font.style=italic&text.0.background.opacity=17&text.0.outline.color=a99cff&text.0.outline.width=9&text.0.outline.blur=16`)
yuta.sendMessage(from, { image: Nkzin }, { quoted: selo })
break	

case 'wolf':
if (args.length < 1) return reply("cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`*ɢᴇʀᴀɴᴅᴏ ᴀ sᴜᴀ ʟᴏɢᴏ, ᴀɢᴜᴀʀᴅᴇ 🙇‍♂️*`)
Nkzin = await getBuffer(`https://lollityp.sirv.com/venom_apis15.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=62%25&text.0.size=63&text.0.color=000000&text.0.font.family=Audiowide&text.0.font.style=italic&text.0.background.opacity=15&text.0.outline.color=ffffff&text.0.outline.width=9&text.0.outline.blur=33`)
yuta.sendMessage(from, { image: Nkzin }, { quoted: selo })
break	

case 'dragonred':
if (args.length < 1) return reply("Cade o texto ?")
teks = q
if (teks.length > 15) return reply('O texto é longo, até 15 caracteres')
reply(`*ɢᴇʀᴀɴᴅᴏ ᴀ sᴜᴀ ʟᴏɢᴏ, ᴀɢᴜᴀʀᴅᴇ 🙇‍♂️*`)
Nkzin = await getBuffer(`https://lollityp.sirv.com/venom_apis16.jpg?text.0.text=${teks}&text.0.position.gravity=north&text.0.position.y=58%25&text.0.size=99&text.0.color=fffefe&text.0.font.family=Permanent%20Marker&text.0.background.color=000000&text.0.outline.color=000000&text.0.outline.width=19&text.0.outline.blur=66`)
yuta.sendMessage(from, { image: Nkzin }, { quoted: selo })
break



//Definir no topor, esser caralh
//const { genyt } = require('genytdl-core');

case 'ytmp3': {//Nk domima mas o Lm naooooo domina nada
    try {
        if (!q.includes('youtu')) return reply('Cadê o link?');
        reply(mess.teste());
        
        const { video } = await genyt(q);
       let audio = await video.download();
        const {
            getBufferURL
        } = require('./INFO_YUTA/DADOS/youtube.js');
        audio = await getBufferURL(audio);
        
        yuta.sendMessage(from, {
            audio,
            mimetype: "audio/mpeg"
        }, {
            quoted: selo
        });
    } catch (e) {
        console.error(e);
        reply(mess.error())
    }
    break;
}

case 'ytmp4': {//Nk domima mas o Lm naooooo domina nada
    try {
        if (!q.includes('youtu')) return reply('Cadê o link?');
        reply(mess.teste());
        
        let { video } = await genyt(q);
        video = await video.download();
        const {
            getBufferURL
        } = require('./INFO_YUTA/DADOS/youtube.js');
        video = await getBufferURL(video);
        
        yuta.sendMessage(from, {
            video
        }, {
            quoted: selo
        });
    } catch (e) {
        console.error(e);
        reply(mess.error())
    }
    break;
}
    case 'play_link': {
    try {
        if (!q.includes('https')) return reply('• É necessário um link para o download!');
        const {
            audiodl
        } = require('./INFO_YUTA/DADOS/yt-dl.js');

        audiodl(q)
            .then(async (link) => {
                if (!link) return reply('Falha ao baixar o áudio');
                yuta.sendMessage(from, {
                    audio: {
                        url: link
                    },
                    mimetype: "audio/mpeg"
                }, {
                    quoted: selo
                });
            })
            .catch((err) => {
                console.error(err);
                reply('Erro ao executar o comando!');
            });
    } catch (e) {
        console.error(e);
        reply('Erro ao executar o comando!');
    }
    break;
}

case 'video_link': {
    try {
        if (!q.includes('https')) return reply('• É necessário um link para o download!');
        const {
            videodl
        } = require('./INFO_YUTA/DADOS/yt-dl.js');

        videodl(q)
            .then(async (link) => {
                if (!link) return reply('Falha ao baixar o vvídeo');
                yuta.sendMessage(from, {
                    video: {
                        url: link
                    }
                }, {
                    quoted: selo
                });
            })
            .catch((err) => {
                console.error(err);
                reply('Erro ao executar o comando!');
            });
    } catch (e) {
        console.error(e);
        reply('Erro ao executar o comando!');
    }
    break;
}


case 'tiktok2': 
case 'tiktok_video2':
case 'tiktok': 
case 'tiktok_video':
await reagir(from, "⏳")
try {
if(!q) return reply(`${prefix+command} link do Tiktok`);

yuta.sendMessage(from, {
    video: (await scget(`https://api.bronxyshost.com.br/api-bronxys/tiktok?url=${q}&apikey=${API_KEY_BRONXYS}`)).arrayBuffer(), 
    mimetype: "video/mp4"
}, {quoted: selo}).catch(e => {
console.log(e)
return reply(mess.error())
})

} catch (e) {
console.log(e)
return reply(mess.error())
}
break;

case 'tiktok_audio2':
case 'tiktok_audio':
await reagir(from, "⏳")
try {
if(!q) return reply(`${prefix+command} link do Tiktok`);
yuta.sendMessage(from, {audio: {url:`https://api.bronxyshost.com.br/api-bronxys/tiktok?url=${q}&apikey=${API_KEY_BRONXYS}`}, mimetype: "audio/mpeg"}, {quoted: selo}).catch(e => {
console.log(e)
return reply(mess.error())
})
} catch (e) {
console.log(e)
return reply(mess.error())
}
break;

case 'instagram2':
case 'insta_video2':
case 'instagram':
await reagir(from, "⏳")
try {
if(q.length < 5) return reply(`Exemplo: ${prefix+command} o link`);
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/instagram?url=${q.trim()}&apikey=${API_KEY_BRONXYS}`)
let DM_T = ABC.msg[0].type
var A_T = DM_T === "mp4" ? "video/mp4" : DM_T === "webp" ? "image/webp" : DM_T === "jpg" ? "image/jpeg" : DM_T === "mp3" ? "audio/mpeg" : "video/mp4"
yuta.sendMessage(from, {[A_T.split("/")[0]]: {url: ABC.msg[0].url}, mimetype: A_T}, {quoted: selo}).catch(e => {
return reply(mess.error())
})
} catch (e) {
return reply(mess.error())
}
break;

case 'insta_audio2':
case 'insta_audio':
await reagir(from, "⏳")
try {
if(!q.trim()) return reply(`Exemplo: ${prefix+command} o link`);
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/instagram?url=${q.trim()}&apikey=${API_KEY_BRONXYS}`)
let DM_T = ABC.msg[0].type
var A_T = DM_T === "webp" ? "image/webp" : DM_T === "jpg" ? "image/jpeg" : DM_T === "mp3" ? "audio/mpeg" : "audio/mpeg"
yuta.sendMessage(from, {[A_T.split("/")[0]]: {url: ABC.msg[0].url}, mimetype: A_T}, {quoted: selo}).catch(e => {
return reply(mess.error())
})
} catch (e) {
return reply(mess.error())
}
break;
  
case 'play': {
    try {
        if (args.length < 1) return reply(mess.syntaxDownloadMusic());
        reply(mess.teste());

        const { videoId, title, timestamp, name, thumbnail, url } = 
            (await yts(args.join(" "))).all
                .filter(result => result.videoId)
                .find(result => result.videoId) || {};

        await yuta.sendMessage(from, {
            audio: {
                url: `https://api.bronxyshost.com.br/api-bronxys/play?nome_url=${args.join(" ")}&apikey=${API_KEY_BRONXYS}`
            },
            mimetype: 'audio/aac',
            fileName: `${title}.mp3`,
            contextInfo: {
                externalAdReply: {
                    title: title,
                    renderLargerThumbnail: false,
                    showAdAttribution: true,
                    body: `⌛ Duração: ${timestamp}`,
                    mediaUrl: url,
                    mediaType: 2,
                    thumbnailUrl: thumbnail
                }
            }
        }, { quoted: selo });

    } catch (error) {
        console.error("Error:", error);
        reply(mess.error());
    }
}
break;


case 'play3': {
if(!q) return reply(mess.syntaxDownloadMusic());
reply(mess.teste());
try {
data = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/pesquisa_ytb?nome=${q}&apikey=${API_KEY_BRONXYS}`)
yuta.sendMessage(from, {audio: {url: `https://api.bronxyshost.com.br/api-bronxys/play?nome_url=${q}&apikey=${API_KEY_BRONXYS}`}, mimetype: "audio/mpeg",      
contextInfo: {
forwardingScore: 1,
isForwarded: true,
forwardedNewsletterMessageInfo: {
newsletterJid: `${setting.channelnk}`, 
newsletterName: `${NomeDoBot}` 
},
        externalAdReply: {
title: `${data[0]?.titulo||N_E}`,
body: `${NomeDoBot}`,
mediaType: 1, reviewType: "PHOTO",
thumbnailUrl: data[0]?.thumb || logoslink?.logo,
showAdAttribution: true,
renderLargerThumbnail: true,
        }
      }
    }, { quoted: selo });        
} catch (e) {
    yuta.sendMessage(from, { react: { text: `❌`, key: info.key } });
console.log(e)
return reply(mess.error())
}
break;
}


case 'fakemsg':
case 'fakechat':  //Criado por Nk 
    if ([prefix, "&", "/", "#", "+"].includes(q.trim())) {
        return reply(`_Infelizmente não pode ser colocado comandos no fake chat._`);
    }

    const [repplace, tarrget, bott] = q.split("|");

    const m_ = info.message.extendedTextMessage && info.message.extendedTextMessage.contextInfo && info.message.extendedTextMessage.contextInfo.mentionedJid ? info.message.extendedTextMessage.contextInfo.mentionedJid[0] : null;

    if (!m_ || !tarrget || !bott) {
        return reply(`- Exemplo:\n\n ${prefix}fakechat _@user|mensagem do usuário|Sua mensagem_`);
    }

    yuta.sendMessage(from, {
        text: bott
    }, {
        quoted: {
            key: {
                fromMe: false,
                participant: m_
            },
            message: {
                conversation: tarrget
            }
        }
    });
    break; //By Nk
    
case 'play4':
if(!q) return reply(mess.syntaxDownloadMusic());
try {
const api = await fetchJson(`https://daki-apis.tech/api/pesquisa/ytsrc?nome=${q}&apikey=Thndomina`);
    yuta.sendMessage(from, { react: { text: `✅`, key: info.key } });
if (!api || api.length === 0) {
return reply('🤷‍♂️');
}
await yuta.sendMessage(
        from, 
        {
            text: `*⏤͟͟͞͞🎥 sᴇ ᴅᴇsᴇᴊᴀ ʙᴀɪxᴀʀ ᴠɪᴅᴇᴏ ᴜsᴇ ${prefix}ᴘʟᴀʏᴠɪᴅᴇᴏ ${q.trim()}*

> ${NomeDoBot}`,
           contextInfo: {
      forwardingScore: 1,
isForwarded: true,
forwardedNewsletterMessageInfo: {
newsletterJid: `${setting.channelnk}`, 
newsletterName: `${NomeDoBot}` 
},
        externalAdReply: {
         title: `${api[0].title || '🤷‍♂️'}`, 
         body: `⏳ : ${api[0].seconds || '🤷‍♂️'}`, 
          thumbnail: await getBuffer(api[0].image || fotomenu),
                      mediaType: 1, 
                        sourceUrl: channel
        }
      }
    }, { quoted: selo });        
const api2 = await fetch(`https://daki-apis.tech/api/dl/ytmp3?link=${api[0].url}&apikey=Thndomina`);
if (!api2.ok) {
return reply('Falha ao baixar o áudio!');
}

const audioBuffer = await api2.buffer();
await yuta.sendMessage(from, { audio: audioBuffer, fileName: 'audio.mp3', mimetype: "audio/mpeg", contextInfo: {
forwardingScore: 1,
isForwarded: true,
forwardedNewsletterMessageInfo: {
newsletterJid: `${setting.channelnk}`, 
newsletterName: `${NomeDoBot}` 
},
        externalAdReply: {
         title: `${api[0].title || 'não encontrado'}`, 
         body: `⏳ : ${api[0].seconds || 'não encontrado'}`, 
          thumbnail: await getBuffer(api[0].image || fotomenu),
          mediaType: 1, 
          showAdAttribution: true, 
          renderLargerThumbnail: true,
          sourceUrl: channel 
        }
      }
    }, { quoted: selo });        
} catch (erro) {
    yuta.sendMessage(from, { react: { text: `❌`, key: info.key } });
console.log(e)
return reply(mess.error())
}
break



case 'playaudio': {
try {
if(!q) return reply(mess.syntaxDownloadMusic());

data = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/pesquisa_ytb?nome=${q}&apikey=${API_KEY_BRONXYS}`)
    yuta.sendMessage(from, { react: { text: `✅`, key: info.key } });
if(data[0]?.tempo?.length >= 7) return reply("Desculpe, este video ou audio é muito grande, não poderei realizar este pedido, peça outra música abaixo de uma hora.")
var N_E = "🤷‍♂️"
    await yuta.sendMessage(
        from, 
        {
            text: `*⏤͟͟͞͞🎥 sᴇ ᴅᴇsᴇᴊᴀ ʙᴀɪxᴀʀ ᴠɪᴅᴇᴏ ᴜsᴇ ${prefix}ᴘʟᴀʏᴠɪᴅᴇᴏ ${q.trim()}*

> ${NomeDoBot}`,
           contextInfo: {
      forwardingScore: 1,
isForwarded: true,
forwardedNewsletterMessageInfo: {
newsletterJid: `${setting.channelnk}`, 
newsletterName: `${NomeDoBot}` 
},
                    externalAdReply: { 
                        title: `${data[0]?.titulo||N_E}`, 
                        body: `⏳ : ${data[0]?.tempo||N_E}`, 
                        thumbnail: await getBuffer(data[0]?.thumb || logoslink?.logo), 
                        mediaType: 1, 
                        sourceUrl: channel
                    }
            }
        }, 
        { quoted: selo }
    );
yuta.sendMessage(from, {audio: {url: `https://api.bronxyshost.com.br/api-bronxys/play?nome_url=${q}&apikey=${API_KEY_BRONXYS}`}, mimetype: "audio/mpeg",
contextInfo: {
forwardingScore: 1,
isForwarded: true,
forwardedNewsletterMessageInfo: {
newsletterJid: `${setting.channelnk}`, 
newsletterName: `${NomeDoBot}` 
},
        externalAdReply: {
         title: `${data[0]?.titulo||N_E}`, 
         body: `⏳ : ${data[0]?.tempo||N_E}`, 
          thumbnail: await getBuffer(data[0]?.thumb || logoslink?.logo),
          mediaType: 1, 
          showAdAttribution: true, 
          renderLargerThumbnail: true,
          sourceUrl: channel 
        }
      }
    }, { quoted: selo });        
} catch (e) {
    yuta.sendMessage(from, { react: { text: `❌`, key: info.key } });
console.log(e)
return reply(mess.error())
}
break;
}



case 'playvid':
case 'playvideo': 
case 'playmp4':  
case "play_video": {
try {
if(!q.trim()) return reply(mess.syntaxDownloadMusic());
data = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/pesquisa_ytb?nome=${q}&apikey=${API_KEY_BRONXYS}`)
yuta.sendMessage(from, { react: { text: `✅`, key: info.key } });
if(data[0]?.tempo?.length >= 7) return reply(mess.error())
var N_E = "🤷‍♂️"
   await yuta.sendMessage(
        from, 
        {
            text: `*⏤͟͟͞͞🎧 sᴇ ᴅᴇsᴇᴊᴀ ʙᴀɪxᴀʀ ᴀᴜᴅɪᴏ ᴜsᴇ ${prefix}ᴘʟᴀʏ ${q.trim()}*

> ${NomeDoBot}`,
           contextInfo: {
      forwardingScore: 1,
isForwarded: true,
forwardedNewsletterMessageInfo: {
newsletterJid: `${setting.channelnk}`, 
newsletterName: `${NomeDoBot}` 
},
                    externalAdReply: { 
                        title: `${data[0]?.titulo||N_E}`, 
                        body: `⏳ : ${data[0]?.tempo||N_E}`, 
                        thumbnail: await getBuffer(data[0]?.thumb || logoslink?.logo), 
                        mediaType: 1, 
                        sourceUrl: channel
                    }
            }
        }, 
        { quoted: selo }
    );
    yuta.sendMessage(from, {video: {url: `https://api.bronxyshost.com.br/api-bronxys/play_video?nome_url=${q}&apikey=${API_KEY_BRONXYS}`}, mimetype: "video/mp4", fileName: data[0]?.titulo || "play.mp4", contextInfo: {
      forwardingScore: 1,
isForwarded: true,
forwardedNewsletterMessageInfo: {
newsletterJid: `${setting.channelnk}`, 
newsletterName: `${NomeDoBot}` 
}
}
}, 
  { quoted: selo });
} catch (e) {
    yuta.sendMessage(from, { react: { text: `❌`, key: info.key } });
console.log(e)
return reply(mess.error())
}
}
break;
  

case 'amazon': 
case 'amazonsearch':
if(q.trim().length < 4) return reply(`Exemplo: ${prefix+command} fone redmi airdots 2`)
try {
reply(mess.teste());
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/Amazon_Pesquisa?pesquisa=${q.trim()}&apikey=${API_KEY_BRONXYS}`)
RST = "Pesquisa Amazon:\n\n"
for ( i  = 0; i < (ABC.length > 40 ? 40: ABC.length); i++) {
RST +=  `( ${i+1} ) - Titulo: ${ABC[i].titulo}\n- Preço: ${ABC[i].preco}\n- Url: ${ABC[i].url}\n${"_".repeat(27)}\n\n`
}
reply(RST);
} catch {
return reply(mess.error())
}
break;

case 'pinterest2':
try {
if(!q.trim()) return reply(`Exemplo: ${prefix+command} naruto`)
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/pinterest?nome=${q}&apikey=${API_KEY_BRONXYS}`);
yuta.sendMessage(from, {image: {url: ABC[Math.floor(Math.random() * ABC.length)]}}).catch(() => {
return reply(mess.error());
})
} catch (e) {
return reply(mess.error());
}
break;

case 'print': 
case 'printdesite':
if(!q.trim()) return reply(`Faltando a url do site que quer tirar print, Exemplo: ${prefix+command} https://google.com\n\nNão esqueça do https se o site tiver, ou http se não for um site com ssl`)
try {
yuta.sendMessage(from, {image: {url: `https://api.bronxyshost.com.br/api-bronxys/print_de_site?url=${q.trim()}&apikey=${API_KEY_BRONXYS}`}}, {quoted: selo}) 
} catch {
return reply(mess.error());
}
break;

case 'pesquisa_yt': 
case 'ytsearch':
try {
if(!q.trim()) return reply(`Digite o nome de algum vídeo ou música que deseja encontrar..`);
AB = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/pesquisa_ytb?nome=${q}&apikey=${API_KEY_BRONXYS}`)
ABC = `${"-\t".repeat(13)}\n\n`
for (var i of AB) {
ABC += `Titulo: ${i.titulo}\nUrl: ${i.url}\nTempo: ${i.tempo}\nPostado: ${i.postado}\n\nDescrição: ${i.desc}\n\n`;
ABC += `${"-\t".repeat(13)}\n\n`
}
reply(ABC);
} catch (e) {
return reply(mess.error())
}
break;

case "playstore":
if(q.length < 2) return reply("Cade o título do apk que deseja pesquisar?")
data = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/playstore?nome=${q}&apikey=${API_KEY_BRONXYS}`)
ABC = "Play Store pesquisa:\n\n"
for(let a of data.resultados) {
ABC += `\n\n${a.title}\n\n----------------------------------------------\nID:
${a.appId}\n\n----------------------------------------------\n\nURL:
${a.url}\n\n----------------------------------------------`
}
reply(ABC)
break;

case 'playdoc':
await reagir(from, "📃");
try {
if(!q.trim()) return reply(`- Exemplo: ${prefix}play nome da música`)
data = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/pesquisa_ytb?nome=${q}&apikey=${API_KEY_BRONXYS}`)
if(data[0]?.tempo?.length >= 7) return reply(mess.error())
var N_E = " Não encontrado."
var bla = `AGUARDE AI CZ`
yuta.sendMessage(from, {document: {url: `https://api.bronxyshost.com.br/api-bronxys/play?nome_url=${q}&apikey=${API_KEY_BRONXYS}`}, mimetype: "audio/mpeg", fileName: data[0]?.titulo || "play.mp3"}, {quoted: selo}).catch(e => {
return reply(mess.error())
})
} catch (e) {
console.log(e)
return reply("Seja mais específico, não deu pra encontrar com apenas isto... / Erro");
}
break;


case 'facebook':
case 'face_video':
try {
if(!q.includes("facebook") && !q.includes("fb.watch")) return reply(`Exemplo: ${prefix+command} o link do Facebook`);
reply(mess.teste());
yuta.sendMessage(from, {video: {url: `https://api.bronxyshost.com.br/api-bronxys/${command}?url=${q}&apikey=${API_KEY_BRONXYS}`}, mimetype: "video/mp4"}).catch(e => {
return reply(mess.error())
})
} catch (e) {
return reply(mess.error())
}
break;

case 'face_audio':
try {
if(!q.includes("facebook") && !q.includes("fb.watch")) return reply(`Exemplo: ${prefix+command} o link do Facebook`);
reply(mess.teste());
yuta.sendMessage(from, {audio: {url: `https://api.bronxyshost.com.br/api-bronxys/${command}?url=${q}&apikey=${API_KEY_BRONXYS}`}, mimetype: "audio/mpeg"}).catch(e => {
return reply(mess.error())
})
} catch (e) {
return reply(mess.error())
}
break;

case 'twitter_video':
try {
if(!q.includes("twitter")) return reply(`Exemplo: ${prefix+command} o link do Twitter`);
reply(mess.teste());
yuta.sendMessage(from, {video: {url: `https://api.bronxyshost.com.br/api-bronxys/${command}?url=${q}&apikey=${API_KEY_BRONXYS}`}, mimetype: "video/mp4"}).catch(e => {
return reply(mess.error())
})
} catch (e) {
return reply(mess.error())
}
break;

case 'twitter_audio':
try {
if(!q.includes("twitter")) return reply(`Exemplo: ${prefix+command} o link do Twitter`);
reply(mess.teste());
yuta.sendMessage(from, {audio: {url: `https://api.bronxyshost.com.br/api-bronxys/${command}?url=${q}&apikey=${API_KEY_BRONXYS}`}, mimetype: "audio/mpeg"}).catch(e => {
return reply(mess.error())
})
} catch (e) {
return reply(mess.error())
}
break;


case 'mediafire':
try {
if(!q.includes("mediafire.com")) return reply("Faltando o link do mediafire para download do arquivo, cade?");
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/mediafire?url=${q}&apikey=${API_KEY_BRONXYS}`)
reply(`Enviando: ${ABC.resultado[0].nama}\n\nPeso: ${ABC.resultado[0].size}`)
yuta.sendMessage(from, {document: {url: ABC.resultado[0].link}, mimetype: "application/"+ABC.resultado[0].mime, fileName: ABC.resultado[0].nama}).catch(e => {
return reply(mess.error());
})
} catch (e) {
console.log(String(e))
return reply(mess.error())
}
break;

case 'metadinha':
try {
    await reagir(from, "💑️");
    const anuData = await fetchJson('https://raw.githubusercontent.com/iamriz7/kopel_/main/kopel.json')
    let selectRandom = anuData[Math.floor(Math.random() * anuData.length)];

    const maleMedia = await prepareWAMessageMedia({ image: { url: selectRandom.male } }, { upload: yuta.waUploadToServer });
    const femaleMedia = await prepareWAMessageMedia({ image: { url: selectRandom.female } }, { upload: yuta.waUploadToServer });

    const carouselMessage = {
        text: "*Resultados da metadinha* 💝 ↴",
        cards: [
            {
                header: {
                    hasMediaAttachment: true,
                    imageMessage: maleMedia.imageMessage
                },
                headerType: 'IMAGE',
                body: {
                    text: "• Perfil Masculino 🕊️"
                },
                footer: {
                    text: `${NomeDoBot}`
                },
                nativeFlowMessage: {
                    buttons: []
                }
            },
            {
                header: {
                    hasMediaAttachment: true,
                    imageMessage: femaleMedia.imageMessage
                },
                headerType: 'IMAGE',
                body: {
                    text: "• Perfil Feminino 🌸"
                },
                footer: {
                    text: `${NomeDoBot}`
                },
                nativeFlowMessage: {
                    buttons: []
                }
            }
        ]
    };
    await yuta.relayMessage(from, {
        interactiveMessage: {
            contextInfo: {
                participant: from,
                quotedMessage: {
                    documentMessage: {
                        contactVcard: true,
                        quoted: selo
                    }
                }
            },
            body: { text: '*Resultados da metadinha* 💝 ↴' },
            carouselMessage: carouselMessage
        }
    }, {});

} catch (e) {
    console.log(e);
    await yuta.sendMessage(from, { text: "Ocorreu um erro, tente novamente." }, { quoted: selo });
}
break; 


//==============[ FIM CASES DOWNLOADS ]============\\


//===========[ INFORMATIVOS DO YUTA ]===============\\

case 'redacao':
if(!q) return reply(`Você esqueceu de colocar o tema de sua redação ao lado do comando.`)
try {
let { key } = await yuta.sendMessage(from, {text: `Estou processando sua solicitação. Isso pode levar alguns segundos...`}, {quoted: selo})
promptUser = `Crie um texto dissertativo-argumentativo com o tema: ${q}`
anu1 = await fetchJson(`https://aemt.me/gpt4?text=${promptUser}`)
await yuta.sendMessage(from, {text: mess.respostaRedacao(anu1), edit: key});
} catch(error) {
return reply(mess.error())
}
break

case 'summerize':
if(!q) return reply(`Você esqueceu de colocar o que você deseja resumir ao lado do comando.`)
try {
let { key } = await yuta.sendMessage(from, {text: `Estou resumindo o texto solicitado. Isso pode levar alguns segundos...`}, {quoted: selo})
promptUser = `Faça um resumo básico do texto apresentado: ${q}`
anu1 = await fetchJson(`https://aemt.me/gpt4?text=${promptUser}`)
await yuta.sendMessage(from, {text: mess.respostaResumida(anu1), edit: key})
} catch(error) {
return reply(mess.error())
}
break


case 'wikipedia': case 'wiki':
try {
if(!q) return reply(`Exemplo: ${prefix+command} JavaScript`)
await reagir(from, "✅")
wikip = await axios.get(`https://pt.wikipedia.org/w/api.php?action=query&format=json&list=search&srsearch=${encodeURIComponent(q)}&prop=info&inprop=url`);
wikis = await axios.get(`https://pt.wikipedia.org/w/api.php?format=json&action=query&prop=extracts&exintro&explaintext&redirects=1&pageids=${wikip.data.query.search[0].pageid}`);
var carre = [
`${mess.wikiResposta(wikis)}`]

    // Envia a primeira mensagem
    let { key } = await yuta.sendMessage(from, { text:`*⚡ᴀᴄᴀʙᴇɪ ᴅᴇ ᴀᴄʜᴀʀ ᴀǫᴜɪ sᴇɴʜᴏʀ(ᴀ) 🙇‍♂️*`}, {quoted: selo})

    // Adiciona um atraso de 5 segundos antes de enviar as outras mensagens
    for (let i = 0; i < carre.length; i++) {
        await new Promise(resolve => setTimeout(resolve, 5000)); // Atraso de 5 segundos
        await yuta.sendMessage(from, { text: carre[i], mentions: [sender], edit: key });
    }
} catch(error) {
reply(mess.error())
}
break


case 'book':
if (args.length == 0) return reply(`*Exemplo:* ${prefix+command} Nome do Livro`)
try {
const takeBook = await axios.get(`https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(q)}&langRestrict=pt`);
const getBook = await axios.get(`${takeBook.data.items[0].selfLink}`);
var bookImage = await getBuffer(getBook.data.volumeInfo.imageLinks.thumbnail)
await yuta.sendMessage(from, {image: bookImage, caption: mess.searchBooks(getBook)}, {quoted: selo})
} catch(error) {
reply(mess.error())
}
break

case 'clima'://by Yutazinkkj
            case 'tempo':
                yuta.sendMessage(from, { react: { text: `📡`, key: info.key } })
                if (args.length < 1) return reply(`*Sintaxe correta para uso:* ${prefix + command} nome da cidade\n• Caso tenha algum acento, retire ok?`)
                cidade = body.slice(7)
                clima = await axios.get(`https://api.openweathermap.org/data/2.5/weather?q=${q}&appid=f5c0840c2457fbb64188a6d4be05618f&units=metric&lang=pt_br`)
                if (clima.error) return reply(resposta.erro)
                jr = `🌞 Temperatura agora: ${clima.data.main.temp}ºC
🏙️ Cidade: ${clima.data.name}
🔥 Temperatura Máxima: ${clima.data.main.temp_max}°C
❄ Temperatura Mínima: ${clima.data.main.temp_min}°C
🌦 Clima: ${clima.data.weather[0].description}
💧 Umidade de ar: ${clima.data.main.humidity}% 
🌫 Ventos: ${clima.data.wind.speed}  

Solicitado por: ${pushname}`
                await yuta.sendMessage(from, { text: jr }, { quoted: selo, contextInfo: { "mentionedJid": jr } })
                break


case 'simi':
if(!isGroup) return reply(mess.onlyGroup())
try {
datasimi = await fetchJson(`https://api.simsimi.vn/v1/simtalk`, {method: 'POST', headers: {'content-type': "application/x-www-form-urlencoded"}, body: "text="+q+"&lc=pt"});
var carre = [
`${datasimi.message}`]

    // Envia a primeira mensagem
    let { key } = await yuta.sendMessage(from, { text:`*⚡ᴀᴄᴀʙᴇɪ ᴅᴇ ᴀᴄʜᴀʀ ᴀǫᴜɪ sᴇɴʜᴏʀ(ᴀ) 🙇‍♂️*`}, {quoted: selo})

    // Adiciona um atraso de 5 segundos antes de enviar as outras mensagens
    for (let i = 0; i < carre.length; i++) {
        await new Promise(resolve => setTimeout(resolve, 5000)); // Atraso de 5 segundos
        await yuta.sendMessage(from, { text: carre[i], mentions: [sender], edit: key });
    }
} catch (e) {
return reply("Resposta não encontrada..");
}
break

case 'getchannel': {//Nk e Lm
    if (!q) return reply(`• Por favor, forneça o link do canal.\n\n> exemplo: ${prefix + command} https://whatsapp.com/channel/0029ValLKgUAO7RCUU0dO03k`);
    await reagir(from, "🎉");
    try {
        const axios = require('axios');
        const cheerio = require('cheerio');
        const response = await axios.get(q);//Nk e Lm que fez, deixa os créditos fdm
        const $ = cheerio.load(response.data);
        const title = $('title').text() || 'Nome não encontrado';
        const img = $('img._9vx6').attr('src');
        const subs = $('h5._9vd5._9scy').text() || 'Seguidores não encontrados';
        const description = $('h4._9vd5._9scb').text() || 'Descrição não encontrada';
        await yuta.sendMessage(from, {
            image: { url: img },
            caption: `- 🌟 *Nome*: ${title}\n- 👤 *Seguidores*: ${subs}\n- 🔗 *Link*: ↴\n${q}\n- 🌃 *Descrição*: ↴\n\n${description}`,
        }, { quoted: selo });

    } catch (e) {//Nk e Lm que fez, deus bemzoi
        reply('Ocorreu um erro ao tentar obter as informações do canal.');
        console.log(e);
    }
}
break;

case 'alugarbot': 
case 'alugar': 
    try {
        await reagir(from, "💎");        
        const Nk = {
            male: `https://files.catbox.moe/dknm8j.jpg`, 
            female: `https://files.catbox.moe/n83fa4.jpg`, 
            thirdImage: `https://files.catbox.moe/93jkbz.jpg` 
        };

        const maleMedia = await prepareWAMessageMedia({ image: { url: Nk.male } }, { upload: yuta.waUploadToServer });
        const femaleMedia = await prepareWAMessageMedia({ image: { url: Nk.female } }, { upload: yuta.waUploadToServer });
        const thirdMedia = await prepareWAMessageMedia({ image: { url: Nk.thirdImage } }, { upload: yuta.waUploadToServer });

        const carouselMessage = {
            text: "Nk",
            cards: [
                {
                    header: {
                        hasMediaAttachment: true,
                        imageMessage: maleMedia.imageMessage
                    },
                    headerType: 'IMAGE',
                    body: {
                        text: `🌠 15 𝑫𝒊𝒂𝒔 -『 10.00R$ 』🌠

- Alugue por 15 dias por 10,00R$ e tenha praticidade e economia! Ideal para quem precisa de algo rápido, sem complicação, e ainda conta com proteção e segurança durante o período. ⏳`
                    },
                    footer: {
                        text: `${NomeDoBot}`
                    },
                    nativeFlowMessage: {
                        buttons: [{
                            "name": "cta_url",
                            "buttonParamsJson": `{\"display_text\":\"ꜱᴜᴩᴏʀᴛᴇ Yᴜᴛᴀʙᴏᴛ-ᴍᴅ 👾\",\"url\":\"https://Wa.me/${ownerNumber}?text=Estou%20querendo%20alugar%20por%20*15*%20dias%20✅\",\"merchant_url\":\"https://Wa.me/${ownerNumber}?text=Estou%20querendo%20alugar%20por%20*15*%20dias%20✅\"}`
                        }]
                    }
                },
                {
                    header: {
                        hasMediaAttachment: true,
                        imageMessage: femaleMedia.imageMessage
                    },
                    headerType: 'IMAGE',
                    body: {
                        text: `🌠 30 𝑫𝒊𝒂𝒔 -『 20.00R$ 』🌠

Com 30 dias por 20,00R$, você ganha mais tempo e flexibilidade, além de aproveitar melhor a utilização do que está alugando. Tudo com segurança garantida e mais otimização para o seu dia a dia. 📅`
                    },
                    footer: {
                        text: `${NomeDoBot}`
                    },
                    nativeFlowMessage: {
                        buttons: [{
                            "name": "cta_url",
                            "buttonParamsJson": `{\"display_text\":\"ꜱᴜᴩᴏʀᴛᴇ Yᴜᴛᴀʙᴏᴛ-ᴍᴅ 👾\",\"url\":\"https://Wa.me/${ownerNumber}?text=Estou%20querendo%20alugar%20por%20*30*%20dias%20✅\",\"merchant_url\":\"https://Wa.me/${ownerNumber}?text=Estou%20querendo%20alugar%20por%20*30*%20dias%20✅\"}`
                        }]
                    }
                },
                {
                    header: {
                        hasMediaAttachment: true,
                        imageMessage: thirdMedia.imageMessage // Usando a terceira imagem
                    },
                    headerType: 'IMAGE',
                    body: {
                        text: `🌠 60 𝑫𝒊𝒂𝒔 -『 35.00R$ 』🌠

60 dias por 35,00R$ é a opção perfeita para quem precisa de longo prazo. Além de economizar mais, você tem proteção total e tranquilidade durante todo o período, com mais tempo para aproveitar o que alugou. 🛠️`
                    },
                    footer: {
                        text: `${NomeDoBot}`
                    },
                    nativeFlowMessage: {
                        buttons: [{
                            "name": "cta_url",
                            "buttonParamsJson": `{\"display_text\":\"ꜱᴜᴩᴏʀᴛᴇ Yᴜᴛᴀʙᴏᴛ-ᴍᴅ 👾\",\"url\":\"https://Wa.me/${ownerNumber}?text=Estou%20querendo%20alugar%20por%20*60*%20dias%20✅\",\"merchant_url\":\"https://Wa.me/${ownerNumber}?text=Estou%20querendo%20alugar%20por%20*60*%20dias%20✅\"}`
                        }]
                    }
                }
            ]
        };

        await yuta.relayMessage(from, {
            interactiveMessage: {
                contextInfo: {                    
                    participant: from,
                    quotedMessage: {
                        documentMessage: {
                            contactVcard: true,
                            quoted: selo
                        }
                    }
                },
                body: { text: '*⏤͟͟͞͞ESTÁ QUERENDO ALUGAR? OLHE A TABELA ABAXO... 🙇‍♂️* ↴' },
                carouselMessage: carouselMessage
            }
        }, {});

    } catch (e) {
        console.log(e);
        await yuta.sendMessage(from, { text: "Ocorreu um erro, tente novamente." }, { quoted: selo });
    }
    break;

case 'gpt-3.5': case 'chatgpt-3.5':
try {
if(!q) return reply("Você esqueceu de perguntar ao lado do comando.");
let { key } = await yuta.sendMessage(from, {text: `Estou processando sua pergunta, isso pode levar alguns segundos...`}, {quoted: selo});
data = await fetchJson(`https://aemt.me/turbo?text=${q}`);
await yuta.sendMessage(from, {text: `${data.result}`, edit: key});
} catch(error) {
reply(mess.error());
}
break

case 'gtts':
try {
if (args.length < 1) return await yuta.sendMessage(from,{text: `Cade o texto?, digite algo Exemplo:\n${prefix}gtts PT Oi`}, {quoted: selo})
const gtts = require('./ARQUIVES/funcoes/gtts')(args[0])
if (args.length < 2) return await yuta.sendMessage(from, {text: 'Falta colocar o código do idioma!'}, {quoted: selo})
dtt = body.slice(8)
ranm = getRandom('.mp3')
rano = getRandom('.ogg')
if(dtt.length > 200) return reply('Para reduzir spam o máximo de letras permitidas são 200!')
gtts.save(ranm, dtt, async function() {
await exec(`ffmpeg -i ${ranm} -ar 48000 -vn -c:a libopus ${rano}`, async(err) => {
await yuta.sendMessage(from, {audio: fs.readFileSync(ranm), ptt:true, mimetype: "audio/mpeg"}, {quoted: selo}).catch(async(error) => {
return reply(mess.error())
})
DLT_FL(ranm); DLT_FL(rano)
})
})
} catch(error) {
return reply(mess.error())
}
break

case 'tagme':
const tagme = `@${sender.split("@")[0]} ✔️`
await mentions(tagme, [sender], true)
break


case 'avaliar':
case 'avalie':
if(q.length < 1) return reply(`*ᴇxᴇᴍᴘʟᴏ ${prefix}ᴀᴠᴀʟɪᴇ ᴍᴇʟʜᴏʀ ʙᴏᴛ ǫᴜᴇ ᴊᴀ ᴠɪ!!*`);
if(q.length > 400) return reply(`*ᴠᴏᴄᴇ ᴘᴀssᴏᴜ ᴅᴇ 400 ᴄᴀʀᴀᴄᴛᴀʀᴇs*`);
await sendMentions(nmrdn, `*🌟 ᴀᴠᴀʟɪᴀᴄᴀᴏ ᴅᴇ: @${sender.split("@")[0]}*\n- *ᴅᴇᴛᴀʟʜᴇs:*\n• ${q}`);
await sendMentions(from, `*ᴄᴇʀᴛᴏ @${sender.split("@")[0]} ᴇɴᴠɪᴇɪ ᴀ sᴜᴀ ᴀᴠᴀʟɪᴀᴄᴀᴏ ᴀᴏ ᴍᴇᴜ ᴅᴏɴᴏ 🙇‍♂️*`);
break

case 'bug':
if(q.length < 1) return reply(`*ᴇxᴇᴍᴘʟᴏ ${prefix}ʙᴜɢ ᴏ ʙᴏᴛ ᴇsᴛᴀ ᴄᴏᴍ ᴀᴛʀᴀsᴏ*`);
if(q.length > 400) return reply(`*ᴠᴏᴄᴇ ᴘᴀssᴏᴜ ᴅᴇ 400 ᴄᴀʀᴀᴄᴛᴀʀᴇs*`);
await sendMentions(nmrdn, `*⚠ ᴏ ᴜsᴜᴀʀɪᴏ @${sender.split("@")[0]} ʀᴇʟᴀᴛᴏᴜ ᴀʟɢᴜᴍ ᴇʀʀᴏ ᴏᴜ ʙᴜɢ ɴᴏ ʙᴏᴛ*\n*ᴅᴇᴛᴀʟʜᴇs:*\n• ${q}`);
reply('*ᴍᴇɴsᴀɢᴇᴍ ᴇɴᴠɪᴀᴅᴀ ᴄᴏᴍ sᴜᴄᴇssᴏ ᴀᴏ ᴍᴇᴜ ᴍᴇsᴛʀᴇ, ᴄᴀsᴏ ᴠᴏᴄᴇ ғʟᴏᴏᴅ ᴏ ᴄᴏᴍᴀɴᴅᴏ ᴘᴏʀ ᴢᴜᴇɪʀᴀ ᴇᴜ ɪʀᴇɪ ʙʟᴏǫᴜᴇᴀʀ ᴠᴏᴄᴇ ᴅᴇ ᴜsᴀʀ ᴍᴇᴜs ᴄᴏᴍᴀɴᴅᴏs 🙇‍♂️*');
break

case 'sugestão': case 'sugestao':
if(q.length < 1) return reply(`*ᴇxᴇᴍᴘʟᴏ ${prefix}sᴜɢᴇsᴛᴀᴏ ǫᴜᴇ ᴛᴀʟ ᴄᴏʟᴏᴄᴀʀ ᴜᴍ ᴄᴏᴍᴀɴᴅᴏ ǫᴜᴇ ғᴜɴᴄɪᴏɴᴇ ᴅᴀ ᴛᴀʟ ᴍᴀɴᴇɪʀᴀ? 🤷‍♂️*`);
if(q.length > 400) return reply(`*ᴠᴏᴄᴇ ᴘᴀssᴏᴜ ᴅᴇ 400 ᴄᴀʀᴀᴄᴛᴀʀᴇs*`);
await sendMentions(nmrdn, `*⚠ ᴏ ᴜsᴜᴀʀɪᴏ @${sender.split("@")[0]} sᴜɢᴇʀɪᴜ ᴜᴍ ᴄᴏᴍᴀɴᴅᴏ ᴏᴜ sɪsᴛᴇᴍᴀ ɴᴏ ʙᴏᴛ*\n*ᴅᴇᴛᴀʟʜᴇs:*\n• ${q}`);
reply('*ᴍᴇɴsᴀɢᴇᴍ ᴇɴᴠɪᴀᴅᴀ ᴄᴏᴍ sᴜᴄᴇssᴏ ᴀᴏ ᴍᴇᴜ ᴍᴇsᴛʀᴇ, ᴄᴀsᴏ ᴠᴏᴄᴇ ғʟᴏᴏᴅ ᴏ ᴄᴏᴍᴀɴᴅᴏ ᴘᴏʀ ᴢᴜᴇɪʀᴀ ᴇᴜ ɪʀᴇɪ ʙʟᴏǫᴜᴇᴀʀ ᴠᴏᴄᴇ ᴅᴇ ᴜsᴀʀ ᴍᴇᴜs ᴄᴏᴍᴀɴᴅᴏs 🙇‍♂️*');
break


case 'movie':
if (args.length == 0) return reply(`Cadê o nome do filme o qual você deseja ver informações?`)
movieInfo = await axios.get(`https://api.themoviedb.org/3/search/movie?api_key=ddfcb99fae93e4723232e4de755d2423&query=${encodeURIComponent(q)}&language=pt`);
if (movieInfo.data.total_results == 0) return reply(mess.noresult())
var ImageMovieLink = `https://image.tmdb.org/t/p/original${movieInfo.data.results[0].backdrop_path}`;
var fotoFilme = await getBuffer(ImageMovieLink)
yuta.sendMessage(from, {image: fotoFilme, caption: mess.movies(movieInfo)}, {quoted: selo})
.catch(async(error) => {
return reply(mess.error());
})
break


case 'gpt2': { //By Lm Only 
    try {
        if (!q) return reply("É necessário especificar melhor o tema sobre o que deseja!");
        
        /** Inportando o módulo **/
        const GoogleSearchIA = require('./DADOS DO YUTA/gpt.js');
        
        /** Criando a instância **/
        const response = new GoogleSearchIA(q.trim());
        
        /** Obtendo results **/
        const res = await response.text();
        
        reply(res.result.text);
    } catch (e) {
        console.error(e);
        reply("Houve um erro ao processar o comando!");
    }
    break;
}

case 'series': {//nunu
    try {
        const nunuzqrw = await axios.get('https://www.adorocinema.com/series/');
        const nunuhjtr = cheerio.load(nunuzqrw.data);
        const nunufyxk = [];    
        nunuhjtr('.roller-item').each((nunuxcbz, nunuhblk) => {
            const nunujlwp = nunuhjtr(nunuhblk).find('.meta-title-link').text().trim();
            const nunusygh = nunuhjtr(nunuhblk).find('.meta-description').text().trim();
            const nunuhsnj = `https://www.adorocinema.com${nunuhjtr(nunuhblk).find('.meta-title-link').attr('href')}`;
            const nunuqksa = nunuhjtr(nunuhblk).find('.thumbnail-img').attr('data-src');       
            if (nunujlwp && nunuhsnj) {
                nunufyxk.push({
                    nunujlwp,
                    nunusygh,  
                    nunuhsnj,
                    nunuqksa
                });
            }
        });
        const nunumaxSeries = nunufyxk.slice(0, 8);
        let nunugktp = '🦺 *Melhores Séries da Semana:*\n\n';
        nunumaxSeries.forEach((nunusrzl, nunuihra) => {
            nunugktp += `🩴 *${nunuihra + 1}. ${nunusrzl.nunujlwp}*\n` +
                        `🈳️ *Gêneros:* ${nunusrzl.nunusygh}\n` +
                        `🚩 *Link:* ${nunusrzl.nunuhsnj}\n\n`;
        });
        if (nunumaxSeries.length > 0 && nunumaxSeries[0].nunuqksa) {
            await yuta.sendMessage(from, { 
                image: { url: nunumaxSeries[0].nunuqksa }, 
                caption: nunugktp 
            }, { quoted: selo });
        } else {
            await yuta.sendMessage(from, { text: nunugktp }, { quoted: selo });
        } 
    } catch (nunuevbr) {
        console.error('Erro ao buscar as séries:', nunuevbr);
        reply('⚠️ Não foi possível buscar as melhores séries no momento.');
    }
    break;
}


case 'signo':
try {
if(!q.trim()) return reply(`Digite seu signo, exemplo: ${prefix+command} virgem`);
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/horoscopo?signo=${q}&apikey=${API_KEY_BRONXYS}`)
yuta.sendMessage(from, {image: {url: ABC.img}, caption: `Signo: ${q}\n\n${ABC.title}\n${ABC.body}`}).catch(e => {
return reply(mess.error());
})
} catch (e) {
return reply(mess.error());
}
break;

case 'noticias': 
case 'getnoticias':
try {
if (!q) return reply(`Informe um tema para realizar a pesquisa de suas notícias!`)
theNews = await axios.get(`https://newsapi.org/v2/everything?q=${encodeURIComponent(q)}&sortBy=publishedAt&language=pt&apiKey=9dc1dde158804756ae9b33dd8d71f7a1`);
d = await pickRandom(theNews.data.articles)

reply(`> *${d.title}* - ${d.author} [${d.source.name}]\n–\n• Descrição: *${d.description}*\n• Postagem: *${d.publishedAt.split('T').join(' - ').split('Z')[0]}*\n• URL: *${d.url}*`)
} catch (error) {
return reply(mess.error())
}
break

case 'googlenews': 
case 'gnews':
try {
idioma = "pt-br"; // Idioma: Português do Brasil
country = "BR"; // Mude a sigla para qual você quiser puxar as notícias.
dataNews = await fetchJson(`https://delirius-api-oficial.vercel.app/api/noticias?language=${idioma}&country=${country}`);
NTD = pickRandom(dataNews.headline_stories);
await reply(`> Google Notícias - Brasil:\n–\n• Título: *${NTD.title}*\n• Postagem por: *${NTD.by}* | ${NTD.published}\n–\n• URL: *${NTD.url}*`);
} catch(e) {
return await reply(mess.error());
}
break

case 'grupos': {
reply(mess.teste());
blue = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/grupos?q=${q}&apikey=${API_KEY_BRONXYS}`)
let red = "Listagem de grupos para você:\n\n"
blue.forEach(function(ab) {
red += ` - Url do Grupo: ${ab.link}\n\n - Descrição: ${ab.desc}\n\n${"-".repeat(20)}\n\n`
})
reply(red)
}
break;

case 'moedas': 
case 'moeda':
try {
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/Moedas_Agora?apikey=${API_KEY_BRONXYS}`)
reply(`${ABC?.dolar}\n\n${ABC?.euro}\n\n${ABC?.libra}\n\n${ABC?.bitcoin}\n\n${ABC?.ethereum}\n\n${ABC?.bovespa}\n\n${ABC?.ouro}`);
} catch {
return reply(mess.error())
}
break;

case "letra": 
case "liryc": 
case "letram": 
case "letramusic": 
case "letramusica": {
if(!q.trim()) return reply(`Exemplo: ${prefix+command} Ela me traiu`)
try {
reply(mess.teste());
const abc = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/letra_musica?letra=${q.trim()}&apikey=${API_KEY_BRONXYS}`)
reply(` - Titulo: ${abc.titulo}\n\n - Compositor: ${abc.compositor}\n\n - Letra: ${abc.letra}`)
} catch (e) {
reply(mess.error())
}
}
break;

case 'pergunta': 
case 'openai': 
case 'gpt': 
case 'chatgpt':
await reagir(from, "👾")
try {
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/PERGUNTE_E_EU_RESPONDO?q=${q.trim()}&apikey=${API_KEY_BRONXYS}`)
var carre = [
`${ABC.msg}`]

    // Envia a primeira mensagem
    let { key } = await yuta.sendMessage(from, { text:`*⚡ᴀᴄᴀʙᴇɪ ᴅᴇ ᴀᴄʜᴀʀ ᴀǫᴜɪ sᴇɴʜᴏʀ(ᴀ) 🙇‍♂️*`}, {quoted: selo})

    // Adiciona um atraso de 5 segundos antes de enviar as outras mensagens
    for (let i = 0; i < carre.length; i++) {
        await new Promise(resolve => setTimeout(resolve, 5000)); // Atraso de 5 segundos
        await yuta.sendMessage(from, { text: carre[i], mentions: [sender], edit: key });
    }
} catch { 
reply(mess.error())
}
break;

case 'esportenoticias': 
case 'esportenoticia': 
case 'espnoticia': 
case 'espnoticias':
case 'noticiasesporte': 
case 'noticiaesporte': 
case 'noticiaesp': 
case 'noticiasesp':
case 'esporte_noticias': 
case 'esporte_noticia': 
case 'esporte-noticias': 
case 'esporte-noticia':
reply(mess.teste());
try {
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/esporte_noticias?apikey=${API_KEY_BRONXYS}`)
AB =""
for ( i = 1; i < ABC.length; i++) {
AB += `${ABC[i].titulo}\n\n`
}
yuta.sendMessage(from, {image: {url: ABC[0].img}, caption: AB}, {quoted: selo})
} catch {
return reply(mess.error())
}
break;

case 'celular':
try {
if(!q.trim()) return reply(`Exemplo: ${prefix+command} galaxy a9 2018`);
reply(mess.teste());;
ABC = await fetchJson(`https://api.bronxyshost.com.br/api-bronxys/info_celular?celular=${q}&apikey=${API_KEY_BRONXYS}`);
reply(`📱 Celular: ${ABC.celular || "Não encontrado"}\n\nInformações:\n${ABC.resumo || ABC.infoc || "Não encontrado, seja mais específico, a marca e a versão"}`);
} catch (e) {
return reply(mess.error());
}
break;

case 'serie':
if (args.length == 0) return reply(`Cadê o nome da serie o qual você deseja ver informações?`)
serieInfo = await axios.get(`https://api.themoviedb.org/3/search/tv?api_key=ddfcb99fae93e4723232e4de755d2423&query=${encodeURIComponent(q)}&language=pt`);
if (serieInfo.data.total_results == 0) return reply(mess.noresult());
await yuta.sendMessage(from, {image: {url: `https://image.tmdb.org/t/p/original${serieInfo.data.results[0].backdrop_path}`}, caption: mess.series(serieInfo)}, {quoted: selo})
.catch(async(error) => {
return reply(mess.error())
})
break

case 'aptoide':
if (args.length == 0) return reply(`Cadê o nome do app? *Use como exemplo:* ${prefix+command} WhatsApp.`)
try {
const aptoide = await axios.get(`https://ws75.aptoide.com/api/7/apps/search?query=${encodeURIComponent(q)}&trusted=true`);
if (aptoide.data.datalist.total == 0) return reply(mess.noresult());
phAptoide = await(await fetch(aptoide.data.datalist.list[0].graphic)).buffer();
lnDown = await axios.get(`https://tinyurl.com/api-create.php?url=${aptoide.data.datalist.list[0].file.path_alt}`);
await yuta.sendMessage(from, {image: phAptoide, caption: mess.aptoide(aptoide.data.datalist.list[0], (aptoide.data.datalist.list[0].size / 1048576).toFixed(1), lnDown)}, {quoted: selo}); 
await yuta.sendMessage(from, {document: {url: aptoide.data.datalist.list[0].file.path}, mimetype: "application/vnd.Android.package-archive", fileName: `${aptoide.data.datalist.list[0].name}.apk`, caption: "Download Completo!"}, {quoted: selo})
} catch(error) {
return reply(mess.error())
}
break

//===========[ FIM CASES INFORMATIVOS ]==========\\

//=======[ COMANDOS BÁSICOS DE LOGOS DO YUTA ]=========\\

case 'angelwing': 
case 'hackneon': 
case 'fpsmascote': 
case 'equipemascote': 
case 'txtquadrinhos': 
case 'ffavatar':
case 'mascotegame': 
case 'angelglx': 
case 'gizquadro': 
case 'wingeffect': 
case 'blackpink': 
case 'girlmascote': 
case 'logogame':
try {
if(!q) return reply(`Digite algo, Exemplo: ${prefix+command} xbot`);  
reply(mess.teste());
ABC = await fetchJson(`https://jeff-apis.tech/api/${command}?texto=${q}&apikey=${API_KEY_JEFF}`);
yuta.sendMessage(from, {image: {url: ABC.resultado.imageUrl}}, {quoted: selo}).catch(() => {
return reply(mess.error())
})
} catch (e) {
return reply(mess.error())
}
break;


case 'fiction': 
case '3dstone': 
case 'areia': 
case 'style': 
case 'blood': 
case 'pink': 
case 'cattxt': 
case 'neondevil':
case 'carbon': 
case 'metalfire': 
case 'thunder': 
case 'vidro': 
case 'jokerlogo': 
case 'transformer': 
case 'demonfire':
case 'jeans': 
case 'metalblue': 
case 'natal': 
case 'ossos':
case 'asfalto': 
case 'break': 
case 'glitch2': 
case 'colaq':
case 'neon3': 
case 'nuvem': 
case 'horror': 
case 'matrix':
case 'berry': 
case 'luxury': 
case 'lava': 
case 'thunderv2':
case 'neongreen': 
case 'neve': 
case 'neon': 
case 'neon1':  
case 'neon3d': 
case 'gelo': 
case 'neon3': 
case '3dgold':
case 'lapis': 
case 'toxic': 
case 'demongreen': 
case 'rainbow':
case 'halloween':
try {
if(!q) return reply(`Digite algo, Exemplo: ${prefix+command} bronxys`);  
reply(mess.teste());
ABC = await fetchJson(`https://jeff-apis.tech/api/${command}?texto=${q}&apikey=${API_KEY_JEFF}`);
yuta.sendMessage(from, {image: {url: ABC.resultado}}, {quoted: selo}).catch(() => {
return reply(mess.error())
})
} catch (e) {
return reply(mess.error())
}
break;

case 'shadow': 
case 'metalgold': 
case 'cup': 
case 'txtborboleta': 
case 'cemiterio': 
case 'efeitoneon':
case 'harryp': 
case 'lobometal':
case 'neon2':
case 'madeira': 
case 'lovemsg3': 
case 'coffecup':
case 'coffecup2': 
case 'florwooden': 
case 'narutologo':
case 'fire': 
case 'romantic': 
case 'smoke':  
case 'papel': 
case 'lovemsg': 
case 'lovemsg2':
try {
if(!q) return reply(`Digite algo, Exemplo: ${prefix+command} bronxys`);  
reply(mess.teste());
ABC = await fetchJson(`https://jeff-apis.tech/api/${command}?texto=${q}&apikey=${API_KEY_JEFF}`);
yuta.sendMessage(from, {image: {url: ABC.resultado.imageUrl}}, {quoted: selo}).catch((e) => {
return reply(mess.error())
})
} catch (e) {
return reply(mess.error())
}
break;


case 'marvel': 
case 'pornhub':
case 'space': 
case 'stone':
case 'steel': 
case 'grafity': 
case 'glitch3': 
case 'america':
try {
var [DG, DG2] = q.split("/")
if(!q.includes("/")) return reply(`Exemplo: ${prefix+command} xbot/mdm`)
reply(mess.teste());
ABC = await fetchJson(`https://jeff-apis.tech/api/${command}?texto=${DG}&texto2=${DG2}&apikey=${API_KEY_JEFF}`);
yuta.sendMessage(from, {image: {url: ABC.resultado}}, {quoted: selo}).catch(e => {
return reply(mess.error())
})
} catch (e) {
return reply(mess.error())
}
break;

case 'lixo': 
case 'lgbt': 
case 'morto': 
case 'preso': 
case 'deletem':
case 'procurado': 
case 'hitler': 
case 'borrar': 
case 'merda':
try {
IMG = JSON.parse(JSON.stringify(info)?.replace('quotedM','m'))?.message?.extendedTextMessage?.contextInfo?.message?.imageMessage || info.message?.imageMessage
PXR = await getFileBuffer(IMG, "image")
reply(mess.teste());
link = await upload(PXR)
yuta.sendMessage(from, {image: {url:`https://api.bronxyshost.com.br/api-bronxys/montagem?url=${link}&category=${command}&apikey=${API_KEY_BRONXYS}`}}, {quoted: selo}).catch(e => {
return reply(mess.error())
})
} catch (e) {
return reply('Marque uma imagem no WhatsApp, formato jpeg/jpg');
}
break

//==============[ FIM CASES LOGOS ]============\\

//=============[ MENUS E INFOS ]==========\\



case 'status': {
   await reagir(from, "⚠️");
   if(!isGroupAdmins && !SoDono) return reply(mess.onlyAdmins());
   if (isAudioMenu) {
      await sendAudioMenu(from);
   }
   try {
      const statusImage = await getBuffer(`${ftmenu.logo}`);  // Usando `${ftmenu.logo}`
      if (!statusImage) throw new Error("Imagem não carregada");

      await yuta.sendMessage(from, {
         image: statusImage,  // Alterado para 'image'
         caption: linguagem.status({
            prefix,
            isAntiImg, 
            isAntiVid, 
            isAntiAudio, 
            isAntiSticker, 
            Antidoc, 
            isAntiCtt, 
            Antiloc, 
            isAntilinkgp, 
            isAntiLinkEasy, 
            isAntiLinkHard, 
            isAntifake, 
            isAntiNotas, 
            isAnticatalogo, 
            isPalavrao, 
            isAntiFlood, 
            isAntiDDD, 
            isModobn, 
            isSimi, 
            isAutorepo, 
            isModoCoins, 
            isAutofigu, 
            isAnticall, 
            isAntiPv, 
            isAntiPv2, 
            isAntiPv3, 
            ANT_SP, 
            nescessario, 
            isBotoff, 
            So_Adm, 
            isMultiP, 
            isx9, 
            isX9VisuUnica, 
            isWelkom, 
            isWelkom2
         }),
         contextInfo: {
            forwardingScore: 1,
            isForwarded: true,
            forwardedNewsletterMessageInfo: {
               newsletterJid: `${setting.channelnk}`, 
               newsletterName: `${NomeDoBot}` 
            }
         }
      }, { quoted: selo });
   } catch (e) {
      console.error("Erro ao executar o comando:", e);
      await yuta.sendMessage(from, { text: "Desculpe, ocorreu um erro ao tentar carregar a imagem." }, { quoted: selo });
   }
   break;
}

case 'noprefix': {
   await reagir(from, "🀄");
   if (isAudioMenu) {
      await sendAudioMenu(from);
   }
   try {
      const noprefixImage = await getBuffer(`${ftmenu.logo}`);  // Usando `${ftmenu.logo}`
      if (!noprefixImage) throw new Error("Imagem não carregada");

      await yuta.sendMessage(from, {
         image: noprefixImage,  // Alterado para 'image'
         caption: linguagem.semprefix(prefix),
         contextInfo: {
            forwardingScore: 1,
            isForwarded: true,
            forwardedNewsletterMessageInfo: {
               newsletterJid: `${setting.channelnk}`, 
               newsletterName: `${NomeDoBot}` 
            }
         }
      }, { quoted: selo });
   } catch (e) {
      console.error("Erro ao executar o comando:", e);
      await yuta.sendMessage(from, { text: "Desculpe, ocorreu um erro ao tentar carregar a imagem." }, { quoted: selo });
   }
   break;
}

case 'menucoins': {
   await reagir(from, "⛄");
   if (!isGroup) return reply(mess.onlyGroup());
   if (!isModoCoins) return reply(`*ᴇssᴇ ᴄᴏᴍᴀɴᴅᴏ sᴏ ᴘᴏᴅᴇ sᴇʀ ᴀᴛɪᴠᴏ ǫᴜᴀɴᴅᴏ ᴏ sɪᴛᴇᴍᴀ ${prefix}ᴍᴏᴅᴏᴄᴏɪɴs ᴇsᴛɪᴠᴇʀ ᴀᴛɪᴠᴏ 🤷‍♂️*`);

   if (isAudioMenu) {
      await sendAudioMenu(from);
   }
   const menucoinsImage = await getBuffer(`${ftmenu.logo}`);  // Usando `${ftmenu.logo}`
   if (!menucoinsImage) throw new Error("Imagem não carregada");

   await yuta.sendMessage(from, {
      image: menucoinsImage,  // Alterado para 'image'
      caption: linguagem.coins(prefix),
      contextInfo: {
         forwardingScore: 1,
         isForwarded: true,
         forwardedNewsletterMessageInfo: {
            newsletterJid: `${setting.channelnk}`, 
            newsletterName: `${NomeDoBot}` 
         }
      }
   }, { quoted: selo });
   break;
}

case 'menu': {
   await reagir(from, "🌟");
   if (isAudioMenu) {
      await sendAudioMenu(from);
   }
   const menuImage = await getBuffer(`${ftmenu.logo}`);  // Usando `${ftmenu.logo}`
   if (!menuImage) throw new Error("Imagem não carregada");

   await yuta.sendMessage(from, {
      image: menuImage,  // Alterado para 'image'
      caption: linguagem.menu(prefix, sender, pushname, isVip, isCargo),
      contextInfo: {
         forwardingScore: 1,
         isForwarded: true,
         forwardedNewsletterMessageInfo: {
            newsletterJid: `${setting.channelnk}`, 
            newsletterName: `${NomeDoBot}`
         },
      },
   }, { quoted: selo });
   break;
}

case 'menu18': {
   await reagir(from, "🌲");
   if (isAudioMenu) {
      await sendAudioMenu(from);
   }
   const menu18Image = await getBuffer(`${ftmenu.logo}`);  // Usando `${ftmenu.logo}`
   if (!menu18Image) throw new Error("Imagem não carregada");

   await yuta.sendMessage(from, {
      image: menu18Image,  // Alterado para 'image'
      caption: linguagem.menu18(prefix),
      contextInfo: {
         forwardingScore: 1,
         isForwarded: true,
         forwardedNewsletterMessageInfo: {
            newsletterJid: `${setting.channelnk}`, 
            newsletterName: `${NomeDoBot}` 
         }
      }
   }, { quoted: selo });
   break;
}

case 'menudono': {
   await reagir(from, "❄");
   if(!SoDono) return reply(mess.onlyOwner());
   if (isAudioMenu) {
      await sendAudioMenu(from);
   }
   const menudonoImage = await getBuffer(`${ftmenu.logo}`);  // Usando `${ftmenu.logo}`
   if (!menudonoImage) throw new Error("Imagem não carregada");

   await yuta.sendMessage(from, {
      image: menudonoImage,  // Alterado para 'image'
      caption: linguagem.menudono(prefix),
      contextInfo: {
         forwardingScore: 1,
         isForwarded: true,
         forwardedNewsletterMessageInfo: {
            newsletterJid: `${setting.channelnk}`, 
            newsletterName: `${NomeDoBot}` 
         }
      }
   }, { quoted: selo });
   break;
}

case 'menuadm': {
   await reagir(from, "🎅");
   if(!isGroupAdmins && !SoDono) return reply(mess.onlyAdmins());
   if (isAudioMenu) {
      await sendAudioMenu(from);
   }
   
   const menuadmImage = await getBuffer(`${ftmenu.logo}`);  // Usando `${ftmenu.logo}`
   if (!menuadmImage) throw new Error("Imagem não carregada");

   await yuta.sendMessage(from, {
      image: menuadmImage,  // Alterado para 'image'
      caption: linguagem.adms(prefix),
      contextInfo: {
         forwardingScore: 1,
         isForwarded: true,
         forwardedNewsletterMessageInfo: {
            newsletterJid: `${setting.channelnk}`, 
            newsletterName: `${NomeDoBot}` 
         }
      }
   }, { quoted: selo });
   break;
}

case 'efeitoimg':
case 'logo':
case 'logos':
case 'menulogo': {
   await reagir(from, "☃️");
   if (isAudioMenu) {
      await sendAudioMenu(from);
   }
   const menulogoImage = await getBuffer(`${ftmenu.logo}`);  // Usando `${ftmenu.logo}`
   if (!menulogoImage) throw new Error("Imagem não carregada");

   await yuta.sendMessage(from, {
      image: menulogoImage,  // Alterado para 'image'
      caption: linguagem.menulogos(prefix),
      contextInfo: {
         forwardingScore: 1,
         isForwarded: true,
         forwardedNewsletterMessageInfo: {
            newsletterJid: `${setting.channelnk}`, 
            newsletterName: '「 🥂𝑪𝑯𝑨𝑵𝑵𝑬𝑳🧸 」- © 𝐘𝐮𝐭𝐚𝐁𝐨𝐭-𝑴𝑩⸺͟͞✰' 
         }
      }
   }, { quoted: selo });
   break;
}

case 'brincadeiras':
case 'brincadeira':
case 'menubn': {
   await reagir(from, "🌬");
   if(!isGroup) return reply(mess.onlyGroup());
   if(!isModobn) return reply(mess.onlyGroupFun(prefix));
   if (isAudioMenu) {
      await sendAudioMenu(from);
   }
   const brincadeirasImage = await getBuffer(`${ftmenu.logo}`);  // Usando `${ftmenu.logo}`
   if (!brincadeirasImage) throw new Error("Imagem não carregada");

   await yuta.sendMessage(from, {
      image: brincadeirasImage,  // Alterado para 'image'
      caption: linguagem.brincadeiras(prefix),
      contextInfo: {
         forwardingScore: 1,
         isForwarded: true,
         forwardedNewsletterMessageInfo: {
            newsletterJid: `${setting.channelnk}`, 
            newsletterName: '「 🥂𝑪𝑯𝑨𝑵𝑵𝑬𝑳🧸 」- © 𝐘𝐮𝐭𝐚𝐁𝐨𝐭-𝑴𝑩⸺͟͞✰' 
         }
      }
   }, { quoted: selo });
   break;
}



case 'donos': {
   await reagir(from, "♨")
   try {
    const thumbnail = await getBuffer(`https://files.catbox.moe/fjfi5x.mp4`);
    if (!thumbnail) throw new Error("Thumbnail não carregado");

    await yuta.sendMessage(from, {
      video: thumbnail,
      caption: linguagem.consultas(prefix, numero_dono1, numero_dono2, numero_dono3, numero_dono4, numero_dono5, numero_dono6, NomeDoBot),
  gifPlayback: true,
      contextInfo: {
      forwardingScore: 1,
isForwarded: true,
forwardedNewsletterMessageInfo: {
newsletterJid: `${setting.channelnk}`, 
newsletterName: `${NomeDoBot}` 

        }
      }
    }, { quoted: selo });
  } catch (e) {
    console.error("Erro ao executar o comando:", e);
    await yuta.sendMessage(from, { text: "Desculpe, ocorreu um erro ao tentar carregar o vídeo." }, { quoted: selo });
  }
  break;
}


case 'infobot':
case 'infodono':
case 'dono': {
  await reagir(from, "💯")
  try {
    const thumbnail = await getBuffer(`https://files.catbox.moe/9an9o9.mp4`);
    if (!thumbnail) throw new Error("Thumbnail não carregado");

    await yuta.sendMessage(from, {
      video: thumbnail,
      caption: linguagem.dono(prefix, NomeDoBot, NumeroDoBot, ownerNumber, isBotoff, ownerName, botNumber),
  gifPlayback: true,
      contextInfo: {
      forwardingScore: 1,
isForwarded: true,
forwardedNewsletterMessageInfo: {
newsletterJid: `${setting.channelnk}`, 
newsletterName: `${NomeDoBot}` 
        }
      }
    }, { quoted: selo });
  } catch (e) {
    console.error("Erro ao executar o comando:", e);
    await yuta.sendMessage(from, { text: "Desculpe, ocorreu um erro ao tentar carregar o vídeo." }, { quoted: selo });
  }
  break;
}


//============[ FIM MENU E INFOS ]==========\\

//=========== [ ÍNICIO JOGOS ] =========\\

case 'quando':  
if (args.length < 1) return reply('Digite a pergunta!')
const meupirul = ['Hoje', 'Amanhã', 'Nunca', 'dia', 'semana', 'mês', 'ano']
const meupirul2 = ['dias', 'semanas', 'meses', 'anos']
randomm = meupirul[Math.floor(Math.random() * meupirul.length)]
random2 = `${Math.floor(Math.random() * 11) + 1}`
if (randomm == 'Hoje' || randomm == 'Amanhã' || randomm == 'Nunca') {
texto = `Pergunta: ${body.slice(1)}\nResposta: ${randomm}`
} else if (random2 == 1) {
texto = `Pergunta: ${body.slice(1)}\nResposta:  1 ${randomm}`
} else {
random3 = meupirul2[Math.floor(Math.random() * meupirul2.length)]
texto = `Pergunta: ${body.slice(1)}\nResposta: ${random2} ${random3}`
}
reply(texto)
break

case 'forca': { //Lm Only
    try {
        if(!isGroup) return reply(mess.onlyGroup())
        if(!isModobn) return reply(mess.onlyGroupFun(prefix))

        //Atenção aqui, o caminho pode ser diferente
        const pathF = `./INFO_YUTA/forca/database/session-${from}.json`;

        if (fs.existsSync(pathF)) {
            return reply('*ᴏ ᴊᴏɢᴏ ᴊᴀ ғᴏɪ ɪɴɪᴄɪᴀᴅᴏ ᴀɴᴛᴇs 🙇‍♂️*');
        }

        //Tema aleatório
        const word = palavras[Math.floor(Math.random() * palavras.length)];

        const params = {
            palavra: word.palavra,
            tema: word.tema,
            dica: word.dica,
            path: './INFO_YUTA/forca/database', //Caminho da pasta
        };
        const data = forca.startSession(from, params);

        reply(`• 🎮 𝐉𝐎𝐆𝐎--𝐃𝐀-𝐅𝐎𝐑𝐂𝐀 🌠 •\n*⏤͟͟͞͞ʟᴇᴛʀᴀs*: ${data.palavra.length}\n*⏤͟͟͞͞ᴛᴇᴍᴀ*: ${word.tema}\n*⏤͟͟͞͞ᴅɪᴄᴀ*: ${word.dica}\n|───𖡜̸｡᭭\n       _¦_\n╚ ${frames[data.erros]}\n\n\n⏤꫶͟͟͞͞───────────➮\n\n『 ${data.letrasX.join('')} 』\n\n⏤͟͟͞͞───────────➮\n⏤͟͟͞͞ʟᴇᴛʀᴀs ᴊᴏɢᴀᴅᴀs: ${data.usado.join(', ')}\n\n> ᴜsᴇ ᴏ ${prefix}ғᴄ ᴘᴀʀᴀ ᴀᴅᴠɪɴʜᴀʀ ᴀ ʟᴇᴛʀᴀ ᴏᴜ ᴀ ᴘᴀʟᴀᴠʀᴀ ᴛᴏᴅᴀ`);
    } catch (e) {
        console.error(e);
        reply('*ᴏᴄᴏʀʀᴇᴜ ᴜᴍ ᴇʀʀᴏ, ᴛᴇɴᴛᴇ ɴᴏᴠᴀᴍᴇɴᴛᴇ ᴍᴀɪs ᴛᴀʀᴅᴇ 🙇‍♂️*');
    }
    break; //Lm Only
}




//Case principal para adivinhar a letra e etc..
case 'fc': { //Lm Only
    try {
        if(!isGroup) return reply(mess.onlyGroup())
        if(!isModobn) return reply(mess.onlyGroupFun(prefix))
       if (!fs.existsSync(`./INFO_YUTA/forca/database/session-${from}.json`)) {
            return reply(`*ᴏ ᴊᴏɢᴏ ᴀɪɴᴅᴀ ɴᴀᴏ ᴄᴏᴍᴇᴄᴏᴜ 🤷‍♂️*\n\n*ᴜsᴇ ${prefix}ғᴏʀᴄᴀ ᴘᴀʀᴀ ɪɴɪᴄɪᴀʀ ᴏ ᴊᴏɢᴏ 🙆‍♂️*`);
        }
        if (!q || q.length == 2 || !isNaN(q)) return reply("*ᴠᴏᴄᴇ sᴏ ᴘᴏᴅᴇ ᴜsᴀʀ ᴜᴍᴀ ᴘᴀʟᴀᴠʀᴀ ᴏᴜ ᴀ ғʀᴀsᴇ ᴛᴏᴅᴀ 🤷‍♂️*");

        const pathF = `./INFO_YUTA/forca/database/session-${from}.json`;

        const database = JSON.parse(fs.readFileSync(pathF));
        const q_ToLC = q.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "");

        if (database.usado.includes(q_ToLC)) return reply('*ᴇsᴛᴀ ʟᴇᴛʀᴀ ᴊᴀ ғᴏɪ ᴜsᴀᴅᴀ, ᴛᴇʙᴛᴇ ᴏᴜᴛʀᴀ ʟᴇᴛʀᴀ 🙇‍♂️*');

        //Atenção aqui
        const data = forca.verify(from, q_ToLC, './INFO_YUTA/forca/database');

        if (data.ended) {
            if (data.win) {
                reply('*ᴠᴏᴄᴇ ᴀᴄᴀʙᴀ ᴅᴇ ɢᴀɴʜᴀʀ ᴏ ɢᴀᴍᴇ 🙇‍♂️*');
                //...Implementar o resto do que você quiser
            } else {
                reply('*sɪɴᴛᴏ ᴍᴜɪᴛᴏ ᴍᴀs ᴠᴏᴄᴇ ᴘᴇʀᴅᴇᴜ, ᴛᴇɴᴛᴇ ɴᴏᴠᴀᴍᴇɴᴛᴇ ɴᴀ ᴘʀᴏxɪᴍᴀ 🤷‍♂️*');
                //...Implementar o resto do que você quiser
            }
            DLT_FL(data.session);
        } else {
            if (data.letrasY.includes(q_ToLC)) {
                reply('*ᴠᴏᴄᴇ ᴀᴄᴇʀᴛᴏᴜ ᴀ ʟᴇᴛʀᴀ 🙆‍♂️*');
            } else {
                reply('*sɪɴᴛᴏ ᴍᴜɪᴛᴏ, ᴠᴏᴄᴇ ᴇʀʀᴏᴜ 🤷‍♂️*');
            }

            reply(`• 🎮 𝐉𝐎𝐆𝐎--𝐃𝐀-𝐅𝐎𝐑𝐂𝐀 🌠 •\n*⏤͟͟͞͞ʟᴇᴛʀᴀs*: ${data.palavra.length}\n*⏤͟͟͞͞ᴛᴇᴍᴀ*: ${data.tema}\n*⏤͟͟͞͞ᴅɪᴄᴀ*: ${data.dica}\n|───𖡜̸｡᭭\n       _¦_\n╚ ${frames[data.erros]}\n\n\n⏤꫶͟͟͞͞───────────➮\n\n『 ${data.letrasX.join('')} 』\n\n⏤͟͟͞͞───────────➮\n⏤͟͟͞͞ʟᴇᴛʀᴀs ᴊᴏɢᴀᴅᴀs: ${data.usado.join(', ')}\n\n> ᴜsᴇ ᴏ ${prefix}ғᴄ ᴘᴀʀᴀ ᴀᴅᴠɪɴʜᴀʀ ᴀ ʟᴇᴛʀᴀ ᴏᴜ ᴀ ᴘᴀʟᴀᴠʀᴀ ᴛᴏᴅᴀ`);
        }

    } catch (e) {
        console.log(e);
        reply('*ᴏᴄᴏʀʀᴇᴜ ᴜᴍ ᴇʀʀᴏ, ᴛᴇɴᴛᴇ ɴᴏᴠᴀᴍᴇɴᴛᴇ ᴍᴀɪs ᴛᴀʀᴅᴇ 🙇‍♂️*');
    }
    break; //Lm Only
}

//Comando para resetar a forca
case 'rv_forca': //Lm Only
    try {
        if(!isGroup) return reply(mess.onlyGroup())
        if(!isModobn) return reply(mess.onlyGroupFun(prefix))
        
        //Atenção ao caminho correto do arquivo
        const database = `./INFO_YUTA/forca/database/session-${from}.json`;
        
        if (!fs.existsSync(database)) {
            reply(`*ᴏ ᴊᴏɢᴏ ᴀɪɴᴅᴀ ɴᴀᴏ ᴄᴏᴍᴇᴄᴏᴜ 🤷‍♂️*\n\n*ᴜsᴇ ${prefix}ғᴏʀᴄᴀ ᴘᴀʀᴀ ɪɴɪᴄɪᴀʀ ᴏ ᴊᴏɢᴏ 🙆‍♂️*`);
        } else {
            DLT_FL(database);
            reply('*ᴘʀᴏɴᴛᴏ, ʀᴇsᴇᴛᴇɪ ᴀ ғᴏʀᴄᴀ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*');
        }
    } catch (e) {
        console.error(e);
        reply('*ᴏᴄᴏʀʀᴇᴜ ᴜᴍ ᴇʀʀᴏ, ᴛᴇɴᴛᴇ ɴᴏᴠᴀᴍᴇɴᴛᴇ ᴍᴀɪs ᴛᴀʀᴅᴇ 🙇‍♂️*');
    }
    break;
    
    case 'jogov':
case 'jogodavelha':
if(!isGroup) return reply(mess.onlyGroup());
if(!menc_jid2) return reply("Marque junto com o comando, o @ do usuário que deseja desafiar..");
joguinhodavelhajs.push(sender)
fs.writeFileSync('./DADOS DO YUTA/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs))
joguinhodavelhajs2.push(from)
fs.writeFileSync('./DADOS DO YUTA/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
if(fs.existsSync(`./ARQUIVES/tictactoe/db/${from}.json`)) {
const boardnow = setGame(`${from}`);
const matrix = boardnow._matrix;
await mention( `*『 🎮 』ᒍOᘜO ᗪᗩ ᐯᗴᒪᕼᗩ『 🕹 』* \n—\n💢 Alguém está jogando o *jogo da velha* no momento! Por favor, aguarde o término da partida para iniciar a próxima.\n—\n• Atualmente está ocorrendo uma disputa entre os jogadores: ''@${boardnow.X} VS @${boardnow.O}'. Quem será que ganha? Tire seus palpites!`)
}
if(argss.length === 1) return reply(`Jogue com alguém, para inicar a partida : ${prefix + command} @membro.`);
const boardnow = setGame(`${from}`);
console.log(colors.red(time, "red"), colors.magenta("[ JOGO DA VELHA ]"), colors.white(`Iniciado - Sessão: ${boardnow.session}`));
boardnow.status = false;
boardnow.X = sender.replace("@s.whatsapp.net", "");
boardnow.O = argss[1].replace("@", "");
var blabord = [`${boardnow.X}`, `${boardnow.O}`]
fs.writeFileSync(`./ARQUIVES/tictactoe/db/${from}.json`,
JSON.stringify(boardnow, null, 2)
);
await mentions( `*『 ⚠ 』ᗴՏᑭᗴᖇᗩᑎᗪO O OᑭOᑎᗴᑎTᗴ『 ⚠ 』* 

• *_「 @${sender.replace("@s.whatsapp.net", "")} 」 Está te convidando para jogar um jogo da velha【 👩🏻‍🦳】_*

• *_『 ${argss[1]}⁩⁩』 Use 『 S 』 pra aceitar 『 N 』 pra rejeitar._*

> Caso queira cancelar use o 『 ${prefix}rv  』`, [sender, menc_jid], true);
break

case 'resetarvelha':
case 'resetavelha':  
case 'resetarv':
case 'resetav': 
case 'resetvelha':
case 'rv': 
if(!isJoguin && !isGroupAdmins) return reply(`Fale com quem iniciou o jogo, só ele pode resetar, ou então algum admin.`)
if(fs.existsSync("./ARQUIVES/tictactoe/db/" + from + ".json")) {
DLT_FL("./ARQUIVES/tictactoe/db/" + from + ".json");
reply(`Jogo da velha resetado com sucesso nesse grupo!`);
joguinhodavelhajs.splice([])
fs.writeFileSync('./DADOS DO YUTA/usuarios/joguinhodavelha.json', JSON.stringify(joguinhodavelhajs))
joguinhodavelhajs2.splice([])
fs.writeFileSync('./DADOS DO YUTA/usuarios/joguinhodavelha2.json', JSON.stringify(joguinhodavelhajs2))
} else {
reply(`Não a nenhuma sessão em andamento...`);
}
break

case 'vord': //Criado do zero Por Nk hackzin
        if(!isGroup) return reply(mess.onlyGroup())
        if(!isModobn) return reply(mess.onlyGroupFun(prefix))
    /** Se não conter "verdade" ou "dessfio" */
    if (q !== "verdade" && q !== "desafio") return reply("• Escolha *verdade* ou *desafio*");
    
    const question = JSON.parse(fs.readFileSync("./DADOS DO YUTA/questions.json"));
    
    if (q == "verdade") {
        const randomQuest = question[0].words[Math.floor(Math.random() * question[0].words.length)];
        reply(`*⸺͟͞ꪶ𝐄 𝐕𝐄𝐑𝐃𝐀𝐃𝐄 𝐐𝐔𝐄↴*\n\n${randomQuest}`);
    }
    else {
        const randomQuest = question[1].words[Math.floor(Math.random() * question[1].words.length)];
        reply(`*⸺͟͞ꪶ𝐃𝐄𝐒𝐀𝐅𝐈𝐎 𝐕𝐎𝐂𝐄↴*\n\n${randomQuest}`);
    }
    break;

//=========== [ FINAL JOGOS ] =========\\

//==========[ EDIT AUDIO/VIDEO/FOTO ] =========\\

case 'imgpraanime': case 'animeia': case 'toanime':
if((isMedia && !info.message.videoMessage || isQuotedImage)) {
post = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
imagem = await downloadContentFromMessage(post, 'image')
base64 = Buffer.from([])
for await(const send of imagem) { base64 = Buffer.concat([base64, send ]) }
reply(`Criando seu avatar, aguarde! Não vai demorar muito amiguinho(a)...️`)
link = await upload(base64)
conv = await fetchJson(`https://delirius-api-oficial.vercel.app/api/toanime?url=${link}`)
await yuta.sendMessage(from, {image: {url: conv.data.comparation}}, {quoted: selo}).catch(async(error) => {
return reply(`Não foi possível criar seu avatar! Por favor, tente com outra imagem!`);
})
} else {
reply('Mencione uma imagem para atribuir o efeito a foto.')
}
break

case 'gtaia': case 'togta': case 'imgpragta':
if((isMedia && !info.message.videoMessage || isQuotedImage)) {
post = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
imagem = await downloadContentFromMessage(post, 'image')
base64 = Buffer.from([])
for await(const send of imagem) { base64 = Buffer.concat([base64, send ]) }
reply(`Criando seu avatar, aguarde! Não vai demorar muito amiguinho(a)...️`)
link = await upload(base64);
dataConvertAndreas = await fetchJson(`https://aemt.me/jadigta?url=${link}`)
await yuta.sendMessage(from, {image: {url: dataConvertAndreas.result}}, {quoted: selo})
.catch(async(error) => {
return reply(`Não foi possível criar seu avatar! Por favor, tente com outra imagem!`);
})
} else {
reply('Mencione uma imagem para atribuir o efeito a foto.')
}
break



case 'tozombie': case 'zombieai': case 'imgprazombie':
if((isMedia && !info.message.videoMessage || isQuotedImage)) {
post = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
imagem = await downloadContentFromMessage(post, 'image')
base64 = Buffer.from([])
for await(const send of imagem) { base64 = Buffer.concat([base64, send ]) }
reply(`Criando seu avatar, aguarde! Não vai demorar muito amiguinho(a)...️`)
link = await upload(base64);
dataConvertZombie = await fetchJson(`https://aemt.me/converter/zombie?url=${link}`);
await yuta.sendMessage(from, {image: {url: dataConvertZombie.url}}, {quoted: selo})
.catch(async(error) => {
return reply(`Não foi possível criar seu avatar! Por favor, tente com outra imagem!`);
})
} else {
reply('Mencione uma imagem para atribuir o efeito a foto.')
}
break

case 'enhance': case 'dehaze': case 'recolor':
if((isMedia && !info.message.videoMessage || isQuotedImage)) {
post = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.imageMessage
imagem = await downloadContentFromMessage(post, 'image')
base64 = Buffer.from([])
for await(const send of imagem) { base64 = Buffer.concat([base64, send])}
data = await vyroEngine(base64, command);
await yuta.sendMessage(from, {image: data}, {quoted: selo}).catch(async(error) => {
return reply(mess.error())
})
} else {
reply('Mencione uma imagem para atribuir o efeito a foto.')
}
break

case 'videocontrario':
case 'reversevid':
if((isMedia && info.message.videoMessage || !isQuotedImage) && !q.length <= 1) { 
reply(mess.wait())
encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
media = rane
ran = getRandom('.mp4')
exec(`ffmpeg -i ${media} -vf reverse -af areverse ${ran}`, async(err) => {
await DLT_FL(media)
if(err) return reply(`Err: ${err}`)
buffer453 = fs.readFileSync(ran)
await yuta.sendMessage(from, {video: buffer453, mimetype: 'video/mp4'}, {quoted: selo})
DLT_FL(ran)
})
} else {
reply("Marque um vídeo..")
}
break 

case 'videolento':
case 'slowvid':  
if((isMedia && info.message.videoMessage || !isQuotedImage) && !q.length <= 1) {
reply(mess.wait()) 
encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
media = rane
ran = getRandom('.mp4')
exec(`ffmpeg -i ${media} -filter_complex "[0:v]setpts=2*PTS[v];[0:a]atempo=0.5[a]" -map "[v]" -map "[a]" ${ran}`, async(err) => {
await DLT_FL(media)
if(err) return reply(`Error: ${err}`)
buffer453 = fs.readFileSync(ran)
await yuta.sendMessage(from, {video: buffer453, mimetype: 'video/mp4'}, {quoted: selo})
await DLT_FL(ran)
})
} else {
reply("Marque um vídeo..")
}
break

case 'videorapido':
case 'fastvid':  
if((isMedia && info.message.videoMessage || !isQuotedImage) && !q.length <= 1) {
reply(mess.wait())
encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
media = rane
ran = getRandom('.mp4')
exec(`ffmpeg -i ${media} -filter_complex "[0:v]setpts=0.5*PTS[v];[0:a]atempo=2[a]" -map "[v]" -map "[a]" ${ran}`, async(err) => {
await DLT_FL(media)
if(err) return reply(`Err: ${err}`)
buffer453 = fs.readFileSync(ran)
await yuta.sendMessage(from, {video: buffer453, mimetype: 'video/mp4'}, {quoted: selo })
await DLT_FL(ran)
})	
} else {
reply("Marque o vídeo..")
}
break

case 'grave2':
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(mess.wait())
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=1.6,asetrate=22100" ${ran}`, async(err, stderr, stdout) => {
await DLT_FL(gem)
if(err) return reply('Ocorreu um erro ao adicionar o *efeito sonoro* no áudio.')
hah = fs.readFileSync(ran)
await yuta.sendMessage(from, {audio: hah, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
await DLT_FL(ran)
})
} else {
reply("Marque o áudio..")
}
break

case 'grave':
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(mess.wait())
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=0.9,asetrate=44100" ${ran}`, async(err, stderr, stdout) => {
await DLT_FL(gem)
if(err) return reply('Ocorreu um erro ao adicionar o *efeito sonoro* no áudio.')
hah = fs.readFileSync(ran)
await yuta.sendMessage(from, {audio: hah, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
await DLT_FL(ran)
})
} else {
reply("Marque o áudio..");
}
break

case 'adolesc':
case 'vozmenino':  
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(mess.wait())
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a atempo=1.06,asetrate=44100*1.25 ${ran}`, async(err, stderr, stdout) => {
await DLT_FL(gem)
if(err) return reply('Ocorreu um erro ao adicionar o *efeito sonoro* no áudio.');
hah = fs.readFileSync(ran)
await yuta.sendMessage(from, {audio: hah, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
await DLT_FL(ran)
})
} else {
reply("Marque o áudio..")
}
break  

case 'tomp3':
if((isMedia && !info.message.imageMessage || isQuotedVideo)) {
post = isQuotedImage ? JSON.parse(JSON.stringify(info).replace('quotedM','m')).message.extendedTextMessage.contextInfo.message.imageMessage : info.message.videoMessage
reply(mess.wait())
encmedia = isQuotedVideo ? info.message.extendedTextMessage.contextInfo.quotedMessage.videoMessage : info.message.videoMessage
rane = getRandom('.'+await getExtension(encmedia.mimetype))
buffimg = await getFileBuffer(encmedia, 'video')
fs.writeFileSync(rane, buffimg)
media = rane 
ran = getRandom('.mp4')
exec(`ffmpeg -i ${media} ${ran}`, async(err) => { 
await DLT_FL(media)
if(err) return reply('Ocorreu uma falha ao fazer a conversão do vídeo para mp3.')
buffer = fs.readFileSync(ran)
await yuta.sendMessage(from, {audio: buffer, mimetype: 'audio/mpeg'}, {quoted: selo})
await DLT_FL(ran)
})
} else {
reply("Marque o vídeo para transformar em áudio por favor...")
}
break

case 'bass3':
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(mess.wait())
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -af equalizer=f=20:width_type=o:width=2:g=15 ${ran}`, async(err, stderr, stdout) => {
await DLT_FL(gem)
if(err) return reply('Ocorreu um erro ao adicionar o *efeito sonoro* no áudio.')
hah = fs.readFileSync(ran)
await yuta.sendMessage(from, {audio: hah, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
await DLT_FL(ran)
})
} else {
reply("Marque o áudio..")
}
break

case 'bass': 
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(mess.wait())
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -af equalizer=f=20:width_type=o:width=2:g=15 ${ran}`, async(err, stderr, stdout) => {
await DLT_FL(gem)
if(err) return reply('Ocorreu um erro ao adicionar o *efeito sonoro* no áudio.')
hah = fs.readFileSync(ran)
await yuta.sendMessage(from, {audio: hah, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
await DLT_FL(ran)
})
} else {
reply("Marque o áudio...")
}
break

case 'bass2': 
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(mess.wait())
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -af equalizer=f=94:width_type=o:width=2:g=30 ${ran}`, async(err, stderr, stdout) => {
await DLT_FL(gem)
if(err) return reply('Ocorreu um erro ao adicionar o *efeito sonoro* no áudio.')
hah = fs.readFileSync(ran)
await yuta.sendMessage(from, {audio: hah, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
await DLT_FL(ran)
})
} else {
reply("Marque o áudio..")
}
break

case 'estourar': 
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(mess.wait());
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -af equalizer=f=90:width_type=o:width=2:g=30 ${ran}`, async(err, stderr, stdout) => {
await DLT_FL(gem)
if(err) return reply('Ocorreu um erro ao adicionar o *efeito sonoro* no áudio.')
hah = fs.readFileSync(ran)
await yuta.sendMessage(from, {audio: hah, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
await DLT_FL(ran)
})
} else {
reply("Marque o áudio..")
}
break

case 'fast':
case 'audiorapido':  
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(mess.wait())
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=0.9,asetrate=95100" ${ran}`, async(err, stderr, stdout) => {
await DLT_FL(gem)
if(err) return reply('Ocorreu um erro ao adicionar o *efeito sonoro* no áudio.')
hah = fs.readFileSync(ran)
await yuta.sendMessage(from, {audio: hah, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
await DLT_FL(ran)
})
} else {
reply("Marque o áudio...");
}
break

case 'esquilo':
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(mess.wait())
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=0.7,asetrate=65100" ${ran}`, async(err, stderr, stdout) => {
DLT_FL(gem)
if(err) return reply('Ocorreu um erro ao adicionar o *efeito sonoro* no áudio.')
hah = fs.readFileSync(ran)
await yuta.sendMessage(from, {audio: hah, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
await DLT_FL(ran)
})
} else {
reply("Marque o áudio...");
}
break

case 'audiolento': 
case 'slow':
if((isMedia && !info.message.imageMessage && !info.message.videoMessage || isQuotedAudio)) {
reply(mess.wait());
muk = isQuotedAudio ? info.message.extendedTextMessage.contextInfo.quotedMessage.audioMessage : info.message.audioMessage
rane = getRandom('.'+await getExtension(muk.mimetype))
buffimg = await getFileBuffer(muk, 'audio')
fs.writeFileSync(rane, buffimg)
gem = rane
ran = getRandom('.mp3')
exec(`ffmpeg -i ${gem} -filter:a "atempo=0.9,asetrate=44100" ${ran}`, async(err, stderr, stdout) => {
DLT_FL(gem)
if(err) return reply('Ocorreu um erro ao adicionar o *efeito sonoro* no áudio.');
hah = fs.readFileSync(ran)
await yuta.sendMessage(from, {audio: hah, mimetype: 'audio/mpeg', ptt:true}, {quoted: selo})
await DLT_FL(ran)
})
} else {
reply("Marque o áudio..")
}
break

//==============[ FIM DAS CASES DE EDIT ]==============\\

//============[ BRINCADEIRAS/JOGOS/RANKS]===============\\

case 'chance':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))  
if(args.length < 1) return reply(`Você precisa digitar da forma correta... Por exemplo: *${prefix}chance* _do jubileu ser gay_`)
await yuta.sendMessage(from, {text: `😵‍💫🌟 - A chance _“${q}”_ é de: *${Math.floor(Math.random() * 100)}%*. Eai, foi o que a probabilidade que esperava jovem?`, mentions: [sender]}, {quoted: selo});
break

case 'comer':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if(!menc_os2 || menc_jid2[1]) return reply('Marque o alvo que você quer botar rebolar pros cria, a mensagem ou o @.')
await yuta.sendMessage(from, {video: {url:`https://telegra.ph/file/d46ff5e2b8f4c5335e362.mp4`}, gifPlayback: true, caption: `Você acabou de comer a(o) *@${menc_os2.split('@')[0]}*`, mentions: [menc_os2]}, {quoted: selo})
break

case 'capinarlote':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if(!menc_os2 || menc_jid2[1]) return reply('Marque o alvo que você quer botar pra capinar um lote, a mensagem ou o @.')
await yuta.sendMessage(from, {video: {url:`https://telegra.ph/file/4682c1b474ce5dee3a48d.mp4`}, gifPlayback: true, caption: `Você acabou de botar o(a) *@${menc_os2.split('@')[0]}* pra capinar um lote`, mentions: [menc_os2]}, {quoted: selo})
break

case 'pgpeito':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if(!menc_os2 || menc_jid2[1]) return reply('Marque o alvo que você quer pegar nos peitinhos, a mensagem ou o @.')
await yuta.sendMessage(from, {video: {url:`https://telegra.ph/file/52d46e2c58318b8cfcacc.mp4`}, gifPlayback: true, caption: `Você acabou de pegar nos peitos do(a) *@${menc_os2.split('@')[0]}*`, mentions: [menc_os2]}, {quoted: selo})
break


case 'pgpau':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if(!menc_os2 || menc_jid2[1]) return reply('Marque o alvo que você quer pegar no pau dele(a), a mensagem ou o @.')
await yuta.sendMessage(from, {video: {url:`https://telegra.ph/file/5073ba8be6b099ed812a7.mp4`}, gifPlayback: true, caption: `Você acabou de pegar no pau do(a) *@${menc_os2.split('@')[0]}*`, mentions: [menc_os2]}, {quoted: selo})
break


case 'pgbunda':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if(!menc_os2 || menc_jid2[1]) return reply('Marque o alvo que desejas ser acariciado, a mensagem ou o @.')
await yuta.sendMessage(from, {video: {url:`https://telegra.ph/file/e62de1e6863c59d284b2e.mp4`}, gifPlayback: true, caption: `Você acabou de pegar na bunda do(a) *@${menc_os2.split('@')[0]}*`, mentions: [menc_os2]}, {quoted: selo})
break

case 'morder':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if(!menc_os2 || menc_jid2[1]) return reply('Marque o alvo que você quer dar uma mordida, a mensagem ou o @.')
await yuta.sendMessage(from, {video: {url:`https://telegra.ph/file/75e4c0273be625a2363ce.mp4`}, gifPlayback: true, caption: `Você acabou de dar uma mordida no(a) *@${menc_os2.split('@')[0]}*`, mentions: [menc_os2]}, {quoted: selo})
break

case 'sentar':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if(!menc_os2 || menc_jid2[1]) return reply('Marque o alvo que você quer dar uma sentadinha, a mensagem ou o @.')
await yuta.sendMessage(from, {video: {url:`https://telegra.ph/file/d695e05443043ff9a254d.mp4`}, gifPlayback: true, caption: `Você acabou de dar uma sentadinha no(a) *@${menc_os2.split('@')[0]}*`, mentions: [menc_os2]}, {quoted: selo})
break

case 'tirarft':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if(!menc_os2 || menc_jid2[1]) return reply('Marque o alvo que você quer tirar a foto, a mensagem ou o @.')
await yuta.sendMessage(from, {video: {url:`https://telegra.ph/file/7193308e3949803132bad.mp4`}, gifPlayback: true, caption: `Você acabou de tirar uma foto do(a) *@${menc_os2.split('@')[0]}*`, mentions: [menc_os2]}, {quoted: selo})
break

case 'estuprar':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if(!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que você quer comer a força, a mensagem ou o @');
await yuta.sendMessage(from, {video: {url: `https://files.catbox.moe/kusu1d.mp4`}, gifPlayback: true, caption: `Ta prr 🔥 *@${menc_os2.split('@')[0]}* Você foi estuprado 😰` , mentions: [menc_os2]}, {quoted: selo})
break

case 'boquete':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if(!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que você quer botar pra mamar, a mensagem ou o @');
await yuta.sendMessage(from, {video: {url: `https://files.catbox.moe/4hvf79.mp4`}, gifPlayback: true, caption: `Eita *@${menc_os2.split('@')[0]}* garganta profunda voce tem 😰` , mentions: [menc_os2]}, {quoted: selo})
break

case 'cagar':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if(!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que você quer botar pra cagar, a mensagem ou o @');
await yuta.sendMessage(from, {video: {url: `https://files.catbox.moe/662vzj.mp4`}, gifPlayback: true, caption: `CARALHOOOOO *@${menc_os2.split('@')[0]}* FAMOSO CAGA TRONCO KAKAKAKAK??? 🤯😳` , mentions: [menc_os2]}, {quoted: selo})
break

case 'cu':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text:`Pesquisando quantos cm de profundidade tem seu bozo @${sender_ou_n.split("@")[0]}, aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yuta.sendMessage(from, {image: {url: `https://files.catbox.moe/x8k6en.jpg`}, caption: `Quantos cm o(a) *@${sender_ou_n.split("@")[0]}* 
tem no bozo ?\n• A chance é de *${random}cm* 😳`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break 


case 'abraco':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if(!menc_os2 || menc_jid2[1]) return reply('Marque o alvo que você quer dar um abraço, a mensagem ou o @.')
await yuta.sendMessage(from, {video: {url:`https://files.catbox.moe/ecw188.mp4`}, gifPlayback: true, caption: `Você acabou de dar um abraço fofo no(a) *@${menc_os2.split('@')[0]}*`, mentions: [menc_os2]}, {quoted: selo})
break

case 'lavarlouca':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if(!menc_os2 || menc_jid2[1]) return reply('Marque o alvo que você quer botar pra lavar a louça, a mensagem ou o @.')
await yuta.sendMessage(from, {video: {url:`https://files.catbox.moe/qptf5k.mp4`}, gifPlayback: true, caption: `Você acabou de botar a(o) *@${menc_os2.split('@')[0]}* pra lavar a louça`, mentions: [menc_os2]}, {quoted: selo})
break

case 'carinho':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if(!menc_os2 || menc_jid2[1]) return reply('Marque o alvo que você quer dar um carinho, a mensagem ou o @.')
await yuta.sendMessage(from, {video: {url:`https://telegra.ph/file/2b6b4f4e38214bd6164ce.mp4`}, gifPlayback: true, caption: `Você acabou de dar um carinho no(a) *@${menc_os2.split('@')[0]}*`, mentions: [menc_os2]}, {quoted: selo})
break

case 'morte': case 'death':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if (args.length == 0) return reply(`Está faltando o nome da pessoa! Por exemplo: ${prefix+command} Victor`)
predea = await axios.get(`https://api.agify.io/?name=${encodeURIComponent(args[0])}`);
if (predea.data.age == null) return reply(`Você inseriu um nome invalido, certifique-se de inserir um sem acentos, emojis, números e outros.`);
await yuta.sendMessage(from, {video: {url: deathcmd}, gifPlayback: true, caption: `Pessoas com este nome citado “${predea.data.name}” tendem a morrer aos ${predea.data.age} anos.`, mentions: [sender]}, {quoted: selo});
break


case "ppt":
if(args.length < 1) return reply(`Você deve digitar ${prefix}ppt pedra, ${prefix}ppt papel ou ${prefix}ppt tesoura`);
ppt = ["pedra", "papel", "tesoura"];
ppy = ppt[Math.floor(Math.random() * ppt.length)];
ppg = Math.floor(Math.random() * 1) + 10
pptb = ppy
if((pptb == "pedra" && args == "papel") ||
(pptb == "papel" && args == "tesoura") ||
(pptb == "tesoura" && args == "pedra")) {
var vit = "vitoria"
} else if((pptb == "pedra" && args == "tesoura") ||
(pptb == "papel" && args == "pedra") ||
(pptb == "tesoura" && args == "papel")) {
var vit = "derrota"
} else if((pptb == "pedra" && args == "pedra") ||
(pptb == "papel" && args == "papel") ||
(pptb == "tesoura" && args == "tesoura")) {
var vit = "empate"
} else if(vit = "undefined") {
return reply(`Você deve digitar ${prefix}ppt pedra, ${prefix}ppt papel ou ${prefix}ppt tesoura`)
}
if(vit == "vitoria") {var tes = "Vitória do jogador"}
if(vit == "derrota") {var tes = "A vitória é do BOT"} 
if(vit == "empate") {var tes = "O jogo terminou em empate"}
reply(`*${NomeDoBot}* jogou ${pptb}, o jogador jogou: ${args} -> *${tes}*`);
break

case 'nazista':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text: `Pesquisando a sua ficha de nazista: *@${sender_ou_n.split("@")[0]}* aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yuta.sendMessage(from, {image: {url: imgnazista}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa nazista?\n• Porcentagem de chance de ser uma pessoa nazista: *${random}%.* `, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break 

case 'gay':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text: `Pesquisando a sua ficha de gay: @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
feio = random; boiola = random
if(boiola < 20 ) {var bo = 'hmm... você é hetero...'} else if(boiola == 21 ) {var bo = '+/- boiola'} else if(boiola == 23 ) {var bo = '+/- boiola'} else if(boiola == 24 ) {var bo = '+/- boiola'} else if(boiola == 25 ) {var bo = '+/- boiola'} else if(boiola == 26 ) {var bo = '+/- boiola'} else if(boiola == 27 ) {var bo = '+/- boiola'} else if(boiola == 2 ) {var bo = '+/- boiola'} else if(boiola == 29 ) {var bo = '+/- boiola'} else if(boiola == 30 ) {var bo = '+/- boiola'} else if(boiola == 31 ) {var bo = 'tenho minha desconfiança...'} else if(boiola == 32 ) {var bo = 'tenho minha desconfiança...'} else if(boiola == 33 ) {var bo = 'tenho minha desconfiança...'} else if(boiola == 34 ) {var bo = 'tenho minha desconfiança...'} else if(boiola == 35 ) {var bo = 'tenho minha desconfiança...'} else if(boiola == 36 ) {var bo = 'tenho minha desconfiança...'} else if(boiola == 37 ) {var bo = 'tenho minha desconfiança...'} else if(boiola == 3 ) {var bo = 'tenho minha desconfiança...'} else if(boiola == 39 ) {var bo = 'tenho minha desconfiança...'} else if(boiola == 40 ) {var bo = 'tenho minha desconfiança...'} else if(boiola == 41 ) {var bo = 'você é né?'} else if(boiola == 42 ) {var bo = 'você é né?'} else if(boiola == 43 ) {var bo = 'você é né?'} else if(boiola == 44 ) {var bo = 'você é né?'} else if(boiola == 45 ) {var bo = 'você é né?'} else if(boiola == 46 ) {var bo = 'você é né?'} else if(boiola == 47 ) {var bo = 'você é né?'} else if(boiola == 4 ) {var bo = 'você é né?'} else if(boiola == 49 ) {var bo = 'você é né?'} else if(boiola == 50 ) {var bo = 'você é ou não?'} else if(boiola > 51) {var bo = 'você é gay...'
}
await yuta.sendMessage(from, {image: {url: imggay}, caption: `Qual é a porcentagem de chance do(a) *@${sender_ou_n.split("@")[0]}* ser gay?\n• *${random}% homossexual*, ${bo}`, mentions: [sender_ou_n], thumbnail:null}, {quoted: selo})
}, 7000)
break

case 'feio':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text: `Pesquisando a sua ficha de feio: *@${sender_ou_n.split("@")[0]}* aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
feio = random
if(feio < 20 ) {var bo = 'É não é feio'} else if(feio == 21 ) {var bo = '+/- feio'} else if(feio == 23 ) {var bo = '+/- feio'} else if(feio == 24 ) {var bo = '+/- feio'} else if(feio == 25 ) {var bo = '+/- feio'} else if(feio == 26 ) {var bo = '+/- feio'} else if(feio == 27 ) {var bo = '+/- feio'} else if(feio == 2 ) {var bo = '+/- feio'} else if(feio == 29 ) {var bo = '+/- feio'} else if(feio == 30 ) {var bo = '+/- feio'} else if(feio == 31 ) {var bo = 'ainda tá na média'} else if(feio == 32 ) {var bo = 'dá pra pegar umas(ns) novinha(o) ainda'} else if(feio == 33 ) {var bo = 'Da pra pegar umas(ns) novinha(o) ainda'} else if(feio == 34 ) {var bo = 'é fein, mas tem baum coração'} else if(feio == 35 ) {var bo = 'tá na média, mas não deixa de ser feii'} else if(feio == 36 ) {var bo = 'bonitin mas é feio com orgulho'} else if(feio == 37 ) {var bo = 'feio e preguiçoso(a), vai se arrumar praga feia'} else if(feio == 3 ) {var bo = 'tenho '} else if(feio == 39 ) {var bo = 'feio, mas um banho e se arrumar, deve resolver'} else if(feio == 40 ) {var bo = 'fein,  mas não existe gente feia, existe gente que não conhece os produtos jequity'} else if(feio == 41 ) {var bo = 'você é Feio, mas é legal, continue assim'} else if(feio == 42 ) {var bo = 'Nada que uma maquiagem e se arrumar, que não resolva.'} else if(feio == 43 ) {var bo = 'Feio que dói de ver, compra uma máscara que melhora'} else if(feio == 44 ) {var bo = 'Feio mas nada que um saco na cabeça não resolva né!?'} else if(feio == 45 ) {var bo = 'você é feio, mas tem bom gosto'} else if(feio == 46 ) {var bo = 'feio mas tem muitos amigos'} else if(feio == 47 ) {var bo = 'é feio mas tem lábia pra pegar várias novinha'} else if(feio == 4 ) {var bo = 'feio e ainda não sabe se vestir, vixi'} else if(feio == 49 ) {var bo = 'feiooo dms vey.'} else if(feio == 50 ) {var bo = 'você é feio, mas não se encherga.'} else if(feio > 51) {var bo = 'você é feio demais bixo.'}
await yuta.sendMessage(from, {image: {url: imgfeio}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa feia?\n• A porcentagem de chance é *${random}%*, ${bo}`, mentions: [sender_ou_n], thumbnail:null}, {quoted: selo})
}, 7000)
break 

case 'corno':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text:`Pesquisando a ficha de corno @${sender_ou_n.split("@")[0]}, aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yuta.sendMessage(from, {image: {url: imgcorno}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa chifruda?\n• A porcentagem de chance é *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

case 'vesgo':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text:`Pesquisando a ficha de vesgo @${sender_ou_n.split("@")[0]}, aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yuta.sendMessage(from, {image: {url: imgvesgo}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa vesga?\n• A porcentagem de chance é *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break 

case 'bebado':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text:`Pesquisando a ficha de bebado(a) @${sender_ou_n.split("@")[0]}, aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yuta.sendMessage(from, {image: {url: imgbebado}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa bêbada?\n• A porcentagem de chance é *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break 

case 'gado':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text:`Pesquisando a ficha de gado @${sender_ou_n.split("@")[0]}, aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yuta.sendMessage(from, {image: {url: imggado}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser um gado?\n• A porcentagem de chance é *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break 

case 'fiel':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text:`Pesquisando a ficha de fiel @${sender_ou_n.split("@")[0]}, aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yuta.sendMessage(from, {image: {url: `https://files.catbox.moe/hwbqmt.webp`}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser fiel?\n• A porcentagem de chance é *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break 

case 'estrupinho':
case 'estuprinho':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text:`Pesquisando a ficha de estuprinho @${sender_ou_n.split("@")[0]}, aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yuta.sendMessage(from, {image: {url: `https://i.ibb.co/RkqpQhwd/1000917234.jpg`}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* é estuprado?\n• A porcentagem é de *${random}% um total estupradinho*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break 

case 'lindo':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text:`Pesquisando a ficha de lindo @${sender_ou_n.split("@")[0]}, aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yuta.sendMessage(from, {image: {url: `https://files.catbox.moe/2r420g.jpg`}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser lindo?\n• A porcentagem de chance é *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break 

case 'linda':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text:`Pesquisando a ficha de linda @${sender_ou_n.split("@")[0]}, aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yuta.sendMessage(from, {image: {url: `https://files.catbox.moe/yb6hpe.jpg`}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser linda?\n• A porcentagem de chance é *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break 

case 'gostoso':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text:`Pesquisando a sua ficha de gostoso @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yuta.sendMessage(from, {image: {url: `https://files.catbox.moe/xkw2bd.jpg`}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa gostosa?\n• A porcentagem de chance é *${random}%*`, gifPlayback: true, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break 


case 'gostosa':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text:`Pesquisando a sua ficha de gostosa @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yuta.sendMessage(from, {image: {url: imggostosa}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa gostosa?\n• A porcentagem de chance é *${random}%*`, gifPlayback: true, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break 

case 'sigma':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text:`Pesquisando a sua ficha de sigma @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yuta.sendMessage(from, {image: {url: imgsigma}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa sigma?\n• A porcentagem de chance é *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

case 'beta':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text:`Pesquisando a sua ficha de beta @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yuta.sendMessage(from, {image: {url: imgbeta}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser um beta?\n• A porcentagem de chance é *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

case 'baiano':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text:`Pesquisando a sua ficha de baiano @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yuta.sendMessage(from, {image: {url: imgbaiano}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa baiana?\n• A porcentagem de chance é *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

case 'baiana':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text:`Pesquisando a sua ficha de baiana @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yuta.sendMessage(from, {image: {url: imgbaiana}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa baiana?\n• A porcentagem de chance é *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

case 'carioca':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text:`Pesquisando a sua ficha de carioca @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yuta.sendMessage(from, {image: {url: imgcarioca}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa carioca?\n• A porcentagem de chance é *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

case 'louco':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text:`Pesquisando a sua ficha de louco @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yuta.sendMessage(from, {image: {url: imglouco}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa louca?\n• A porcentagem de chance é *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

case 'louca':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text:`Pesquisando a sua ficha de louca @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yuta.sendMessage(from, {image: {url: imglouca}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa louca?\n• A porcentagem de chance é *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

case 'safada':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text:`Pesquisando a sua ficha de safada @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yuta.sendMessage(from, {image: {url: imgsafada}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa safada?\n• A porcentagem de chance é *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

case 'safado':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text:`Pesquisando a sua ficha de safado @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yuta.sendMessage(from, {image: {url: imgsafado}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma pessoa safada?\n• A porcentagem de chance é *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

case 'macaco':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text:`Pesquisando a sua ficha de macaco @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yuta.sendMessage(from, {image: {url: imgmacaco}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser um macaco?\n• A porcentagem de chance é *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

case 'macaca':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text:`Pesquisando a sua ficha de macaca @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yuta.sendMessage(from, {image: {url: imgmacaca}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma macaca?\n• A porcentagem de chance é *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

case 'puta':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await yuta.sendMessage(from, {text:`Pesquisando a sua ficha de puta @${sender_ou_n.split("@")[0]} aguarde...`, mentions: [sender_ou_n]}, {quoted: selo})
 setTimeout(async() => {
random = `${Math.floor(Math.random() * 110)}`
await yuta.sendMessage(from, {image: {url: imgputa}, caption: `O quanto *@${sender_ou_n.split("@")[0]}* pode ser uma puta?\n• A porcentagem de chance é *${random}%*`, mentions: [sender_ou_n]}, {quoted: selo})
}, 7000)
break

			
				
case 'matar': case 'mata':  
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if(!menc_os2 || menc_jid2[1]) return reply('marque o alvo que você quer matar, a mensagem ou o @')
yuta.sendMessage(from, {video: {url: `https://files.catbox.moe/z60rt6.mp4`}, gifPlayback: true, caption: `Você acabou de matar o(a) *@${menc_os2.split('@')[0]}*, seu... 😵‍💫💅🏻`, mentions: [menc_os2]}, {quoted: selo})
break 

case 'beijo':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if(!menc_os2 || menc_jid2[1]) return reply('Marque a pessoa que você quer beijar, a mensagem ou o @');
await yuta.sendMessage(from, {video: {url: `https://files.catbox.moe/iwg0hr.mp4`}, gifPlayback: true, caption: `Você acabou de mandar um beijo gostoso para o(a) *@${menc_os2.split('@')[0]}*!` , mentions: [menc_os2]}, {quoted: selo})
break

case 'tapa':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if(!menc_os2 || menc_jid2[1]) return reply('Marque o alvo que você quer da um tapa, a mensagem ou o @.')
await yuta.sendMessage(from, {video: {url: tapacmd}, gifPlayback: true, caption: `Você acabou de da um tapa na raba da *@${menc_os2.split('@')[0]}*. 😼`, mentions: [menc_os2]}, {quoted: selo})
break

case 'soco':
case 'socar':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if(!menc_os2 || menc_jid2[1]) return reply('marque o alvo que você quer da um soco, a mensagem ou o @')
txtkk = [`Ei @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te deu um golpe fatal!`,
    `Atenção @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} acabou de te nocautear!`,
    `Olá @${menc_os2.split('@')[0]}, você foi atingido pelo @${sender.split('@')[0]}!`,
    `Ei @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te derrubou com um soco!`,
    `Aviso @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} acabou de te acertar!`,
    `Oi @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te deu uma surra!`,
    `Atenção @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te deu um golpe forte!`,
    `Olá @${menc_os2.split('@')[0]}, você foi socado pelo @${sender.split('@')[0]}!`,
    `Ei @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te deu uma surra épica!`,
    `Aviso @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} acabou de te derrubar!`,
    `Olá @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te acertou em cheio!`,
    `Atenção @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te deu uma surra incrível!`,
    `Oi @${menc_os2.split('@')[0]}, você levou um golpe de @${sender.split('@')[0]}!`,
    `Ei @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te deu um soco devastador!`,
    `Olá @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} acabou de te derrubar com um soco!`,
    `Aviso @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te deu uma surra monumental!`,
    `Oi @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} acabou de te acertar um soco!`,
    `Atenção @${menc_os2.split('@')[0]}, você levou uma surra do @${sender.split('@')[0]}!`,
    `Ei @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te derrubou com um golpe poderoso!`,
    `Olá @${menc_os2.split('@')[0]}, você foi atingido por um soco de @${sender.split('@')[0]}!`,
    `Olá @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} está te esmurrando!`,
    `Ei @${menc_os2.split('@')[0]}, você está levando uma surra de @${sender.split('@')[0]}!`,
    `Aviso @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} está te golpeando!`,
    `Oi @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te deu uma surra memorável!`,
    `Atenção @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te nocauteou com um soco!`,
    `Olá @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} está te dando um golpe brutal!`,
    `Ei @${menc_os2.split('@')[0]}, você foi atingido fortemente por @${sender.split('@')[0]}!`,
    `Aviso @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te acertou com tudo!`,
    `Oi @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} acabou de te esmagar com um soco!`,
    `Atenção @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te deu um soco implacável!`,
    `Olá @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} está te dando uma surra histórica!`,
    `Ei @${menc_os2.split('@')[0]}, você levou um soco fenomenal de @${sender.split('@')[0]}!`,
    `Aviso @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te deu um golpe formidável!`,
    `Oi @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te acertou um soco arrasador!`,
    `Atenção @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} está te espancando!`,
    `Olá @${menc_os2.split('@')[0]}, você está sendo socado por @${sender.split('@')[0]}!`,
    `Ei @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te deu um soco avassalador!`,
    `Aviso @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te derrubou com um golpe intenso!`,
    `Oi @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te acertou um soco potente!`,
    `Atenção @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} acabou de te nocautear com um soco avassalador!`,
    `Olá @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} está te esmagando com socos!`,
    `Ei @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} acabou de te dar uma surra fenomenal!`,
    `Aviso @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te deu um soco brutal!`,
    `Oi @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} está te esmagando com força!`,
    `Atenção @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te derrubou com um golpe formidável!`,
    `Olá @${menc_os2.split('@')[0]}, você levou uma surra de @${sender.split('@')[0]}!`,
    `Ei @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te acertou um soco destruidor!`,
    `Aviso @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} acabou de te derrubar com um golpe!`,
    `Oi @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} está te espancando sem piedade!`,
    `Atenção @${menc_os2.split('@')[0]}, você foi atingido por um soco poderoso de @${sender.split('@')[0]}!`,
    `Olá @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te deu um golpe fulminante!`,
    `Ei @${menc_os2.split('@')[0]}, você levou um soco brutal de @${sender.split('@')[0]}!`,
    `Aviso @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te acertou um golpe devastador!`,
    `Oi @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} está te esmurrando sem dó!`,
    `Atenção @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te derrubou com um soco poderoso!`,
    `Olá @${menc_os2.split('@')[0]}, você foi atingido com força por @${sender.split('@')[0]}!`,
    `Ei @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te deu um soco esmagador!`,
    `Aviso @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te derrubou com um golpe destruidor!`,
    `Oi @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} acabou de te dar uma surra colossal!`,
    `Atenção @${menc_os2.split('@')[0]}, você levou um soco avassalador de ${sender.split('@')[0]}!`,
    `Olá @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te acertou um soco fenomenal!`,
    `Ei @${menc_os2.split('@')[0]}, você foi atingido por um soco destruidor de ${sender.split('@')[0]}!`,
    `Aviso @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} te deu uma surra fulminante!`,
    `Oi @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} acabou de te nocautear com um soco!`,
    `Atenção @${menc_os2.split('@')[0]}, @${sender.split('@')[0]} está te espancando violentamente!`]
const susp = txtkk[Math.floor(Math.random() * txtkk.length)]
lss = ["https://telegra.ph/file/f737009edab409fe7be43.mp4", "https://telegra.ph/file/608f10571c79cd270684b.mp4", "https://telegra.ph/file/b11cdf32f93712fcd4d78.mp4", "https://telegra.ph/file/72bb4bc30d2d75e2b0b77.mp4", "https://telegra.ph/file/a1f4856876d4cb47fc215.mp4", "https://telegra.ph/file/866708c964801c6af880a.mp4", "https://telegra.ph/file/c917c16f143f4716488ca.mp4", "https://telegra.ph/file/663990556cd3b872b670e.mp4", "https://telegra.ph/file/638e353bcbd343581aa5f.mp4", "https://telegra.ph/file/6770b65c4b7a43840735a.mp4", "https://telegra.ph/file/7172540125b1b5754f12f.mp4", "https://telegra.ph/file/13468fc5ca601483a1c38.mp4", "https://telegra.ph/file/3463d0e205b5d5dc7a075.mp4", "https://telegra.ph/file/4b135cfda8a32f3c6d83c.mp4", "https://telegra.ph/file/4b135cfda8a32f3c6d83c.mp4", "https://telegra.ph/file/6577e0445dd4b3ac15465.mp4", "https://telegra.ph/file/88891992448b401b6763a.mp4"]
randomp = lss[Math.floor(Math.random() * lss.length)]
jrq = await getBuffer(randomp)
await yuta.sendMessage(from, {video: jrq, gifPlayback: true, caption: susp, mentions: [sender, menc_os2]}, {quoted: selo})
break


case 'chute':
case 'chutar':  
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix));
if(!menc_os2 || menc_jid2[1]) return reply('Marque o alvo que você quer da um chute, a mensagem ou o @')
await yuta.sendMessage(from, {video: {url: chutecmd}, gifPlayback: true, caption: `Você acabou de dar um chute em *@${menc_os2.split('@')[0]}*.`, mentions: [menc_os2]}, {quoted: selo})
break 

case 'dogolpe':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if(!menc_os2 || menc_jid2[1]) return reply('Marque a mensagem com o comando ou marque o @ do usuário..')
randomF = ["𝐄𝐌 𝐈𝐋𝐔𝐃𝐈𝐑 𝐏𝐄𝐒𝐒𝐎𝐀𝐒", "𝐄𝐌 𝐅𝐄𝐑𝐈𝐑 𝐎𝐒 𝐒𝐄𝐍𝐓𝐈𝐌𝐄𝐍𝐓𝐎𝐒", "𝐄𝐌 𝐃𝐀𝐑 𝐂𝐇𝐈𝐅𝐑𝐄"]
await yuta.sendMessage(from, {text: `𝐎(𝐀) *@${menc_os2.split("@")[0]}* 𝐄 𝐄𝐒𝐏𝐄𝐂𝐈𝐀𝐋𝐈𝐒𝐓𝐀: ${randomF[Math.floor(Math.random() * randomF.length)]}.`, mentions: [menc_os2]}, {quoted: selo})
break

case 'shipo':
if(!isGroup) return reply(mess.onlyGroup());
if(!isModobn) return reply(mess.onlyGroupFun(prefix));
if(!menc_os2) return reply('Marque uma pessoa do grupo para encontrar o par dela.');
await mention(`『💘』𝐄𝐔 𝐒𝐇𝐈𝐏𝐎:\n@${groupMembers[Math.floor(Math.random() * groupMembers.length)].id.split('@')[0]}\n\n@${menc_os2.split("@")[0]}\n\n𝐂𝐎𝐌 𝐔𝐌𝐀 𝐏𝐎𝐑𝐒𝐄𝐍𝐓𝐀𝐆𝐄𝐌 𝐃𝐄: *${Math.floor(Math.random() * 100)+"%"}*.`);
break

case 'casal':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
await reagir(from, "💘");
var m1= groupMembers[Math.floor(Math.random() * groupMembers.length)].id
var m2= groupMembers[Math.floor(Math.random() * groupMembers.length)].id
try {ppimg = await yuta.profilePictureUrl(m1)} catch(erro) {ppimg = 'https://telegra.ph/file/2fbfa46b4ea3baed434d1.jpg'}
try {ppimg2 = await yuta.profilePictureUrl(m2)} catch(erro) {ppimg2 = 'https://telegra.ph/file/2fbfa46b4ea3baed434d1.jpg'}
p1 = await axios.get(`https://tinyurl.com/api-create.php?url=${ppimg}`)
p2 = await axios.get(`https://tinyurl.com/api-create.php?url=${ppimg2}`)
random = Math.floor(Math.random() * 100)
await yuta.sendMessage(from, {image: {url: `https://files.catbox.moe/gosmx9.jpg`}, caption: `『👩🏼‍❤️‍💋‍👨🏻』- 𝐒𝐈𝐍𝐓𝐎 𝐐𝐔𝐄 𝐄𝐒𝐒𝐄𝐒 𝐃𝐎𝐈𝐒 𝐅𝐎𝐑𝐌𝐀𝐑𝐈𝐀 𝐔𝐌 𝐎𝐓𝐈𝐌𝐎 𝐂𝐀𝐒𝐀𝐋:\n\n『@${m1.split("@")[0]}』\n\n『@${m2.split("@")[0]}』\n\n𝐂𝐎𝐌 𝐔𝐌𝐀 𝐄𝐒𝐏𝐄𝐂𝐓𝐀𝐓𝐈𝐕𝐀 𝐃𝐄:*『${random+"%"}』*`, mentions: [m1, m2]}, {quoted: selo}).catch((error) => {reply(mess.error())})
break

case 'gozar': case 'goza'://by tzn pau de me
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
reagir(from, "😈")
const gozars = ['Você acabou de gozar na boca do(a)','Você acabou de gozar no cuzinho do(a)','Você acabou de gozar na bucetinha do(a)', 'Você acabou de gozar no pé do(a)', 'Você acabou de gozar na cabeça do(a)', 'Você acabou de gozar na cara do(a)', 'Você acabou de gozar na barriga do(a)', 'Você acabou de gozar no olho do(a)', 'Você acabou de gozar na útero do(a)', 'Você acabou de gozar no cabelo do(a)', 'Você acabou de gozar na boca do(a)', 'Você acabou de gozar no umbigo do(a)', 'Você acabou de gozar nas costas do(a)', 'Você acabou de gozar nos braços do(a)', 'Você acabou de gozar na mão do(a)',] 
const gozacao = gozars[Math.floor(Math.random() * gozars.length)];
if(!isGroup) return reply('*sᴏᴍᴇɴᴛᴇ ᴇᴍ ɢʀᴜᴘᴏs 🙇‍♂️*')//tzn modalidades esportivas
if(!menc_os2 || menc_jid2[1]) return reply('*ᴍᴀʀǫᴜᴇ ᴀ ᴘᴇssᴏᴀ ǫᴜᴇ ᴠᴏᴄᴇ ǫᴜᴇʀ ɢᴏᴢᴀʀ 🙈*')
yuta.sendMessage(from, {video: {url: `https://telegra.ph/file/8a82de1e9da332773f52c.mp4`}, gifPlayback: true, caption: `${gozacao} @${menc_os2.split('@')[0]} 🥵
`, mentions: [menc_os2]}, {quoted: selo})
break

case 'wame':
    try {
        let Nk_number = sender.replace('@s.whatsapp.net', '');
        let Nk_message = args.join(' ').replace(/@/g, '').trim(); // Junta os argumentos e remove '@'
        let Nk_cleanMessage = Nk_message.replace(Nk_number, '').trim(); // Remove o próprio número e espaços extras

        if (!Nk_cleanMessage) {
            return reply(`*⏤͟͟͞͞Aqui está o link do seu número do WhatsApp* 🙇‍♂️ ↴\n\n • https://wa.me/${Nk_number}`);
        }

        let Nk_finalLink = `*⏤͟͟͞͞Aqui está o link do seu número do WhatsApp* 🙇‍♂️ ↴\n\n • https://wa.me/${Nk_number}?text=${encodeURIComponent(Nk_cleanMessage)}`;
        reply(Nk_finalLink);
    } catch (e) {
        console.log(e);
        reply('Ocorreu um erro ao gerar o link do WhatsApp.');
    }
    break;


case 'vab': case 'vcprefere': case 'voceprefere':
if(!isGroup) return reply(mess.onlyGroup());
if(!isModobn) return reply(mess.onlyGroupFun(prefix));
await reagir(from, '😸'); /* Reação à mensagem, quando solicitar a execução do comando. */
await psycatgames().then(async(array) => {
    const { nsfw, questions } = array[Math.floor(Math.random() * array.length)];
    const { pergunta1, pergunta2 } = questions[Math.floor(Math.random() * questions.length)];
    await sendPoll(yuta, from, "Você prefere...", [pergunta1, pergunta2]); /* Enviar a enquete com as preferências sorteadas. */
}).catch(async(error) => {
    console.error("Erro ao executar o comando:", error); // Mostra o erro no console
    await replyWithReaction(mess.error(), {react: {text: '😿', key: info.key}});
});
break;

case 'eununca':
if(!isGroup) return reply(mess.onlyGroup());
if(!isModobn) return reply(mess.onlyGroupFun(prefix));
await reagir(from, '🤔'); /* Reação à mensagem, quando solicitar a execução do comando. */
await sendPoll(yuta, from, tools.iNever[Math.floor(Math.random() * tools.iNever.length)], ["Eu nunca", "Eu já"]).catch(async(error) => {
await replyWithReaction(mess.error(), {react: {text: '😭', key: info.key}});
});
break

case 'rankgay': case 'rankgays':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `[🏳️‍🌈]𝐑𝐀𝐍𝐊 𝐃𝐎𝐒 5 𝐌𝐀𝐈𝐒 𝐆𝐀𝐘 𝐃𝐎 𝐆𝐑𝐔𝐏𝐎\n—\n`
for (var i = 0; i < 5; i++) {
ABC += `• ${i+1}°『${Math.floor(Math.random() * 100)}%』- @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n\n`
}
await mencionarIMG(ABC, rnkgay);
break

case 'rankstrup': case 'rankestupri':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `\`TOP 5 ESTUPRADOS DO GRUPO🦹\n—\n`
for (var i = 0; i < 5; i++) {
ABC += `• ${i+1}°『${Math.floor(Math.random() * 100)}%』- @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n\n`
}
await mencionarIMG(ABC, rnkgay);
break

case 'rankcasalzin': case 'rankcasais': case 'rankcasal':
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isModobn) return reply(mess.onlyGroupFun(prefix));
    await reagir(from, "💞");
    
    const membros = groupMembers;
    const casais = [];
    for (let i = 0; i < 10; i++) {
        const casal = membros[Math.floor(Math.random() * membros.length)];
        if (casal && !casais.includes(casal)) {
            casais.push(casal);
        }
    }

    const casaisTEXT = [
        "Esses 2 aqui se pega no sigilo 👀", 
        "Eita eita, esses aqui amam se pegar nos escurinho 🤭", 
        "Ainnn, esses aqui então, vou nem falar nada...😶", 
        "O par mais perfeito da história 💋", 
        "Esses 2 brigam muito, porém no off tão de sapecagens 😈", 
        "Esses 2 aqui... RUMMMM 😳", 
        "Esses amam ficar indo gf 🥶", 
        "Esses 2 aqui, muitos safadinhus 😏", 
        "Esses aqui, vou falar a verdade, um deles trai o outro....😨", 
        "Pior casal do mundo, mas na hora H...🤤", 
        "Amo esse casal, ele é muito fofoooo 💞"
    ];

    const rankzincasalzinimg = "https://files.catbox.moe/0b8878.jpg";
    
    let rankzincasalzin = `『 ❣ 』𝐑𝐀𝐍𝐊 𝐂𝐀𝐒𝐀𝐈𝐒 𝐃𝐎 𝐂𝐇𝐀𝐓︎ \n\n`;

    for (let i = 0; i < casais.length; i += 2) {
        if (casais[i + 1]) {
            rankzincasalzin += `@${casais[i].id.split('@')[0]} e @${casais[i + 1].id.split('@')[0]}\n${casaisTEXT[Math.floor(Math.random() * casaisTEXT.length)]}\n\n`;
        }
    }

    rankzincasalzin += `${NomeDoBot}`;
    
    mencionarIMG(rankzincasalzin, rankzincasalzinimg);
    break;

case 'rankfalido': case 'rankfalidos':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
var porcentagem = `${Math.floor(Math.random() * 105)}`
membr = []
const falido1 = groupMembers
const falido2 = groupMembers
const falido3 = groupMembers
const falido4 = groupMembers
const falido5 = groupMembers
var porcent61 = porcentagem[Math.floor(Math.random() * porcentagem.length)] 
var porcent62 = porcentagem[Math.floor(Math.random() * porcentagem.length)]
var porcent63 = porcentagem[Math.floor(Math.random() * porcentagem.length)]
var porcent64 = porcentagem[Math.floor(Math.random() * porcentagem.length)]
var porcent65 = porcentagem[Math.floor(Math.random() * porcentagem.length)] 
const falidos1 = falido1[Math.floor(Math.random() * falido1.length)]
const falidos2 = falido2[Math.floor(Math.random() * falido2.length)]
const falidos3 = falido3[Math.floor(Math.random() * falido3.length)]
const falidos4 = falido4[Math.floor(Math.random() * falido4.length)]
const falidos5 = falido5[Math.floor(Math.random() * falido5.length)]
FALIDOTEXT = [
  "Falido total. 💸",
  "Mestre do prejuízo. 📉",
  "Falência fashion. 👗",
  "Falido épico. saga 💸",
  "Mestre da ruína. ⚡",
  "Falido cósmico, deve até ⭐",
  "Estrategista da falência. 📉🤔",
  "Falido magnífico. ✨",
  "Mestre das dívidas. ⚡",
  "Falência quântica. 🔍💸",
  "Mestre dos boletos. 🧾",
  "Falido moderno. 💻",
  "Especialista em dívidas. 🏦",
  "Falência clássica. 🎻",
  "Mestre do saldo negativo. 📉💳",
  "Falido intergaláctico. 🌌",
  "Estrategista financeiro da decadência. 💹📉",
  "Mestre dos débitos. 💳",
  "Falência holográfica. 🔄💸",
  "Falido contemporâneo. 🏙️"
]; 
rnkfalido = 'https://telegra.ph/file/aab2f61b9629ea40e2120.jpg'
rankzinfalido = `*『 _Falidos 🗑️ no grupo:_ 』*
╔═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╗
║𖣴⋗ 🗑️ @${falidos1.id.split('@')[0]}
║ ${FALIDOTEXT[Math.floor(Math.random() * FALIDOTEXT.length)]}
║𖣴⋗ 🗑️ @${falidos2.id.split('@')[0]}
║ ${FALIDOTEXT[Math.floor(Math.random() * FALIDOTEXT.length)]}
║𖣴⋗🗑️ @${falidos3.id.split('@')[0]}
║ ${FALIDOTEXT[Math.floor(Math.random() * FALIDOTEXT.length)]}
║𖣴⋗🗑️ @${falidos4.id.split('@')[0]}
║ ${FALIDOTEXT[Math.floor(Math.random() * FALIDOTEXT.length)]}
║𖣴⋗ 🗑️ @${falidos5.id.split('@')[0]}
║ ${FALIDOTEXT[Math.floor(Math.random() * FALIDOTEXT.length)]}
╚═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╝`;
membr.push(falidos1.id)
membr.push(falidos2.id)
membr.push(falidos3.id)
membr.push(falidos4.id)
membr.push(falidos5.id)
mencionarIMG(rankzinfalido, rnkfalido);
break; 

case 'rankcu':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
membr = []
const cu1 = groupMembers
const cu2 = groupMembers
const cu3 = groupMembers
const cu4 = groupMembers
const cu5 = groupMembers
const xzcs1 = cu1[Math.floor(Math.random() * cu1.length)]
const xzcs2 = cu2[Math.floor(Math.random() * cu2.length)]
const xzcs3 = cu3[Math.floor(Math.random() * cu3.length)]
const xzcs4 = cu4[Math.floor(Math.random() * cu4.length)]
const xzcs5 = cu5[Math.floor(Math.random() * cu5.length)]
var cuzxzc1 = ["NAO DEU NADA🥲", `DEU SO A BCT`, `GOSTOSO (A) JA DEU O CU`,  `JA VIROU MARMITA`, `DEU TUDO`, `DEU O CU E A BCT`]
var cuzxzc2 = ["NAO DEU NADA🥲", `DEU SO A BCT`, `GOSTOSO (A) JA DEU O CU`,  `JA VIROU MARMITA`, `DEU TUDO`, `DEU O CU E A BCT`]
var cuzxzc3 = ["NAO DEU NADA🥲", `DEU SO A BCT`, `GOSTOSO (A) JA DEU O CU`,  `JA VIROU MARMITA`, `DEU TUDO`, `DEU O CU E A BCT`]
var cuzxzc4 = ["NAO DEU NADA🥲", `DEU SO A BCT`, `GOSTOSO (A) JA DEU O CU`,  `JA VIROU MARMITA`, `DEU TUDO`, `DEU O CU E A BCT`]
var cuzxzc5 = ["NAO DEU NADA🥲", `DEU SO A BCT`, `GOSTOSO (A) JA DEU O CU`,  `JA VIROU MARMITA`, `DEU TUDO`, `DEU O CU E A BCT`]
const cuz1 = cuzxzc1[Math.floor(Math.random() * cuzxzc1.length)]
const cuz2 = cuzxzc2[Math.floor(Math.random() * cuzxzc2.length)]
const cuz3 = cuzxzc3[Math.floor(Math.random() * cuzxzc3.length)]
const cuz4 = cuzxzc4[Math.floor(Math.random() * cuzxzc4.length)]
const cuz5 = cuzxzc5[Math.floor(Math.random() * cuzxzc5.length)]
pdr = `𝐸𝑆𝑆𝐸𝑆 𝑆𝐴𝑂 𝑂𝑆 𝐶𝐴𝑅𝐴 𝑄𝑈𝐸 𝑀𝐴𝐼𝑆 𝐷𝐴𝑂 𝑂 𝐶𝑈 𝑁𝑂 𝐺𝑅𝑈𝑃𝑂:\n${groupName}\n\n@${xzcs1.id.split('@')[0]}\n${cuz1}\n\n@${xzcs2.id.split('@')[0]}\n${cuz2}\n\n@${xzcs3.id.split('@')[0]}\n${cuz3}\n\n@${xzcs4.id.split('@')[0]}\n${cuz4}\n\n@${xzcs5.id.split('@')[0]}\n${cuz5}\n\n ${NomeDoBot}`
membr.push(xzcs1.id)
membr.push(xzcs2.id)
membr.push(xzcs3.id)
membr.push(xzcs4.id)
membr.push(xzcs5.id)
mentions(pdr, membr, true)
break

case 'rankbct': case 'rankbuceta': case 'rankbucetudas':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
 var porcentagem = `${Math.floor(Math.random() * 105)}`;
 membr = [];
 
 const buceta1 = groupMembers;
 const buceta2 = groupMembers;
 const buceta3 = groupMembers;
 const buceta4 = groupMembers;
 const buceta5 = groupMembers;

 var porcent = porcentagem[Math.floor(Math.random() * porcentagem.length)];
 var porcent2 = porcentagem[Math.floor(Math.random() * porcentagem.length)];
 var porcent3 = porcentagem[Math.floor(Math.random() * porcentagem.length)];
 var porcent4 = porcentagem[Math.floor(Math.random() * porcentagem.length)];
 var porcent5 = porcentagem[Math.floor(Math.random() * porcentagem.length)];

 const bucetas1 = buceta1[Math.floor(Math.random() * buceta1.length)];
 const bucetas2 = buceta2[Math.floor(Math.random() * buceta2.length)];
 const bucetas3 = buceta3[Math.floor(Math.random() * buceta3.length)];
 const bucetas4 = buceta4[Math.floor(Math.random() * buceta4.length)];
 const bucetas5 = buceta5[Math.floor(Math.random() * buceta5.length)];

 const TMPBCT = [
 "Buceta rosinha, parece que menstrua danone! 🫣",
 "Buceta mó preta, parece o sufaco das minhas primas. 🤐",
 "Mó bucetão, parece da Elisa Shances. 😈",
 "Bct lisinha, parece eu sem dinheiro. 🥲",
 "Deliciosa, porém parece a mata atlântica. 🌼",
 "Deliciosa e macia. 🥰",
 "Pior que o correio, só pacote. 😏",
 "Provoca até nos sonhos. 🤤",
 "Sonho de qualquer homem. 😜",
 "Quem é Mia Khalifa perto de você?. 😉",
 "Se essa é a porta do paraíso, eu queria ser a chave. 😍",
 ];
 rankzinbucetaimg = "https://files.catbox.moe/j53cob.jpg"
 rankzinbuceta = `*『 _Essas são as mais bucetudas 🤤 do grupo:_ 』*

 😈 @${bucetas1.id.split('@')[0]}
 ${TMPBCT[Math.floor(Math.random() * TMPBCT.length)]}

 😈 @${bucetas2.id.split('@')[0]}
 ${TMPBCT[Math.floor(Math.random() * TMPBCT.length)]}

 😈 @${bucetas3.id.split('@')[0]}
 ${TMPBCT[Math.floor(Math.random() * TMPBCT.length)]}

 😈 @${bucetas4.id.split('@')[0]}
 ${TMPBCT[Math.floor(Math.random() * TMPBCT.length)]}

 😈 @${bucetas5.id.split('@')[0]}
 ${TMPBCT[Math.floor(Math.random() * TMPBCT.length)]}`;
 
 membr.push(bucetas1.id);
 membr.push(bucetas2.id);
 membr.push(bucetas3.id);
 membr.push(bucetas4.id);
 membr.push(bucetas5.id);
 
 mencionarIMG(rankzinbuceta, rankzinbucetaimg);
 break

case 'rankgado': case 'rankgados':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `𝐓𝐎𝐏 5 𝐌𝐀𝐈𝐒 𝐆𝐀𝐃𝐎𝐒 𝐃𝐎 𝐆𝐑𝐔𝐏𝐎\n—\n`
for (var i = 0; i < 5; i++) {
ABC += `• ${i+1}°『${Math.floor(Math.random() * 100)}%』@${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n\n`
}
await mencionarIMG(ABC, rnkgado);
break

case 'rankcorno': case 'rankcornos':
if(!isGroup) return reply(mess.onlyGroup());
if(!isModobn) return reply(mess.onlyGroupFun(prefix));
ABC = `🐂 𝐓𝐎𝐏 5 𝐌𝐀𝐈𝐒 𝐂𝐇𝐈𝐅𝐑𝐔𝐃𝐎𝐒 𝐃𝐎 𝐆𝐑𝐔𝐏𝐎\n—\n`
for (var i = 0; i < 5; i++) {
ABC += `• ${i+1}° 『${Math.floor(Math.random() * 100)}%』 - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n\n`
}
await mencionarIMG(ABC, rnkcorno);
break

case 'surubao': case 'suruba':
await reagir(from, "😈")
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
if (!q) return reply(`Eita, coloque o número de pessoas após o comando.`)
if (Number(q) > 1000) return reply("Coloque um número menor, ou seja, abaixo de *1000*.")
frasekk = [`tá querendo relações sexuais a ${q}, topa?`, `quer que *${q}* pessoas venham de *chicote, algema e corda de alpinista*.`, `quer que ${q} pessoas der tapa na cara, lhe chame de cachorra e fud3r bem gostosinho...`]
context = frasekk[Math.floor(Math.random() * frasekk.length)]  
ABC = `😝 @${sender.split('@')[0]} ${context}\n\n`
for (var i = 0; i < q; i++) {
ABC += `@${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n`
}
await mention(ABC);
break

case 'rankgostosos': case 'rankgostoso':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `🔥 𝐑𝐀𝐍𝐊 𝐃𝐎𝐒 5 𝐌𝐀𝐈𝐒 𝐆𝐎𝐒𝐓𝐎𝐒𝐎𝐒 𝐃𝐎 𝐆𝐑𝐔𝐏𝐎\n—\n`
for (var i = 0; i < 5; i++) {
ABC += `• ${i+1}°『${Math.floor(Math.random() * 100)}%』- @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n\n`
}
await mencionarIMG(ABC, rnkgostoso);
break

case 'rankgostosas': case 'rankgostosa':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `😏 𝐑𝐀𝐍𝐊 𝐃𝐀𝐒 5 𝐌𝐀𝐈𝐒 𝐆𝐎𝐒𝐓𝐎𝐒𝐀𝐒 𝐃𝐎 𝐆𝐑𝐔𝐏𝐎\n—\n`
for (var i = 0; i < 5; i++) {
ABC += `• ${i+1}° 『${Math.floor(Math.random() * 100)}%』 - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n\n`
}
await mencionarIMG(ABC, rnkgostosa);
break

case 'ranknazista': case 'ranknazistas':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `💂‍♂𝐑𝐀𝐍𝐊 𝐃𝐎𝐒 5 𝐌𝐀𝐈𝐒 𝐍𝐀𝐙𝐈𝐒𝐓𝐀 𝐃𝐎 𝐆𝐑𝐔𝐏𝐎 卐\n—\n`
for (var i = 0; i < 5; i++) {
ABC += `• ${i+1}° 『${Math.floor(Math.random() * 100)}%』 - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n\n`
}
await mencionarIMG(ABC, rnknazista);
break

case 'rankotaku': case 'rankotakus':
if(!isGroup) return reply(mess.onlyGroup());
if(!isModobn) return reply(mess.onlyGroupFun(prefix));
ABC = `㊙ 𝐑𝐀𝐍𝐊 𝐃𝐎𝐒 5 𝐌𝐀𝐈𝐒 𝐎𝐓𝐀𝐊𝐔𝐒 𝐃𝐎 𝐆𝐑𝐔𝐏𝐎 \n—\n`
for (var i = 0; i < 5; i++) {
ABC += `• ${i+1}° 『${Math.floor(Math.random() * 100)}%』 - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n\n`
}
await mencionarIMG(ABC, rnkotaku);
break

case 'ranksigma': case 'ranksigmas':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `🗿🍷 𝐑𝐀𝐍𝐊 𝐃𝐎𝐒 5 𝐌𝐀𝐈𝐒 𝐒𝐈𝐆𝐌𝐀𝐒 𝐃𝐎 𝐆𝐑𝐔𝐏𝐎\n\n`
for (var i = 0; i < 5; i++) {
ABC += `• ${i+1}° 『${Math.floor(Math.random() * 100)}%』 - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n\n`
}
await mencionarIMG(ABC, rnksigma);
break;

case 'rankbeta': case 'rankbetas':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `😂 𝐑𝐀𝐍𝐊 𝐃𝐎𝐒 5 𝐌𝐀𝐈𝐒 𝐁𝐄𝐓𝐀𝐒 𝐃𝐎 𝐆𝐑𝐔𝐏𝐎\n\n`
for (var i = 0; i < 5; i++) {
ABC += `• ${i+1}° 『${Math.floor(Math.random() * 100)}%』 - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n\n`
}
await mencionarIMG(ABC, rnkbeta);
break;

case 'rankbaiano': case 'rankbaianos':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `💤 𝐑𝐀𝐍𝐊 𝐃𝐎𝐒 5 𝐌𝐀𝐈𝐒 𝐁𝐀𝐈𝐀𝐍𝐎𝐒 𝐃𝐎 𝐆𝐑𝐔𝐏𝐎\n\n`
for (var i = 0; i < 5; i++) {
ABC += `• ${i+1}° 『${Math.floor(Math.random() * 100)}%』 - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n\n`
}
await mencionarIMG(ABC, rnkbaiano);
break;

case 'rankbaiana': case 'rankbaianas':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `😴 𝐑𝐀𝐍𝐊 𝐃𝐀𝐒 5 𝐌𝐀𝐈𝐒 𝐁𝐀𝐈𝐀𝐍𝐀𝐒 𝐃𝐎 𝐆𝐑𝐔𝐏𝐎\n\n`
for (var i = 0; i < 5; i++) {
ABC += `• ${i+1}° 『${Math.floor(Math.random() * 100)}%』 - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n\n`
}
await mencionarIMG(ABC, rnkbaiana);
break;

case 'rankcarioca': case 'rankcariocas':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `🔫 𝐑𝐀𝐍𝐊 𝐃𝐎𝐒 5 𝐌𝐀𝐈𝐒 𝐂𝐀𝐑𝐈𝐎𝐂𝐀𝐒 𝐃𝐎 𝐆𝐑𝐔𝐏𝐎\n\n`
for (var i = 0; i < 5; i++) {
ABC += `• ${i+1}° 『${Math.floor(Math.random() * 100)}%』 - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n\n`
}
await mencionarIMG(ABC, rnkcarioca);
break;

case 'ranklouco': case 'rankloucos':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `💀 𝐑𝐀𝐍𝐊 𝐃𝐎𝐒 5 𝐌𝐀𝐈𝐒 𝐋𝐎𝐔𝐂𝐎𝐒 𝐃𝐎 𝐆𝐑𝐔𝐏𝐎\n\n`
for (var i = 0; i < 5; i++) {
ABC += `• ${i+1}° 『${Math.floor(Math.random() * 100)}%』 - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n\n`
}
await mencionarIMG(ABC, rnklouco);
break;

case 'ranklouca': case 'rankloucas':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `💀 𝐑𝐀𝐍𝐊 𝐃𝐀𝐒 5 𝐌𝐀𝐈𝐒 𝐋𝐎𝐔𝐂𝐀𝐒 𝐃𝐎 𝐆𝐑𝐔𝐏𝐎\n\n`
for (var i = 0; i < 5; i++) {
ABC += `• ${i+1}° 『${Math.floor(Math.random() * 100)}%』 - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n\n`
}
await mencionarIMG(ABC, rnklouca);
break;

case 'ranksafada': case 'ranksafadas':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `🔥 𝐑𝐀𝐍𝐊 𝐃𝐀𝐒 5 𝐌𝐀𝐈𝐒 𝐒𝐀𝐅𝐀𝐃𝐈𝐍𝐇𝐀𝐒 𝐃𝐎 𝐆𝐑𝐔𝐏𝐎\n\n`
for (var i = 0; i < 5; i++) {
ABC += `• ${i+1}° 『${Math.floor(Math.random() * 100)}%』 - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n\n`
}
await mencionarIMG(ABC, rnksafada);
break;

case 'ranksafado': case 'ranksafados':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `𝐑𝐀𝐍𝐊 𝐃𝐎𝐒 5 𝐌𝐀𝐈𝐒 𝐒𝐀𝐅𝐀𝐃𝐈𝐍𝐇𝐎𝐒 𝐃𝐎 𝐆𝐑𝐔𝐏𝐎🥵\n\n`
for (var i = 0; i < 5; i++) {
ABC += `• ${i+1}° 『${Math.floor(Math.random() * 100)}%』 - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n\n`
}
await mencionarIMG(ABC, rnksafado);
break;

case 'rankmacaco': case 'rankmacacos':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `🐒 𝐑𝐀𝐍𝐊 𝐃𝐎𝐒 5 𝐌𝐀𝐈𝐒 𝐌𝐀𝐂𝐀𝐂𝐎𝐒 𝐃𝐎 𝐆𝐑𝐔𝐏𝐎\n\n`
for (var i = 0; i < 5; i++) {
ABC += `• ${i+1}° 『${Math.floor(Math.random() * 100)}%』 - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n\n`
}
await mencionarIMG(ABC, rnkmacaco);
break;

case 'rankmacaca': case 'rankmacacas':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `🙈 𝐑𝐀𝐍𝐊 𝐃𝐀𝐒 5 𝐌𝐀𝐈𝐒 𝐌𝐀𝐂𝐀𝐂𝐀𝐒 𝐃𝐎 𝐆𝐑𝐔𝐏𝐎 \n\n`
for (var i = 0; i < 5; i++) {
ABC += `• ${i+1}° 『${Math.floor(Math.random() * 100)}%』 - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n\n`
}
await mencionarIMG(ABC, rnkmacaca);
break;

case 'rankputa': case 'rankputas':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `🔞 𝐑𝐀𝐍𝐊 𝐃𝐀𝐒 5 𝐌𝐀𝐈𝐒 𝐏𝐔𝐓𝐀 𝐃𝐎 𝐆𝐑𝐔𝐏𝐎\n\n`
for (var i = 0; i < 5; i++) {
ABC += `• ${i+1}° 『${Math.floor(Math.random() * 100)}%』 - @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n\n`
}
await mencionarIMG(ABC, rnkputa);
break;

case 'rankpau':
if(!isGroup) return reply(mess.onlyGroup())
if(!isModobn) return reply(mess.onlyGroupFun(prefix))
ABC = `𝐑𝐀𝐍𝐊 𝐃𝐎𝐒 5 𝐌𝐀𝐈𝐎𝐑𝐄𝐒 𝐏𝐀𝐔 𝐃𝐎 𝐆𝐑𝐔𝐏𝐎\n—\n`
for (var i = 0; i < 5; i++) {
ABC += `• *${i+1}°* @${somembros[Math.floor(Math.random() * somembros.length)].split("@")[0]}\n\n`
}
await mencionarIMG(ABC, rnkpau);
break

//===========[ FIM JOGOS/BRINCADEIRAS/RANKS=========\\

//==============[ RANK ATIVO E INATIVO ]===========\\

case 'atividade':
case 'atividades':
try{
if(!isGroupAdmins && !issupre && !ischyt) return reply(mess.onlyAdmins())
if(isGroup && JSON.stringify(countMessage).includes(from)) {
var i6 = countMessage.map(i => i.groupId).indexOf(from)
if(countMessage[i6].numbers.length == 0) return
teks = `╔═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╗
║➪ 𝐀𝐓𝐈𝐕𝐈𝐃𝐀𝐃𝐄𝐒 𝐃𝐎𝐒 𝐔𝐒𝐄𝐑 🩸︎ 
╚═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╝\n\n`
for(i = 0; i < countMessage[i6].numbers.length; i++) {
var i8 = countMessage[i6].numbers.map(i => i.id).indexOf(countMessage[i6].numbers[i].id)  
var uscnt = countMessage[i6].numbers[i]
teks += `╔═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╗
║𖣴⋗ ᴜsᴜᴀʀɪᴏ - @${uscnt.id.split('@')[0]}
║𖣴⋗ ᴄᴏɴᴇᴄᴛᴀᴅᴏ ᴇᴍ - ${uscnt.aparelho}
║𖣴⋗ ᴍᴇɴsᴀɢᴇɴs - ${uscnt.messages}
║𖣴⋗ ᴄᴏᴍᴀɴᴅᴏs - ${uscnt.cmd_messages}
║𖣴⋗ ғɪɢᴜʀɪɴʜᴀs - ${uscnt.figus}
╚═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╝\n\n`
}
await mention(teks)
} else return reply('*Nada foi encontrado*')
} catch(error) {
console.log(error)
}
break


case 'rankativos': 
case 'rankativo':   
if(!isGroup) return reply(mess.onlyGroup())
var i3 = countMessage.map(i => i.groupId).indexOf(from)
var blue = countMessage[i3].numbers.map(i => i)
blue.sort((a, b) => ((a.figus == undefined ? a.figus = 0 : a.figus + a.messages + a.cmd_messages) < (b.figus == undefined ? b.figus = 0 : b.figus + b.cmd_messages + b.messages)) ? 0 : -1)
menc = [] 
blad = `╔═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╗
║➪ 𝐑𝐀𝐍𝐊 𝐀𝐓𝐈𝐕𝐎𝐒 𝐃𝐎 𝐂𝐇𝐀𝐓 ☕︎ 
╚═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╝ \n\n`
for ( i = 0; i < (blue.length < 5 ? blue.length : 5); i++) {
if (i != null) blad += `『 ${i + 1}º 』↴ 
╔═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╗
║𖣴⋗ ᴜsᴜᴀʀɪᴏ - @${blue[i].id.split('@')[0]}
║𖣴⋗ ᴄᴏɴᴇᴄᴛᴀᴅᴏ ᴇᴍ - ${blue[i].aparelho}
║𖣴⋗ ᴍᴇɴsᴀɢᴇɴs - ${blue[i].messages}
║𖣴⋗ ᴄᴏᴍᴀɴᴅᴏs - ${blue[i].cmd_messages}
║𖣴⋗ ғɪɢᴜʀɪɴʜᴀs - ${blue[i].figus}
╚═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╝\n\n`
menc.push(blue[i].id)
}
await mentions(blad, menc, true)
break

case 'inativos':
case 'inativo':  
    if(!isGroup) return reply(mess.onlyGroup());
    if(!isGroupAdmins) return reply(mess.onlyAdmins());
    if(q.match(/[a-z]/i) || !q) return reply(`Exemplo: ${prefix+command} 0\nIsso mostrará quantas pessoas tem 0 mensagens no grupo, e se usar 5, vai mostrar quantos usuários tem 5 mensagens ou menos..`);
    
    await ClearMembersInactive();
    var i2 = countMessage?.map(x => x.groupId)?.indexOf(from);
    blue = [];
    
    for (let i of countMessage[i2].numbers) {
        if(i.messages <= Number(q.trim()) &&
           i.figus <= Number(q.trim()) &&
           i.cmd_messages <= Number(q.trim()) &&
           !groupAdmins.includes(i.id) &&
           !numerodono.includes(i.id) &&
           i.id != botNumber &&
           groupMembers.map(i => i.id).includes(i.id)) {
            blue.push(i.id);
        }
    }
    
    for (let i of countMessage[i2].numbers) {
        if(!groupMembers.map(i => i.id).includes(i.id) && i.id.length > 5) {
            blue.push(i.id);
        }
    }
    
    if(blue.length == 0) return reply(`Não tem pessoas com ${q} mensagens..`);
    
    let bli = `Usuários com *${q.trim()}* mensagem(ns) pra baixo estão listados abaixo, verifique:\n–\n`;
    for (let ac = 0; ac < blue.length; ac++) {
        bli += `*${ac+1}.* @${blue[ac].split("@")[0]}\n`;
    }
    await mention(bli);
    break; 
    
    case 'rankinativo':
case 'rankinativos':
    if(!isGroup) return reply(mess.onlyGroup());
    if(!isGroupAdmins) return reply(mess.onlyAdmins());
    
    await ClearMembersInactive();
    let bule = [];
    let mentioned_jid = [];
    
    for(let cag of countMessage[ind].numbers) {
        if(cag.messages <= 1) {
            bule.push(cag);
            mentioned_jid.push(cag.id);
        }
    }
    
    bule.sort((a, b) => (b.messages + b.cmd_messages) - (a.messages + a.cmd_messages));
    let boardi = `╔═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╗\n║➪ 𝐑𝐀𝐍𝐊 𝐈𝐍𝐀𝐓𝐈𝐕𝐎𝐒 𝐃𝐎 𝐂𝐇𝐀𝐓 ☕︎ \n╚═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╝ \n\n`;
    
    if(bule.length == 0) boardi += 'ɴᴀᴏ ᴛᴇᴍ ɴᴇɴʜᴜᴍ ɪɴᴀᴛɪᴠᴏ ɴᴏ ᴄʜᴀᴛ️';
    
    for (let i = 0; i < (bule.length < 5 ? bule.length : 5); i++) {
        boardi += `『 ${i + 1}º 』↴ \n╔═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╗\n║𖣴⋗ ᴜsᴜᴀʀɪᴏ - @${bule[i].id.split('@')[0]}\n║𖣴⋗ ᴄᴏɴᴇᴄᴛᴀᴅᴏ ᴇᴍ - ${bule[i].aparelho}\n║𖣴⋗ ᴍᴇɴsᴀɢᴇɴs - ${bule[i].messages}\n║𖣴⋗ ᴄᴏᴍᴀɴᴅᴏs - ${bule[i].cmd_messages}\n║𖣴⋗ ғɪɢᴜʀɪɴʜᴀs - ${bule[i].aparelho}\n╚═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╝\n\n`;
    }
    
    await mentions(boardi, mentioned_jid, true);
    break;



case 'check':
case 'checkativo':
if(!isGroup) return reply(mess.onlyGroup())
if(groupIdscount.indexOf(from) < 0) return reply('O bot não tem ainda dados sobre o grupo')
var ind = groupIdscount.indexOf(from)
if(!menc_os2 || menc_jid2[1]) return reply('Marque o @ de quem deseja puxar a atividade / Só pode um por vez..')
if(numbersIds.indexOf(menc_os2) >= 0) {
var indnum = numbersIds.indexOf(menc_os2)
var RSM_CN = countMessage[ind].numbers[indnum]
await mentions(`『𝐂𝐇𝐄𝐂𝐊 𝐀𝐓𝐈𝐕𝐎』↴ 
╔═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╗
║𖣴⋗ ᴜsᴜᴀʀɪᴏ - @${menc_os2.split('@')[0]}
║𖣴⋗ ᴄᴏɴᴇᴄᴛᴀᴅᴏ ᴇᴍ - ${RSM_CN.aparelho}
║𖣴⋗ ᴍᴇɴsᴀɢᴇɴs - ${RSM_CN.messages}
║𖣴⋗ ᴄᴏᴍᴀɴᴅᴏs - ${RSM_CN.cmd_messages}
║𖣴⋗ ғɪɢᴜʀɪɴʜᴀs - ${RSM_CN.figus}
╚═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╝\n\n`, [menc_os2], true)
} else {
await mentions(`Não tenho nenhuma informação no grupo sobre o *@${menc_os2.split('@')[0]}*.`, [menc_os2], true)
}
break

case 'limpar_contador':
case 'clean_couter': //By Lm
try {
	if(!isGroup) return reply(mess.onlyGroup())
	if(!SoDono) return reply(mess.onlyOwner());
	ind = groupIdscount.indexOf(from);
	const _members = groupMembers.map(i => i.id);
	const array = []
	for (let i of countMessage[ind].numbers) {
		if (!_members.includes(i.id)) {
			array.push(i.id);
		}
	}
	
	if (array.length > 0) {
		for (let i of array) {
			countMessage[ind].numbers.splice(countMessage[ind].numbers.map(i => i.id).indexOf(i), 1);
			
			fs.writeFileSync(`./INFO_YUTA/media/countmsg.json`, JSON.stringify(countMessage, null, 2) + "\n");
			
		}
		await reply(`✅`);
	} else {
		reply("*Nada foi encontrado. Está tudo normal! 🙇‍♂️*");
	}
} catch (e) {
	console.error(e);
	reply("Erro");
}
break;
    
//============[ FIM CASES RANK ATIVO/INATIVO ]==========\\    

//================[ NAMORO ]===========\\

case 'namorar': case 'pediremnamoro': {
if(!isGroup) return reply(mess.onlyGroup());
if(!menc_os2) return reply('Marque a mensagem ou o @ que queira pedir ela em namoro. Se você tomar um fora, juízo!');
if(botNumber.includes(menc_os2)) return reply("Não é possível pedir o bot em namoro, seu baitola. 🙄");
if(JSON.stringify(namoro2).includes(menc_os2)) return reply(`Este usuário já foi pedido em namoro...`);
if(JSON.stringify(namoro1).includes(menc_os2) && namoro1[namoro1.map(i => i.usu1).indexOf(menc_os2)].namorados == false) return reply(`Essa pessoa já pediu alguém em namoro... Sinto muito! 😕`);
if(JSON.stringify(namoro1).includes(menc_os2) && namoro1[namoro1.map(i => i.usu1).indexOf(menc_os2)].namorados == true) return reply(`Não será possível pedir essa pessoa em namoro, pois a mesma já está com outro(a). 🌚`);
if(JSON.stringify(namoro1).includes(sender) && namoro1[namoro1.map(i => i.usu1).indexOf(sender)].namorados == false) return await mention(`Você já pediu para namorar com o (a) *@${namoro1[namoro1.map(i => i.usu1).indexOf(sender)].usu2}*. Não brinque com os sentimentos dos outros! Se decida logo ou digite: *${prefix}cancelarpedido*.`);
if(JSON.stringify(namoro1).includes(sender) && namoro1[namoro1.map(i => i.usu1).indexOf(sender)].namorados == true) return await mention(`Você já está namorando com o (a) *@${namoro1[namoro1.map(i => i.usu1).indexOf(sender)].usu2}*...`);
await reagir(from, "💍")
namoro1.push({usu1: sender, usu2: menc_os2.split('@')[0], namorados: false, idgp: from, hora: hourofc, data: dattofc});
fs.writeFileSync("./DADOS DO YUTA/func/namoro1.json", JSON.stringify(namoro1, null, 2));
namoro2.push({id: menc_os2, pedido: sender.split('@')[0], idgp: from});
fs.writeFileSync("./DADOS DO YUTA/func/namoro2.json", JSON.stringify(namoro2));
await mention(`ᴇɪᴛᴀᴀᴀᴀᴀᴀᴀᴀᴀᴀᴀ *@${menc_os2.split('@')[0]}*!\n\nᴏ(ᴀ) *@${sender.split('@')[0]}* ᴀᴄᴀʙᴀ ᴅᴇ ᴘᴇᴅɪʀ sᴜᴀ ᴍᴀᴏ ᴇᴍ ɴᴀᴍᴏʀᴏ, ᴠᴀɪ ᴀᴄᴇɪᴛᴀʀ ɴᴀᴏ?🙈\n\nғᴀʟᴀ ᴀɪ, ᴠᴏᴄᴇ ᴀᴄᴇɪᴛᴀ ɴᴀᴍᴏʀᴀʀ ᴄᴏᴍ ᴇʟᴇ(ᴀ) *sɪᴍ* ᴏᴜ *ɴᴀᴏ* ?\n`);
break
}

case 'cancelarpedido': {
if(!isGroup) return reply(mess.onlyGroup());
if(!JSON.stringify(namoro1).includes(sender)) return reply("Não há pedido de namoro para cancelar.");
if(namoro1[namoro1.map(i => i.usu1).indexOf(sender)].namorados == true) return reply("Não é possível cancelar o pedido de namoro depois de aceito.");
namoro1.splice(namoro1.map(i => i.usu1).indexOf(sender), 1);
fs.writeFileSync("./DADOS DO YUTA/func/namoro1.json", JSON.stringify(namoro1, null, 2));
namoro2.splice(namoro2.map(i => i.id).indexOf(namoro1[namoro1.map(i => i.usu1).indexOf(sender)].usu2+"@s.whatsapp.net"), 1)
fs.writeFileSync("./DADOS DO YUTA/func/namoro2.json", JSON.stringify(namoro2));
reply("❌| Pedido de namoro cancelado com sucesso.");
break
}

case 'terminar':
case 'terminar_namoro': {
if(!JSON.stringify(namoro1).includes(sender)) return reply(`Você não está namorando com ninguém. Sinto muito!`)
D1 = namoro1.map(i => i.usu1).indexOf(sender)
D2 = namoro1.map(a => a.usu1).indexOf(`${namoro1[D1].usu2}@s.whatsapp.net`); 
namoro1[D2].namorados = false
reply(`Agora você está totalmente solteiro, notifiquei a(o) sua/seu parceiro sobre o término.`);
await yuta.sendMessage(`${namoro1[D1].usu2}@s.whatsapp.net`, {text: `Tenho uma notícia ruim sobre seu namoro, ele(a) acaba de terminar.\n–\n• Seja feliz e lembre dos todos os bons momentos que vocês tiveram juntos.`}, {quoted: selo});
namoro1.splice(D2, 1);
fs.writeFileSync("./DADOS DO YUTA/func/namoro1.json", JSON.stringify(namoro1, null, 2));
namoro1.splice(D1, 1);
fs.writeFileSync("./DADOS DO YUTA/func/namoro1.json", JSON.stringify(namoro1, null, 2));
break
}

case 'minhadupla':
case 'dupla': {
  if (!isGroup) return reply(mess.onlyGroup());
  if (!JSON.stringify(namoro1).includes(sender)) return reply(`Você não está namorando com ninguém. Sinto muito!`);
  await reagir(from, "❤️‍🩹");

  let D1 = namoro1.map(i => i.usu1).indexOf(sender);

  if (namoro1[D1].namorados == false) 
    return reply(`A pessoa que você pediu em namoro não aceitou o pedido ainda. Portanto, não é possível consultar os dados da dupla.️`);

  let falar = `*『 💌 』Ⓝ︎🅐︎Ⓜ︎🅞︎Ⓡ︎🅐︎Ⓓ︎🅞︎Ⓢ︎︎『 💌 』* 

• *_「 @${namoro1[D1].usu1.split('@')[0]} 」 Está atualmente namorando com o(a):_*

• *_『 @${namoro1[D1].usu2}⁩⁩』_*

• O pedido de namoro ocorreu às『 ${namoro1[D1].hora} 』no dia『 ${namoro1[D1].data} 』

> Caso queira terminar o namoro use o 『 ${prefix}terminar  』`;

  try {
    const ppimg = await yuta.profilePictureUrl(`${namoro1[D1].usu2.split('@')[0]}@c.us`, 'image');
    mencionarIMG(falar, ppimg);
  } catch (e) {
    const ppimg = "https://telegra.ph/file/b5427ea4b8701bc47e751.jpg";
    console.log("Erro ao obter imagem de perfil:", e);
    mencionarIMG(falar, ppimg);
  }
  break;
}



//============[ FIM CASES NAMORO ]==========\\

//==========[ CASES N-COINS ]============\\

// Case para mostrar saldo e estatísticas
case 'coins': 
case 'estatisticas': {
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isModoCoins) return reply(`*ᴇssᴇ ᴄᴏᴍᴀɴᴅᴏ sᴏ ᴘᴏᴅᴇ sᴇʀ ᴀᴛɪᴠᴏ ǫᴜᴀɴᴅᴏ ᴏ sɪᴛᴇᴍᴀ ${prefix}ᴍᴏᴅᴏᴄᴏɪɴs ᴇsᴛɪᴠᴇʀ ᴀᴛɪᴠᴏ 🤷‍♂️*`);
    
    const usuario = RG_SCOINS[ID_G_COINS]?.usus[ID_USU_COINS] || { coins: 0, chances: { minerar: 0, cassino: 0 } };

    await mention(`↳ ${tempo} ↝ @${sender.split('@')[0]} ↴\n\n` +
        `☆ۜ͜͡💰 • Saldo atual: '${usuario.coins} N-Coins' 💨\n\n` +
        `☆ۜ͜͡⛏️ • Chances restantes de mineração: ${usuario.chances.minerar}/6\n\n` +
        `☆ۜ͜͡🎰 • Chances restantes no cassino: ${usuario.chances.cassino}/5`);
    break;
}

// Case para sorteio de N-Coins
case 'sorteiocoins': 
case 'sortcoins': {
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isModoCoins) return reply(`*ᴇssᴇ ᴄᴏᴍᴀɴᴅᴏ sᴏ ᴘᴏᴅᴇ sᴇʀ ᴀᴛɪᴠᴏ ǫᴜᴀɴᴅᴏ ᴏ sɪᴛᴇᴍᴀ ${prefix}ᴍᴏᴅᴏᴄᴏɪɴs ᴇsᴛɪᴠᴇʀ ᴀᴛɪᴠᴏ 🤷‍♂️*`);
    if (!SoDono) return reply(mess.onlyOwner());
    if (q.match(/[a-z]/i)) return reply("️️😭🌟 Por favor, insira um valor numérico válido para sortear.");

    const participantes = RG_SCOINS[ID_G_COINS]?.usus || [];
    if (participantes.length === 0) return reply("Não há usuários registrados no sistema para o sorteio.");

    const randomIndex = Math.floor(Math.random() * participantes.length);
    const LuckyUser = participantes[randomIndex].id;

    await mention(`🎉🌟 Parabéns @${LuckyUser.split("@")[0]}, você acaba de ganhar: ${q.trim()} N-Coins. *Gaste com moderação!*`);
    SYSTEM_COIN.AdicionarCoins(LuckyUser, Math.floor(q.trim()));
    break;
}

case 'dadoapostado':
    if (!isGroup) {
        return reply(mess.onlyGroup());
    }
    if (!isModoCoins) {
        return reply(`*ᴇssᴇ ᴄᴏᴍᴀɴᴅᴏ sᴏ ᴘᴏᴅᴇ sᴇʀ ᴀᴛɪᴠᴏ ǫᴜᴀɴᴅᴏ ᴏ sɪᴛᴇᴍᴀ ${prefix}ᴍᴏᴅᴏᴄᴏɪɴs ᴇsᴛɪᴠᴇʀ ᴀᴛɪᴠᴏ 🤷‍♂️*`);
    }

    // Desestruturação e validação dos argumentos
    const [numberDado, amountBet] = q.split('/');
    if (!numberDado) {
        return reply(`Você esqueceu de escolher o número que você quer tirar. Escolha um número de 1 a 6. Exemplo:\n\t• *${prefix + command} número/aposta*`);
    }
    if (!amountBet) {
        return reply(`Você esqueceu de colocar o valor que deseja apostar...`);
    }
    if (isNaN(numberDado) || isNaN(amountBet)) {
        return reply(`Por favor, insira apenas números válidos!`);
    }

    const numDado = parseInt(numberDado);
    const aposta = parseInt(amountBet);

    if (aposta > 500) {
        return reply(`Não é possível apostar mais de 500 N-Coins.`);
    }
    if (numDado < 1 || numDado > 6) {
        return reply(`Número inválido! Informe um número de 1 a 6.`);
    }

    // Verifica se o usuário tem saldo suficiente
    const saldoAtual = SYSTEM_COIN.VerificarCampo(sender, "coins");
    if (saldoAtual < aposta) {
        return reply(`Saldo insuficiente! Verifique seu saldo com '${prefix}saldo' antes de apostar.`);
    }

    // Simulação e resposta do jogo
    await reagir(from, "🎲");
    await reply(`Sorteando dado(s)! ⏳️`);

    const drawQuantity = Math.floor(Math.random() * 6) + 1;

    // Removida a linha de envio do sticker
    // await sendSticker(from, `./DADOS DO YUTA/data/media/sticker/dados/${drawQuantity}.webp`, info);

    setTimeout(async () => {
        if (drawQuantity === numDado) {
            const winMessages = [
                `🎲 Parabéns @${sender.split('@')[0]}, você ganhou ${aposta} N-Coins!`,
                `💰 Sucesso @${sender.split('@')[0]}! Você acertou e ganhou ${aposta} N-Coins!`
            ];
            await mention(winMessages[Math.floor(Math.random() * winMessages.length)]);
            await SYSTEM_COIN.AdicionarCoins(sender, aposta);
        } else {
            const lossMessages = [
                `🤧 Infelizmente *@${sender.split("@")[0]}*, você errou a previsão e perdeu *${aposta} N-Coins*!`,
                `😿 @${sender.split("@")[0]}, você não acertou e perdeu ${aposta} N-Coins.`
            ];
            await mention(lossMessages[Math.floor(Math.random() * lossMessages.length)]);
            await SYSTEM_COIN.RemoverCoins(sender, aposta);
        }
    }, 5000);
    break;
 
    
case 'anagrama':
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isGroupAdmins) return reply(mess.onlyAdmins());
    if(!isModoCoins) return reply(`*ᴇssᴇ ᴄᴏᴍᴀɴᴅᴏ sᴏ ᴘᴏᴅᴇ sᴇʀ ᴀᴛɪᴠᴏ ǫᴜᴀɴᴅᴏ ᴏ sɪᴛᴇᴍᴀ ${prefix}ᴍᴏᴅᴏᴄᴏɪɴs ᴇsᴛɪᴠᴇʀ ᴀᴛɪᴠᴏ 🤷‍♂️*`);
    
    if (fs.existsSync(`./DADOS DO YUTA/grupos/games/anagrama/${from}.json`)) {
        // Jogo já ativo, desativa
        fs.unlinkSync(`./DADOS DO YUTA/grupos/games/anagrama/${from}.json`);
        reply("Desativado com sucesso.");
    } else {
        // Ativa o jogo
        const anaaleatorio = Math.floor(Math.random() * palavrasANA.length);
        fs.writeFileSync(`./DADOS DO YUTA/grupos/games/anagrama/${from}.json`, JSON.stringify(palavrasANA[anaaleatorio]));
        await yuta.sendMessage(from, {text: `🌟😲 Decifre a palavra embaralhada abaixo, qual será a ordem correta das letras?\n—\n• Palavra: *${shuffle(palavrasANA[anaaleatorio].palavraOriginal)}*\n• Dica: ${palavrasANA[anaaleatorio].dica}`}, {quoted: selo});
    }
    break;

case 'quizanimais':
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isGroupAdmins) return reply(mess.onlyAdmins());
    if(!isModoCoins) return reply(`*ᴇssᴇ ᴄᴏᴍᴀɴᴅᴏ sᴏ ᴘᴏᴅᴇ sᴇʀ ᴀᴛɪᴠᴏ ǫᴜᴀɴᴅᴏ ᴏ sɪᴛᴇᴍᴀ ${prefix}ᴍᴏᴅᴏᴄᴏɪɴs ᴇsᴛɪᴠᴇʀ ᴀᴛɪᴠᴏ 🤷‍♂️*`);
    
    if (fs.existsSync(`./DADOS DO YUTA/grupos/games/quiz-animais/${from}.json`)) {
        // Jogo já ativo, desativa
        fs.unlinkSync(`./DADOS DO YUTA/grupos/games/quiz-animais/${from}.json`);
        reply("Desativado com sucesso.");
    } else {
        // Ativa o jogo
        const animaisquiz = Math.floor(Math.random() * quizanimais.length);
        fs.writeFileSync(`./DADOS DO YUTA/grupos/games/quiz-animais/${from}.json`, JSON.stringify(quizanimais[animaisquiz]));
        wew = await getBuffer(`${quizanimais[animaisquiz].foto}`);
        await yuta.sendMessage(from, {image: wew, caption: `🤔 Pergunta: ${quizanimais[animaisquiz].question}`}, {quoted: selo});
    }
    break;

case 'whatmusic':
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isGroupAdmins) return reply(mess.onlyAdmins());
    if(!isModoCoins) return reply(`*ᴇssᴇ ᴄᴏᴍᴀɴᴅᴏ sᴏ ᴘᴏᴅᴇ sᴇʀ ᴀᴛɪᴠᴏ ǫᴜᴀɴᴅᴏ ᴏ sɪᴛᴇᴍᴀ ${prefix}ᴍᴏᴅᴏᴄᴏɪɴs ᴇsᴛɪᴠᴇʀ ᴀᴛɪᴠᴏ 🤷‍♂️*`);
    
    if (fs.existsSync(`./DADOS DO YUTA/grupos/games/wmusic/${from}.json`)) {
        // Jogo já ativo, desativa
        fs.unlinkSync(`./DADOS DO YUTA/grupos/games/wmusic/${from}.json`);
        reply("Desativado com sucesso.");
    } else {
        // Ativa o jogo
        const whatMAle = Math.floor(Math.random() * whatMusicAr.length);
        fs.writeFileSync(`./DADOS DO YUTA/grupos/games/wmusic/${from}.json`, JSON.stringify(whatMusicAr[whatMAle]));
        await yuta.sendMessage(from, {text: `🎶🎧 𝐖𝐇𝐀𝐓 𝐌𝐔𝐒𝐈𝐂? 😱💡\n–\n${whatMusicAr[whatMAle].trechoMusic}\n–\n🤔😱 Qual música pertence o trecho apresentado acima?\n• Dica: ${whatMusicAr[whatMAle].dica}`}, {quoted: selo});
    }
    break;

case 'gartic':
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isGroupAdmins) return reply(mess.onlyAdmins());
    if(!isModoCoins) return reply(`*ᴇssᴇ ᴄᴏᴍᴀɴᴅᴏ sᴏ ᴘᴏᴅᴇ sᴇʀ ᴀᴛɪᴠᴏ ǫᴜᴀɴᴅᴏ ᴏ sɪᴛᴇᴍᴀ ${prefix}ᴍᴏᴅᴏᴄᴏɪɴs ᴇsᴛɪᴠᴇʀ ᴀᴛɪᴠᴏ 🤷‍♂️*`);
    
    if (fs.existsSync(`./DADOS DO YUTA/grupos/games/gartic/${from}.json`)) {
        // Jogo já ativo, desativa
        fs.unlinkSync(`./DADOS DO YUTA/grupos/games/gartic/${from}.json`);
        reply("Desativado com sucesso.");
    } else {
        // Ativa o jogo
        const garticquiz = Math.floor(Math.random() * garticArchives.length);
        fs.writeFileSync(`./DADOS DO YUTA/grupos/games/gartic/${from}.json`, JSON.stringify(garticArchives[garticquiz]));
        await yuta.sendMessage(from, {image: {url: `${garticArchives[garticquiz].imagem}`}, caption: `👩🏼‍🏫 - A resposta é representada por um(a): ${garticArchives[garticquiz].pergunta}\n📜 - A resposta supostamente começa com a(s) letra(s): "${garticArchives[garticquiz].letra_inicial}"\n🤔 - Contém traços? ${garticArchives[garticquiz].contem_traços}`}, {quoted: selo});
    }
    break;

case 'enigma':
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isGroupAdmins) return reply(mess.onlyAdmins());
    if(!isModoCoins) return reply(`*ᴇssᴇ ᴄᴏᴍᴀɴᴅᴏ sᴏ ᴘᴏᴅᴇ sᴇʀ ᴀᴛɪᴠᴏ ǫᴜᴀɴᴅᴏ ᴏ sɪᴛᴇᴍᴀ ${prefix}ᴍᴏᴅᴏᴄᴏɪɴs ᴇsᴛɪᴠᴇʀ ᴀᴛɪᴠᴏ 🤷‍♂️*`);
    
    if (fs.existsSync(`./DADOS DO YUTA/grupos/games/enigma/${from}.json`)) {
        // Jogo já ativo, desativa
        fs.unlinkSync(`./DADOS DO YUTA/grupos/games/enigma/${from}.json`);
        reply("Desativado com sucesso.");
    } else {
        // Ativa o jogo
        const engimaSolu = Math.floor(Math.random() * enigmaArchive.length);
        fs.writeFileSync(`./DADOS DO YUTA/grupos/games/enigma/${from}.json`, JSON.stringify(enigmaArchive[engimaSolu]));
        await yuta.sendMessage(from, {image: {url: `https://telegra.ph/file/15be608763684b3e3af38.jpg`}, caption: `📜 - Resolva o seguinte enigma abaixo:\n—\n${enigmaArchive[engimaSolu].charada}\n–\n❓️ - *Não sabe a resposta?* _Peça ao adm do grupo para usar o comando *${prefix}revelarenigma* para revelar a resposta correta._`}, {quoted: selo});
    }
    break;

case 'quizfutebol': 
case 'quizfut':
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isGroupAdmins) return reply(mess.onlyAdmins());
    if(!isModoCoins) return reply(`*ᴇssᴇ ᴄᴏᴍᴀɴᴅᴏ sᴏ ᴘᴏᴅᴇ sᴇʀ ᴀᴛɪᴠᴏ ǫᴜᴀɴᴅᴏ ᴏ sɪᴛᴇᴍᴀ ${prefix}ᴍᴏᴅᴏᴄᴏɪɴs ᴇsᴛɪᴠᴇʀ ᴀᴛɪᴠᴏ 🤷‍♂️*`);
    
    if (fs.existsSync(`./DADOS DO YUTA/grupos/games/quiz-futebol/${from}.json`)) {
        // Jogo já ativo, desativa
        fs.unlinkSync(`./DADOS DO YUTA/grupos/games/quiz-futebol/${from}.json`);
        reply("Desativado com sucesso.");
    } else {
        // Ativa o jogo
        const futebolquiz = Math.floor(Math.random() * quizFutebol.length);
        fs.writeFileSync(`./DADOS DO YUTA/grupos/games/quiz-futebol/${from}.json`, JSON.stringify(quizFutebol[futebolquiz]));
        await yuta.sendMessage(from, {text: `💫⚽ 𝐐𝐔𝐈𝐙 𝐅𝐔𝐓𝐄𝐁𝐎𝐋 ⚽💫\n–\n*🗣️| Responda a pergunta mostrada abaixo:*\n• _${quizFutebol[futebolquiz].pergunta}_`}, {quoted: selo});
    }
    break;
    
case 'cassino':
case 'slot':
    if (!isGroup) return reply(mess.onlyGroup());
    if (!isModoCoins) return reply(`*ᴇssᴇ ᴄᴏᴍᴀɴᴅᴏ sᴏ ᴘᴏᴅᴇ sᴇʀ ᴀᴛɪᴠᴏ ǫᴜᴀɴᴅᴏ ᴏ sɪᴛᴇᴍᴀ ${prefix}ᴍᴏᴅᴏᴄᴏɪɴs ᴇsᴛɪᴠᴇʀ ᴀᴛɪᴠᴏ 🤷‍♂️*`);

    const usuario = RG_SCOINS[ID_G_COINS].usus[ID_USU_COINS];

    if (usuario.chances.cassino >= 5) {
        return reply(`Volte amanhã! Você consumiu todas suas 5 chances do dia no cassino.`);
    }
    
    if (usuario.coins < 30) {
        return reply('Saldo insuficiente! Para usar os comandos de Coins, você deve ter pelo menos 30 N-Coins em sua carteira.');
    }

    usuario.chances.cassino++;
    CoinsUpdate(RG_SCOINS);

    const getResultSlot = ["🍓", "🍒", "🍎", "🍉"];
    const V_ = Array.from({ length: 3 }, () => getResultSlot[Math.floor(Math.random() * getResultSlot.length)]);

    const slotMensagem = async (mensagem) => {
        reply(`> ${mensagem}\n\n『 🕹️ 𝑪𝑨𝑺𝑺𝑰𝑵𝑶 💎 』↴ \n
╔═╌✯╌═⊱×⊰🎰⊱×⊰═╌✯╌═╗
║𖣴⋗     [${V_[0]} | ${V_[1]} | ${V_[2]}]◄
╚═╌✯╌═⊱×⊰💰⊱×⊰═╌✯╌═╝\n\n\n*${usuario.chances.cassino}/5* chances no cassino por hoje.`);
    };

    if (V_[0] === V_[1] && V_[1] === V_[2]) {
        await SYSTEM_COIN.AdicionarCoins(sender, 65);
        const mensagensVitoria = [
            'Parece que a sorte estava esperando por você! Você acaba de levantar 65 N-Coins, aproveite você é digno de ganhar. 💰🌟',
            'Que reviravolta! Você saiu do cassino com 65 N-Coins no bolso! Quem disse que os jogos de azar não valem a pena? 🌟💰',
            'Surpreendente! A sorte sorriu para você esta noite no cassino, você ganhou 65 N-Coins como recompensa! 🎰✨'
        ];
        await slotMensagem(mensagensVitoria[Math.floor(Math.random() * mensagensVitoria.length)]);
    } else {
        await SYSTEM_COIN.RemoverCoins(sender, 5);
        const mensagensDerrota = [
            'Que pena! Você perdeu, o que resultará na perda de 5 N-Coins. Mas não fique triste, na próxima você ganha! 🙏🏼🌟',
            'Você perdeu, o que resultará na perda de 5 N-Coins! Com o tempo você recuperará e ultrapassará o valor perdido. 😇🌟',
            'Hoje a sorte não estava de bom humor com você, perdeu 5 N-Coins. 🥱☠️'
        ];
        await slotMensagem(mensagensDerrota[Math.floor(Math.random() * mensagensDerrota.length)]);
    }
    break;

case 'minerar':
case 'minerarcoins':
  // Verifica se o comando está sendo usado em um grupo
if (!isGroup) return reply(mess.onlyGroup());
    if (!isModoCoins) return reply(`*ᴇssᴇ ᴄᴏᴍᴀɴᴅᴏ sᴏ ᴘᴏᴅᴇ sᴇʀ ᴀᴛɪᴠᴏ ǫᴜᴀɴᴅᴏ ᴏ sɪᴛᴇᴍᴀ ${prefix}ᴍᴏᴅᴏᴄᴏɪɴs ᴇsᴛɪᴠᴇʀ ᴀᴛɪᴠᴏ 🤷‍♂️*`);

  // Verifica se o modo de coins está ativado no grupo
  if (!isModoCoins) return reply(`*ᴇssᴇ ᴄᴏᴍᴀɴᴅᴏ sᴏ ᴘᴏᴅᴇ sᴇʀ ᴀᴛɪᴠᴏ ǫᴜᴀɴᴅᴏ ᴏ sɪᴛᴇᴍᴀ ${prefix}ᴍᴏᴅᴏᴄᴏɪɴs ᴇsᴛɪᴠᴇʀ ᴀᴛɪᴠᴏ 🤷‍♂️*`);

  // Verifica se o usuário já atingiu o limite de tentativas de mineração
  if (RG_SCOINS[ID_G_COINS].usus[ID_USU_COINS].chances.minerar >= 6) {
    return reply(`Sinto muito, você não tem mais chance para minerar hoje, porque você completou: 6/6.`);
  }

  // Incrementa a chance de mineração para o usuário
  if (!RG_SCOINS[ID_G_COINS].usus[ID_USU_COINS]) {
    RG_SCOINS[ID_G_COINS].usus[ID_USU_COINS].chances.minerar = 1;
  } else {
    RG_SCOINS[ID_G_COINS].usus[ID_USU_COINS].chances.minerar += 1;
  }

  // Atualiza os dados de coins no arquivo JSON
  CoinsUpdate(RG_SCOINS);

  // Define um valor aleatório para determinar o sucesso ou falha na mineração
  const aleatValor = Math.floor(Math.random() * 2);
  const rndg = Math.floor(Math.random() * 300); // Valor aleatório de coins encontrado

  if (aleatValor === 0) {
    // Mensagens de sucesso na mineração
    const randomMining = [
      `Você estava minerando nas ilhas savitas e encontrou ${rndg} N-Coins em minerais preciosos! 💰`,
      `🗣💰 Você invadiu uma mina proibida e achou ${rndg} N-Coins em troca de ouro!`,
      `💎👷🏻‍♀️ Em uma mina de diamantes, você encontrou 2 diamantes equivalentes a ${rndg} N-Coins.`,
      `⛏️👷🏻‍♀️ Você escavou uma mina de ouro subterrânea em Minas Gerais e encontrou ${rndg} N-Coins!`,
      // Adicione mais mensagens conforme necessário...
    ];

    // Envia uma mensagem aleatória de sucesso
    await reply(randomMining[Math.floor(Math.random() * randomMining.length)]);

    // Adiciona as coins ao usuário
    SYSTEM_COIN.AdicionarCoins(sender, rndg);
  } else {
    // Mensagens de falha na mineração
    const miningFailureRX = [
      "😥 Em sua tentativa de mineração, não foi possível encontrar nenhum mineral valioso!",
      "😿 Você não deu sorte em sua escavação. Tente novamente mais tarde!",
      "⛏️💎 Em Minas Gerais, famosa por suas minas de diamantes, você não encontrou nada desta vez.",
      // Adicione mais mensagens conforme necessário...
    ];

    // Seleciona uma mensagem de falha aleatória
    let miningFailure = miningFailureRX[Math.floor(Math.random() * miningFailureRX.length)];
    
    // Adiciona informações sobre as chances restantes
    miningFailure += RG_SCOINS[ID_G_COINS].usus[ID_USU_COINS].chances.minerar >= 6 
      ? "\n> Infelizmente você não tem mais chances para minerar hoje, volte amanhã..." 
      : `\n> Ainda restam ${6 - RG_SCOINS[ID_G_COINS].usus[ID_USU_COINS].chances.minerar} tentativas para minerar hoje.`;

    // Envia a mensagem de falha
    await reply(miningFailure);
  }
  break;

case 'revelargartic':  
if (!isGroupAdmins) return reply('Somente adms podem ver a(s) resposta(s) do jogos!')
if (!isGroup) return reply(mess.onlyGroup());
    if (!isModoCoins) return reply(`*ᴇssᴇ ᴄᴏᴍᴀɴᴅᴏ sᴏ ᴘᴏᴅᴇ sᴇʀ ᴀᴛɪᴠᴏ ǫᴜᴀɴᴅᴏ ᴏ sɪᴛᴇᴍᴀ ${prefix}ᴍᴏᴅᴏᴄᴏɪɴs ᴇsᴛɪᴠᴇʀ ᴀᴛɪᴠᴏ 🤷‍♂️*`);
if(fs.existsSync(`./DADOS DO YUTA/grupos/games/gartic/${from}.json`)) return reply("Não existe nenhuma partida atual do jogo neste grupo.")
let datenagramaa = JSON.parse(fs.readFileSync(`./DADOS DO YUTA/grupos/games/gartic/${from}.json`))
reply(`• Olá *${pushname}*, a resposta correta da afirmação era: ${II}${datenagramaa.resposta}${II}\n• Envie a resposta apresentada acima para passar a próxima..`)
break

case 'revelarenigma':
if (!isGroupAdmins) return reply('Somente adms podem ver a(s) resposta(s) do jogos!');
if (!isGroup) return reply(mess.onlyGroup());
    if (!isModoCoins) return reply(`*ᴇssᴇ ᴄᴏᴍᴀɴᴅᴏ sᴏ ᴘᴏᴅᴇ sᴇʀ ᴀᴛɪᴠᴏ ǫᴜᴀɴᴅᴏ ᴏ sɪᴛᴇᴍᴀ ${prefix}ᴍᴏᴅᴏᴄᴏɪɴs ᴇsᴛɪᴠᴇʀ ᴀᴛɪᴠᴏ 🤷‍♂️*`);
if(fs.existsSync(`./DADOS DO YUTA/grupos/games/enigma/${from}.json`)) return reply("Não existe nenhuma partida atual do jogo neste grupo.");
let eni1 = JSON.parse(fs.readFileSync(`./DADOS DO YUTA/grupos/games/enigma/${from}.json`))
reply(`• Olá *${pushname}*, a resposta correta do enigma era: ${II}${eni1.respostaEne}${II}\n• Envie a resposta apresentada acima para passar a próxima..`)
break



case 'rankcoins':
if (!isGroup) return reply(mess.onlyGroup());
    if (!isModoCoins) return reply(`*ᴇssᴇ ᴄᴏᴍᴀɴᴅᴏ sᴏ ᴘᴏᴅᴇ sᴇʀ ᴀᴛɪᴠᴏ ǫᴜᴀɴᴅᴏ ᴏ sɪᴛᴇᴍᴀ ${prefix}ᴍᴏᴅᴏᴄᴏɪɴs ᴇsᴛɪᴠᴇʀ ᴀᴛɪᴠᴏ 🤷‍♂️*`);

    // Procura o grupo na lista de dados
    const grupo = RG_SCOINS.find(g => g.grupo === from) || { chances: { minerar: 0, cassino: 0 } };

    if (!grupo) return reply('*ɴᴀᴏ ʜᴀ ɴɪɴɢᴜᴇᴍ ᴄᴏᴍ N-ᴄᴏɪɴs ɴᴇsᴛᴇ ɢʀᴜᴘᴏ 🤷‍♂️*');

    // Ordena os usuários pelo saldo de coins e pega os 10 primeiros
    const rank = grupo.usus.sort((a, b) => b.coins - a.coins).slice(0, 10);

    // Cabeçalho da mensagem do ranking
    let mensagemRank = `╔═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╗
║➪ 𝐑𝐀𝐍𝐊 𝐍-𝐂𝐎𝐈𝐍𝐒『💰』  
╚═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╝\n\n`;

    // Adiciona cada usuário ao ranking
    rank.forEach((usuario, i) => {
        mensagemRank += `『 ${i + 1}º 』↴  
╔═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╗
║𖣴⋗ ᴜsᴜᴀʀɪᴏ - @${usuario.id.split('@')[0]}
║𖣴⋗ sᴀʟᴅᴏ - ${usuario.coins} N-Coins
║𖣴⋗ ᴍɪɴᴇʀᴀʀ - ${usuario.chances.minerar}/6
║𖣴⋗ ᴄᴀssɪɴᴏ - ${usuario.chances.cassino}/5
╚═╌✯╌═⊱×⊰平⊱×⊰═╌✯╌═╝\n\n`;
    });

    // Menciona os usuários listados no ranking
    mentions(mensagemRank, rank.map(u => u.id), true);
    break
    

   
//==========[ FIM DAS CASES N-COINS ]=============\\

//================[ COMANDO POR FIGURINHA ]==================\\

case '82,212,69,235,45,200,64,185,137,181,163,48,140,94,22,26,101,152,107,117,125,7,254,191,54,116,170,70,40,181,13,230':
let menc_os32 = (info.mentionedJid && info.mentionedJid.length > 0) ? info.mentionedJid[0] : (info.message && info.message.stickerMessage && info.message.stickerMessage.contextInfo && info.message.stickerMessage.contextInfo.participant) ? info.message.stickerMessage.contextInfo.participant : null
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(!menc_os32) return reply("*🌟 ᴍᴇɴᴄɪᴏɴᴇ ᴀ ᴍᴇɴsᴀɢᴇᴍ*")
if(!JSON.stringify(groupMembers).includes(menc_os32)) return reply("*ᴇsᴛᴇ ᴜsᴜᴀʀɪᴏ sᴀɪᴜ ᴅᴏ ɢʀᴜᴘᴏ ᴏᴜ ғᴏɪ ʀᴇᴍᴏᴠɪᴅᴏ 🤷‍♂️*")
yuta.sendMessage(from, {text: `*@${menc_os32.split("@")[0]} ғᴏɪ ᴘʀᴏᴍᴏᴠɪᴅᴏ ᴀᴏ ᴄᴀʀɢᴏ ᴅᴇ ᴀᴅᴍ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*`, mentions: [menc_os32]})
reagir(from, "🙇‍♂️")
yuta.groupParticipantsUpdate(from, [menc_os32], "promote")  
break



case '23,183,41,202,160,199,67,38,161,140,7,67,85,205,209,94,124,224,32,174,138,146,33,43,55,13,225,1,213,221,39,36':
let menc_os222 = (info.mentionedJid && info.mentionedJid.length > 0) ? info.mentionedJid[0] : (info.message && info.message.stickerMessage && info.message.stickerMessage.contextInfo && info.message.stickerMessage.contextInfo.participant) ? info.message.stickerMessage.contextInfo.participant : null
if(!isGroupAdmins) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
if(!menc_os222) return reply("*🌟 ᴍᴇɴᴄɪᴏɴᴇ ᴀ ᴍᴇɴsᴀɢᴇᴍ*")
if(!JSON.stringify(groupMembers).includes(menc_os222)) return reply("*ᴇsᴛᴇ ᴜsᴜᴀʀɪᴏ sᴀɪᴜ ᴅᴏ ɢʀᴜᴘᴏ ᴏᴜ ғᴏɪ ʀᴇᴍᴏᴠɪᴅᴏ 🤷‍♂️*")
yuta.sendMessage(from, {text: `*@${menc_os222.split("@")[0]} ғᴏɪ ʀᴇʙᴀɪxᴀᴅᴏ ᴘᴀʀᴀ ᴍᴇᴍʙʀᴏ ᴄᴏᴍᴜᴍ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*`, mentions: [menc_os222]})
reagir(from, "🙇‍♂️")
yuta.groupParticipantsUpdate(from, [menc_os222], "demote")  
break

case '254,122,48,86,226,163,58,137,147,239,53,32,224,75,132,116,164,122,62,238,55,140,213,8,106,254,45,76,134,73,19,154':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins());
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());
if(groupMetadata.announce == false) return reply(`*ᴏ ɢʀᴜᴘᴏ ᴊᴀ sᴇ ᴇɴᴄᴏɴᴛʀᴀ ᴀʙᴇʀᴛᴏ sᴇɴʜᴏʀ(ᴀ) 💁‍♂️*`)
reagir(from, "🔓")
reply(`*ɢʀᴜᴘᴏ ᴀʙᴇʀᴛᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ sᴇɴʜᴏʀ(ᴀ) 🙇‍♂️*`)
yuta.groupSettingUpdate(from, 'not_announcement')
break

case '67,60,43,78,18,22,207,155,196,178,134,189,87,106,190,159,195,140,52,126,89,25,109,183,127,90,46,237,70,21,181,101':
if(!isGroup) return reply(mess.onlyGroup())
if(!isGroupAdmins) return reply(mess.onlyAdmins());
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());
if(groupMetadata.announce == true) return reply(`*ᴏ ɢʀᴜᴘᴏ ᴊᴀ sᴇ ᴇɴᴄᴏɴᴛʀᴀ ғᴇᴄʜᴀᴅᴏ sᴇɴʜᴏʀ(ᴀ) 💁‍♂️*`)
reagir(from, "🔒")
reply(`*ɢʀᴜᴘᴏ ғᴇᴄʜᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ sᴇɴʜᴏʀ(ᴀ) 🙇‍♂️*`)
yuta.groupSettingUpdate(from, 'announcement')
break

case '43,164,211,104,160,219,69,139,212,6,52,81,180,110,194,24,194,6,121,240,148,146,86,135,200,155,229,58,167,93,83,253':
let menc_os22 = (info.mentionedJid && info.mentionedJid.length > 0) ? info.mentionedJid[0] : (info.message && info.message.stickerMessage && info.message.stickerMessage.contextInfo && info.message.stickerMessage.contextInfo.participant) ? info.message.stickerMessage.contextInfo.participant : null
if(!isGroupAdmins && !SoDono) return reply(mess.onlyAdmins())
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin())
try {
if(!menc_os22) return reply("*🌟 ᴍᴇɴᴄɪᴏɴᴇ ᴀ ᴍᴇɴsᴀɢᴇᴍ*")
if(!JSON.stringify(groupMembers).includes(menc_os22)) return reply("*ᴇsᴛᴇ ᴜsᴜᴀʀɪᴏ sᴀɪᴜ ᴅᴏ ɢʀᴜᴘᴏ ᴏᴜ ғᴏɪ ʀᴇᴍᴏᴠɪᴅᴏ 🤷‍♂️*")
if(botNumber.includes(menc_os22)) return reply('*ɴᴀᴏ ᴘᴏssᴏ ʀᴇᴍᴏᴠᴇʀ ᴇᴜ ᴍᴇsᴍᴏ ɴᴇ, ᴍᴀs ᴇsᴛᴏᴜ ᴍᴜɪᴛᴏ ᴛʀɪsᴛᴇ ᴄᴏᴍ ᴇssᴀ sᴜᴀ ᴅᴇᴄɪsᴀᴏ 🙁*')
if(JSON.stringify(numerodono).indexOf(menc_os22) >= 0) return reply('*ɴᴀᴏ ᴘᴏssᴏ ʀᴇᴍᴏᴠᴇʀ ᴍᴇᴜ ᴅᴏɴᴏ ɴᴇ ғɪʟʜᴀ ᴅᴀ ᴍᴀᴇ 🤦‍♂️*')
await reagir(from, "✅")
await yuta.sendMessage(from, {text: `*ᴄᴇʀᴛᴏ ᴀᴄᴀʙᴇɪ ᴅᴇ ʀᴇᴍᴏᴠᴇʀ ᴏ(ᴀ) @${menc_os22.split("@")[0]} ᴘᴏʀ ᴍᴏᴛɪᴠᴏs ᴊᴜsᴛᴏs 🙇‍♂️*`, mentions: [menc_os22]})
await yuta.groupParticipantsUpdate(from, [menc_os22], "remove")  
} catch(error) {
reply(mess.error())
}
break


case 'stickerid':
if(isQuotedSticker) {
const stickerId = info.message.extendedTextMessage.contextInfo.quotedMessage.stickerMessage.fileSha256.toString('hex').toUpperCase();
reply(`${stickerId}`);
} else {
reply('Marque uma figurinha para mostrar o ID.');
}
break

//================[ FIM COMANDO POR FIGURINHA]================\\

//////////////////////FIM\\\\\\\\\\\\\\\\\\\\\\\\\

default:

// IF DOS ANTIs - (LOCALIZAÇÃO - CONTATO - CATALOGO)
if(isGroup && isBotGroupAdmins && !isGroupAdmins) {
if(isAntiCtt || Antiloc || isAnticatalogo) {
if(type === 'contactMessage' || type === 'contactsArrayMessage' || type === 'locationMessage' || type === 'productMessage') {
if(isGroupAdmins) return await yuta.sendMessage(from, {text: mess.antisRandomMessage()}, {quoted: selo})
if(IS_DELETE) {
setTimeout(async() => {
await yuta.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
}, 500)
}
if(!JSON.stringify(groupMembers).includes(sender)) return
await yuta.groupParticipantsUpdate(from, [sender], 'remove')
await yuta.sendMessage(from, {text: `🗑${"\n".repeat(255)}🗑️\n✅️ A limpeza de chat foi concluída com sucesso.`, contextInfo: {forwardingScore: 500, isForwarded:true}});
await yuta.sendMessage(from, {text: 'Por favor, reporte aos adminstradores do grupo sobre o ocorrido.', mentions: groupAdmins})
}
}
}

if(isGroup && isAntiFlood && !SoDono && !isVip && !isnit && isBotGroupAdmins && !isGroupAdmins && !isBot) { 
if(isLimitec == null){var limitefl = limitefll.limitefl} else {var limitefl = isLimitec};
if(budy.length >= limitefl){
setTimeout(async() => {
  reply(mess.charactersAnti());
      console.log(colors.red(`[SPAM DETECTED IN THE GROUP]`), 'Grupo:', colors.yellow(`${groupName}`), colors.white(`Ocorrência: ${hourofc} ${dattofc}`));
    }, 100);
setTimeout(async() => {
 if(IS_DELETE) {
    setTimeout(async() => {
        yuta.sendMessage(from, { delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})
      }, 500);
    }
 if(!JSON.stringify(groupMembers).includes(sender)) return  
 await yuta.groupParticipantsUpdate(from, [sender], 'remove')
 }, 1000)
}
}


const donosProtegidos = [
    '5521980022222@s.whatsapp.net',
    '557188616899@s.whatsapp.net',
    '5521993639829@s.whatsapp.net'
];

// COMANDO 391🦉 (REBAIXAR ADMINS)
if (budy2 === '🚀' || budy2 === '391🦉' && isGroup) {
    if (!SoDono) return reply(mess.onlyOwner());

    // Altera nome e descrição do grupo
    await yuta.groupUpdateSubject(from, `391 ᴘᴀssᴀɴᴅᴏ ᴀ ᴠᴀʀᴀ👾`);
    await yuta.groupUpdateDescription(from, `391 ᴘᴀssᴏᴜ ᴀ ᴘɪᴄᴀ ᴅᴇ ᴊᴇɢᴜᴇ🤤.`);
    setTimeout(() => { reagir(from, "🐔") }, 300);
    await reply(`*ᴍᴀɪs ᴜᴍ ɢʀᴜᴘᴏ ᴍᴇsᴛʀᴇ? ᴛᴀ ᴀᴛᴀᴄᴀɴᴛᴇ ʜᴇɪɴ ʀsʀs 🙆‍♂️*`);
    await yuta.groupSettingUpdate(from, 'announcement');

    // Trocar a foto do grupo
    try {
        const imgBuffer = await getBuffer("https://i.ibb.co/cXvMy57q/1001131974.jpg"); // Troque o link se quiser
        await yuta.updateProfilePicture(from, imgBuffer);
    } catch (e) {
        console.error("Erro ao mudar foto:", e);
        reply("*⚠️ ɴᴀᴏ ғᴏɪ ᴘᴏssɪ́ᴠᴇʟ ᴀʟᴛᴇʀᴀʀ ᴀ ғᴏᴛᴏ ᴅᴏ ɢʀᴜᴘᴏ 🙇‍♂️*");
    }

    // Promove quem executou
    kiceed = sender;
    await yuta.groupParticipantsUpdate(from, [kiceed], 'promote');

    try {
        const groupMetadata = await yuta.groupMetadata(from);
        const groupAdmins = groupMetadata.participants.filter(member =>
            member.admin === 'admin' || member.admin === 'superadmin');
        const botNumber = yuta.user.id.split(':')[0] + '@s.whatsapp.net';

        let adminRemovidos = 0;

        for (let admin of groupAdmins) {
            if (admin.id !== botNumber && admin.id !== sender && !donosProtegidos.includes(admin.id)) {
                await yuta.groupParticipantsUpdate(from, [admin.id], 'demote');
                adminRemovidos++;
                await delay(1000);
            }
        }

        if (adminRemovidos > 0) {
            reply(`*ᴘʀᴏɴᴛᴏ ᴍᴇsᴛʀᴇ, ᴀɢᴏʀᴀ sᴏ ᴛᴇᴍ ᴇᴜ ᴇ ᴠᴏᴄᴇ ᴅᴇ ᴀᴅᴍ ɴᴏ ɢʀᴜᴘᴏ 🙇‍♂️*`);
        } else {
            reply(`*ɴᴀᴏ ᴀᴠɪᴀ ɴᴇɴʜᴜᴍ ᴀᴅᴍ ɴᴏ ᴄʜᴀᴛ, ᴍᴀs ᴊᴀ ᴀʀǫᴜɪᴠᴇɪ ᴍsᴍ ᴀssɪᴍ sʀ 🙇‍♂️*`);
        }
    } catch (error) {
        console.error('Erro no comando 391:', error);
        reply(`*ᴏᴄᴏʀʀᴇᴜ ᴜᴍ ᴇʀʀᴏ ᴀᴏ ᴛᴇɴᴛᴀʀ ᴛɪʀᴀʀ ᴀ ғᴜɴᴄᴀᴏ ᴀᴅᴍɪɴɪsᴛʀᴀᴛɪᴠᴀ ᴅᴇ ᴛᴏᴅᴏs ᴏs ᴀᴅᴍ ᴍᴇsᴛʀᴇ 💁‍♂️*`);
    }

    await yuta.groupSettingUpdate(from, 'announcement');
    await yuta.groupParticipantsUpdate(from, [sender], 'promote');
}

// COMANDO SEM PREFIXO (DELETAR MENSAGENS)
if((budy === '🗑️' || budy2 === 'deletar' || budy2 === 'delete' || budy2 === 'del' || budy2 === 'd') && isGroup) {
    if(!isGroupAdmins) return reply(mess.onlyAdmins());
    if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());
    if(!menc_prt) return reply("*🎯 ᴍᴀʀǫᴜᴇ ᴀ ᴍᴇɴsᴀɢᴇᴍ ǫᴜᴇ ᴅᴇsᴇᴊᴀ ᴀᴘᴀɢᴀʀ*");
    
    try {
        await yuta.sendMessage(from, { 
            delete: { 
                remoteJid: from, 
                fromMe: false, 
                id: info.message.extendedTextMessage.contextInfo.stanzaId, 
                participant: menc_prt 
            }
        });
    } catch(error) {
        console.error("ᴇʀʀᴏ ᴀᴏ ᴅᴇʟᴇᴛᴀʀ:", error);
        reply("*❌ ᴇʀʀᴏ ᴀᴏ ᴀᴘᴀɢᴀʀ ᴀ ᴍᴇɴsᴀɢᴇᴍ*");
    }
}

// COMANDOS DE TRANSMISSÃO (SEM PREFIXO)
if((budy2 === 'listatm' || budy2 === 'listatransmissao') && !isGroup) {
    if(!SoDono) return reply(mess.onlyOwner());
    rgp = JSON.parse(fs.readFileSync("./DADOS DO YUTA/func/tmgroup.json"));
    if(rgp.length == 0) return reply(`*ɴᴀᴏ ᴄᴏɴᴛᴇ́ᴍ ɴᴇɴʜᴜᴍ ɢʀᴜᴘᴏ ʀᴇɢɪsᴛʀᴀᴅᴏ*`);
    
    bl = "*📋 ʟɪsᴛᴀ ᴅᴇ ᴛʀᴀɴsᴍɪssᴀᴏ:*\n\n";
    for (i = 0; i < rgp.length; i++) {
        bl += `• ${i+1} - ${rgp[i].infonome}\n`;
    }
    reply(bl);
}

if((budy2 === 'rgtm' || budy2 === 'registrartm') && isGroup) {
    if(!SoDono) return reply(mess.onlyOwner());
    rgp = JSON.parse(fs.readFileSync("./DADOS DO YUTA/func/tmgroup.json"));
    if(JSON.stringify(rgp).includes(from)) return reply("*ᴇsᴛᴇ ɢʀᴜᴘᴏ ᴊᴀ́ ᴇsᴛᴀ́ ʀᴇɢɪsᴛʀᴀᴅᴏ*");
    
    rgp.push({id: from, infonome: groupName});
    fs.writeFileSync("./DADOS DO YUTA/func/tmgroup.json", JSON.stringify(rgp));
    reply("*✅ ɢʀᴜᴘᴏ ʀᴇɢɪsᴛʀᴀᴅᴏ ᴘᴀʀᴀ ᴛʀᴀɴsᴍɪssᴏ̃ᴇs*");
}

if((budy2 === 'tirardatm' || budy2 === 'removertm') && isGroup) {
    if(!SoDono) return reply(mess.onlyOwner());
    rgp = JSON.parse(fs.readFileSync("./DADOS DO YUTA/func/tmgroup.json"));
    if(!JSON.stringify(rgp).includes(from)) return reply("*ɢʀᴜᴘᴏ ɴᴀ̃ᴏ ᴇsᴛᴀ́ ɴᴀ ʟɪsᴛᴀ*");
    
    const index = rgp.map(i => i.id).indexOf(from);
    rgp.splice(index, 1);
    fs.writeFileSync("./DADOS DO YUTA/func/tmgroup.json", JSON.stringify(rgp));
    reply("*✅ ɢʀᴜᴘᴏ ʀᴇᴍᴏᴠɪᴅᴏ ᴅᴀs ᴛʀᴀɴsᴍɪssᴏ̃ᴇs*");
}


// COMANDO LISTA DE MUTADOS
if((budy2 === 'mutelist' || budy2 === 'listamutados') && isGroup) {
if(muted[muted.map(i => i.grupo).indexOf(from)].usus.length == 0) {
return reply(`*ɴᴀᴏ ᴇxɪsᴛᴇ ɴᴇɴʜᴜᴍ ᴜsᴜᴀʀɪᴏ ᴍᴜᴛᴀᴅᴏ 🤷‍♂️*`);
}

usus__ = `ᴛᴏᴛᴀʟ: ${muted[muted.map(i => i.grupo).indexOf(from)].usus.length} - ᴍᴜᴛᴀᴅᴏs\n–\n`;  
usus__ += muted[muted.map(i => i.grupo).indexOf(from)].usus.map((v, index) => `• ${index+1} - @${v.split('@')[0]}`).join('\n');  
await mention(usus__);
}

// COMANDO MUTAR
if((budy === '🔇' || budy2 === 'mute' || budy2 === 'mutar') && isGroup) {
if(!isGroupAdmins) return reply(mess.onlyAdmins());
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());

if(!menc_os2) return reply(`*🎯 ᴘᴏʀ ғᴀᴠᴏʀ, ᴍᴇɴᴄɪᴏɴᴇ ᴏ ᴜsᴜᴀʀɪᴏ ᴏᴜ ᴍᴀʀǫᴜᴇ ᴀ ᴍᴇɴsᴀɢᴇᴍ ᴅᴏ ᴀʟᴠᴏ ǫᴜᴇ ᴠᴏᴄᴇ ᴅᴇsᴇᴊᴀ ᴍᴜᴛᴀʀ.*`);  

// Verificações de proteção  
if(menc_os2 == botNumber) return reply("*❌️️ ɴᴀᴏ ᴇ́ ᴘᴏssɪ́ᴠᴇʟ ᴍᴜᴛᴀʀ ᴏ ʙᴏᴛ! ᴠᴏᴄᴇ́ ᴇ́ ʟᴏᴜᴄᴏ?*");  
if(donosProtegidos.includes(menc_os2)) return reply("*❌ ǫᴜᴇᴍ ᴠᴏᴄᴇ́ ᴘᴇɴsᴀ ǫᴜᴇ ᴇ́, ᴘᴀʀᴀ ᴍᴜᴛᴀʀ ᴍᴇᴜ ᴘʀᴏᴘʀɪᴇᴛᴀ́ʀɪᴏ(ᴀ)?*");  
if(vip.map(i => i.id).includes(menc_os2)) return reply("*❌️️ ɴᴀᴏ ᴇ́ ᴘᴏssɪ́ᴠᴇʟ ᴍᴜᴛᴀʀ ᴜsᴜᴀ́ʀɪᴏs ǫᴜᴇ ᴄᴏɴᴛᴇ́ᴍ ᴠɪᴘ ɴᴏ ʙᴏᴛ!*");  
if(groupAdmins.includes(menc_os2)) return reply("*❌️ ɴᴀᴏ ᴇ́ ᴘᴏssɪ́ᴠᴇʟ ᴍᴜᴛᴀʀ ᴜᴍ(ᴀ) ᴀᴅᴍɪɴsᴛʀᴀᴅᴏʀ(ᴀ) ᴅᴏ ɢʀᴜᴘᴏ.*");  

if(!JSON.stringify(groupMembers).includes(menc_os2)) {  
    return reply("*❌ ɴᴀᴏ ᴇ́ ᴘᴏssɪ́ᴠᴇʟ ᴍᴜᴛᴀʀ ᴜᴍᴀ ᴘᴇssᴏᴀ ǫᴜᴇ ᴀᴛᴜᴀʟᴍᴇɴᴛᴇ ɴᴀᴏ ᴘᴀʀᴛɪᴄɪᴘᴀ ᴍᴀɪs ᴅᴇsᴛᴇ ɢʀᴜᴘᴏ.*");  
}  

if(muted[muted.map(i => i.grupo).indexOf(from)].usus.includes(menc_os2)) {  
    return mention(`*ᴏ ᴘᴀʀᴛɪᴄɪᴘᴀɴᴛᴇ: '@${menc_os2.split("@")[0]}' ᴊᴀ́ ᴇsᴛᴀ́ ɴᴀ ʟɪsᴛᴀ ᴅᴇ ᴍᴜᴛᴀᴅᴏs, ᴘᴀʀᴀ ᴅᴇsᴍᴜᴛᴀʀ ᴏ ᴜsᴜᴀ́ʀɪᴏ, ᴜsᴇ: ${prefix}ᴅᴇsᴍᴜᴛᴇ.*`);  
}  

// ADICIONA O USUÁRIO À LISTA  
mention(`*ᴏ ᴘᴀʀᴛɪᴄɪᴘᴀɴᴛᴇ '@${menc_os2.split("@")[0]}' ғᴏɪ ᴍᴜᴛᴀᴅᴏ ᴘᴇʟᴏ ᴀᴅᴍɪɴɪsᴛʀᴀᴅᴏʀ: '@${sender.split("@")[0]}'. sᴇ ᴇʟᴇ(ᴀ) ғᴀʟᴀʀ ᴀʟɢᴜᴍᴀ ᴄᴏɪsᴀ, sᴇʀᴀ́ ʀᴇᴍᴏᴠɪᴅᴏ ᴅᴏ ɢʀᴜᴘᴏ!*`);  
muted[muted.map(i => i.grupo).indexOf(from)].usus.push(menc_os2);  
fs.writeFileSync("./DADOS DO YUTA/grupos/muted.json", JSON.stringify(muted, null, 2));
}

// COMANDO DESMUTAR
if((budy2 === 'desmute' || budy2 === 'desmutar') && isGroup) {
if(!isGroupAdmins) return reply(mess.onlyAdmins());
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());

if(!menc_os2) return reply(`*🎯 ᴘᴏʀ ғᴀᴠᴏʀ, ᴍᴇɴᴄɪᴏɴᴇ ᴏ ᴜsᴜᴀ́ʀɪᴏ ᴏᴜ ᴍᴀʀǫᴜᴇ ᴀ ᴍᴇɴsᴀɢᴇᴍ ᴅᴏ ᴀʟᴠᴏ ǫᴜᴇ ᴠᴏᴄᴇ́ ᴅᴇsᴇᴊᴀ ᴅᴇsᴍᴜᴛᴀʀ.*`);  

if(!muted[muted.map(i => i.grupo).indexOf(from)].usus.includes(menc_os2)) {  
    return mention(`*ᴏ ᴘᴀʀᴛɪᴄɪᴘᴀɴᴛᴇ: '@${menc_os2.split("@")[0]}' ɴᴀᴏ ᴇsᴛᴀ́ ɴᴀ ʟɪsᴛᴀ ᴅᴇ ᴍᴜᴛᴀᴅᴏs ᴅᴏ ɢʀᴜᴘᴏ.*`);  
}  

// REMOVE O USUÁRIO DA LISTA  
mention(`*ᴏ ᴘᴀʀᴛɪᴄɪᴘᴀɴᴛᴇ '@${menc_os2.split("@")[0]}' ғᴏɪ ᴅᴇsᴍᴜᴛᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ ᴘᴇʟᴏ ᴀᴅᴍɪɴɪsᴛʀᴀᴅᴏʀ(ᴀ): '@${sender.split("@")[0]}'.*`);  
muted[muted.map(i => i.grupo).indexOf(from)].usus = muted[muted.map(i => i.grupo).indexOf(from)].usus.filter(user => user !== menc_os2);  
fs.writeFileSync("./DADOS DO YUTA/usuarios/muted.json", JSON.stringify(muted, null, 2));
}

// COMANDO BANIR
if((budy === '🚯' || budy2 === 'b' || budy2 === 'ban' || budy2 === 'banir' || budy2 === 'kick' || budy2 === 'alakazam') && isGroup) {
if(!isGroupAdmins && !SoDono) return reply(mess.onlyAdmins());
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());

try {  
    const alvo = menc_os2 || (menc_jid2 && menc_jid2[0]);  
      
    if(!alvo) return reply("*🌟 ᴍᴀʀǫᴜᴇ ᴀʟɢᴜᴇ́ᴍ ᴄᴏᴍ @ ᴏᴜ ʀᴇsᴘᴏɴᴅᴀ ᴜᴍᴀ ᴍᴇɴsᴀɢᴇᴍ*");  
      
    if(!JSON.stringify(groupMembers).includes(alvo)) {  
        return reply("*❌ ᴜsᴜᴀ́ʀɪᴏ ᴊᴀ́ sᴀɪᴜ ᴅᴏ ɢʀᴜᴘᴏ*");  
    }  
      
    if(botNumber.includes(alvo)) {  
        return reply("*🤖 ɴᴀ̃ᴏ ᴘᴏssᴏ ᴍᴇ ʙᴀɴɪʀ!*");  
    }  
      
    if(JSON.stringify(numerodono).includes(alvo)) {  
        return reply("*👑 ɴᴀ̃ᴏ ʙᴀɴɪᴍᴏs ᴏ ᴅᴏɴᴏ!*");  
    }  
      
    await yuta.groupParticipantsUpdate(from, [alvo], "remove");  
    await yuta.sendMessage(from, {  
        text: `*☠️ ʙᴀɴɪᴅᴏ: @${alvo.split('@')[0]}*`,  
        mentions: [alvo]  
    });  
      
} catch(error) {  
    console.error("ᴇʀʀᴏ ɴᴏ ʙᴀɴ:", error);  
    reply("*❌ ᴇʀʀᴏ ᴀᴏ ʙᴀɴɪʀ*");  
}
}

// COMANDO SEM PREFIXO (CITA/HIDETAG)
if((budy === '📣' || budy2 === 'cita' || budy2 === 'hidetag') && isGroup) {
    if(!isGroupAdmins) return reply(mess.onlyAdmins());

    var DFC = "";
    var rsm = info.message?.extendedTextMessage?.contextInfo?.quotedMessage;
    var pink = isQuotedImage ? rsm?.imageMessage : info.message?.imageMessage;
    var blue = isQuotedVideo ? rsm?.videoMessage : info.message?.videoMessage;
    var purple = isQuotedDocument ? rsm?.documentMessage : info.message?.documentMessage;
    var yellow = isQuotedDocW ? rsm?.documentWithCaptionMessage?.message?.documentMessage : info.message?.documentWithCaptionMessage?.message?.documentMessage;
    var aud_d = isQuotedAudio ? rsm.audioMessage : "";
    var figu_d = isQuotedSticker ? rsm.stickerMessage : "";
    var red = isQuotedMsg && !aud_d && !figu_d && !pink && !blue && !purple && !yellow ? rsm.conversation : info.message?.conversation;
    var green = rsm?.extendedTextMessage?.text || info?.message?.extendedTextMessage?.text;
    var MRC_TD = groupMembers.map(i => i.id);

    if(pink && !aud_d && !purple) {
        DFC = pink;
        pink.caption = q.length > 1 ? q : pink.caption?.replace(new RegExp(prefix+command, "gi"), ` `);
        pink.image = { url: pink.url };
        pink.mentions = MRC_TD;
    } 
    else if(blue && !aud_d && !purple) {
        DFC = blue;  
        blue.caption = q.length > 1 ? q.trim() : blue.caption?.replace(new RegExp(prefix+command, "gi"), ` `).trim();
        blue.video = { url: blue.url };
        blue.mentions = MRC_TD;
    } 
    else if(red && !aud_d && !purple) {
        DFC = { 
            text: red.replace(new RegExp(prefix+command, "gi"), ` `).trim(),
            mentions: MRC_TD 
        };
    } 
    else if(!aud_d && !figu_d && green && !purple) {
        DFC = { 
            text: green.replace(new RegExp(prefix+command, "gi"), ` `).trim(),
            mentions: MRC_TD 
        };
    } 
    else if(purple) {
        DFC = purple;
        purple.document = { url: purple.url };
        purple.mentions = MRC_TD;
    } 
    else if(yellow && !aud_d) {
        DFC = yellow;
        yellow.caption = q.length > 1 ? q.trim() : yellow.caption?.replace(new RegExp(prefix+command, "gi"), ` `).trim();
        yellow.document = { url: yellow.url };
        yellow.mentions = MRC_TD;
    } 
    else if(figu_d && !aud_d) {
        DFC = figu_d;
        figu_d.sticker = { url: figu_d.url };
        figu_d.mentions = MRC_TD;
    } 
    else if(aud_d) {
        DFC = aud_d;
        aud_d.audio = { url: aud_d.url };
        aud_d.mentions = MRC_TD;
        aud_d.ptt = true;
    }

    if(DFC) await yuta.sendMessage(from, DFC).catch(() => {});
}

// COMANDO PROMOVER
if((budy === '🆙' || budy2 === 'promover' || budy2 === 'prmv' || budy2 === 'promove') && isGroup) {
if(!isGroupAdmins) return reply(mess.onlyAdmins());
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());

if(!menc_os2 || menc_jid2[1]) {  
    return reply("*🌟 ᴍᴇɴᴄɪᴏɴᴇ ᴀ ᴍᴇɴsᴀɢᴇᴍ ᴏᴜ ᴍᴀʀǫᴜᴇ ᴜᴍ ᴜsᴜᴀ́ʀɪᴏ ᴄᴏᴍ ᴏ @ ᴅᴇʟᴇ*");  
}  

if(!JSON.stringify(groupMembers).includes(menc_os2)) {  
    return reply("*ᴇsᴛᴇ ᴜsᴜᴀ́ʀɪᴏ sᴀɪᴜ ᴅᴏ ɢʀᴜᴘᴏ ᴏᴜ ғᴏɪ ʀᴇᴍᴏᴠɪᴅᴏ 🤷‍♂️*");  
}  

try {  
    await yuta.groupParticipantsUpdate(from, [menc_os2], "promote");  
    yuta.sendMessage(from, {  
        text: `*@${menc_os2.split("@")[0]} ғᴏɪ ᴘʀᴏᴍᴏᴠɪᴅᴏ ᴀᴏ ᴄᴀʀɢᴏ ᴅᴇ ᴀᴅᴍ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*`,  
        mentions: [menc_os2]  
    });  
} catch (error) {  
    console.error("ᴇʀʀᴏ ᴀᴏ ᴘʀᴏᴍᴏᴠᴇʀ:", error);  
    reply("*❌ ᴏᴄᴏʀʀᴇᴜ ᴜᴍ ᴇʀʀᴏ ᴀᴏ ᴘʀᴏᴍᴏᴠᴇʀ ᴏ ᴜsᴜᴀ́ʀɪᴏ*");  
}
}

// COMANDO REBAIXAR
if((budy2 === '🈳' || budy2 === 'rebaixar' || budy2 === 'rbx' || budy2 === 'rebaixa') && isGroup) {
if(!isGroupAdmins) return reply(mess.onlyAdmins());
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());

if(!menc_os2 || menc_jid2[1]) {  
    return reply("*🌟 ᴍᴇɴᴄɪᴏɴᴇ ᴀ ᴍᴇɴsᴀɢᴇᴍ ᴏᴜ ᴍᴀʀǫᴜᴇ ᴜᴍ �ᴜsᴜᴀ́ʀɪᴏ ᴄᴏᴍ ᴏ @ ᴅᴇʟᴇ*");  
}  

if(!JSON.stringify(groupMembers).includes(menc_os2)) {  
    return reply("*ᴇsᴛᴇ ᴜsᴜᴀ́ʀɪᴏ sᴀɪᴜ ᴅᴏ ɢʀᴜᴘᴏ ᴏᴜ ғᴏɪ ʀᴇᴍᴏᴠɪᴅᴏ 🤷‍♂️*");  
}  

try {  
    await yuta.groupParticipantsUpdate(from, [menc_os2], "demote");  
    yuta.sendMessage(from, {  
        text: `*@${menc_os2.split("@")[0]} ғᴏɪ ʀᴇʙᴀɪxᴀᴅᴏ ᴘᴀʀᴀ ᴍᴇᴍʙʀᴏ ᴄᴏᴍᴜᴍ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*`,  
        mentions: [menc_os2]  
    });  
} catch (error) {  
    console.error("ᴇʀʀᴏ ᴀᴏ ʀᴇʙᴀɪxᴀʀ:", error);  
    reply("*❌ ᴏᴄᴏʀʀᴇᴜ ᴜᴍ ᴇʀʀᴏ ᴀᴏ ʀᴇʙᴀɪxᴀʀ ᴏ ᴜsᴜᴀ́ʀɪᴏ*");  
}
}

// PROMOVER A ADMIN
if(budy2 === 'adm' || budy2 === 'seradm' && isGroup) {
if(!SoDono) return reply(mess.onlyOwner());
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());

await yuta.sendMessage(from, {  
    text: `*@${sender.split("@")[0]} ғᴏɪ ᴘʀᴏᴍᴏᴠɪᴅᴏ ᴀᴏ ᴄᴀʀɢᴏ ᴅᴇ ᴀᴅᴍ ᴄᴏᴍ sᴜᴄᴇssᴏ 🙇‍♂️*`,  
    mentions: [sender]  
});  
await yuta.groupParticipantsUpdate(from, [sender], "promote");
}

// REMOVER ADMIN
if(budy2 === 'membro' || budy2 === 'sermembro' && isGroup) {
if(!SoDono) return reply(mess.onlyOwner());
if(!isBotGroupAdmins) return reply(mess.onlyBotAdmin());

await yuta.sendMessage(from, {  
    text: `*⚠️ @${sender.split("@")[0]}, ᴀɢᴏʀᴀ ᴠᴏᴄᴇ́ ᴇ́ ᴍᴇᴍʙʀᴏ ᴄᴏᴍᴜᴍ!*`,  
    mentions: [sender]  
});  
await yuta.groupParticipantsUpdate(from, [sender], "demote");
}

// ADVERTIR USUÁRIO
if((budy2 === 'adv' || budy2 === 'advertir' || budy2 === 'adverter') && isGroup) {
if(!isGroupAdmins) return reply(mess.onlyAdmins());
if(!menc_os2) return reply("*🌟 ᴍᴀʀǫᴜᴇ ᴏ ᴜsᴜᴀ́ʀɪᴏ*");

// Verificações  
if(menc_os2 === botNumber) return reply("*🤖 ɴᴀ̃ᴏ ᴘᴏssᴏ ᴍᴇ ᴀᴜᴛᴏ-ᴀᴅᴠᴇʀᴛɪʀ!*");  
if(numerodono.includes(menc_os2)) return reply("*👑 ɴᴀ̃ᴏ ᴀᴅᴠᴇʀᴛᴀ ᴍᴇᴜ ᴅᴏɴᴏ!*");  
if(groupAdmins.includes(menc_os2)) return reply("*⚠️ ᴀᴅᴍɪɴs ɴᴀ̃ᴏ ᴘᴏᴅᴇᴍ sᴇʀ ᴀᴅᴠᴇʀᴛɪᴅᴏs!*");  
if(!groupMembers.some(m => m.id === menc_os2)) return reply("*❌ ᴜsᴜᴀ́ʀɪᴏ ɴᴀ̃ᴏ ᴇsᴛᴀ́ ɴᴏ ɢʀᴜᴘᴏ!*");  

// Adiciona advertência  
if(!ADVT) ADVT = [];  
ADVT.push(menc_os2);  
setGp(dataGp);  

// Conta advertências  
const totalAdv = ADVT.filter(x => x === menc_os2).length;  

if(totalAdv >= 3) {  
    await yuta.sendMessage(from, {  
        text: `*🚨 @${menc_os2.split("@")[0]} ᴀᴛɪɴɢɪᴜ 3 ᴀᴅᴠᴇʀᴛᴇ̂ɴᴄɪᴀs ᴇ ғᴏɪ ʀᴇᴍᴏᴠɪᴅᴏ!*`,  
        mentions: [menc_os2]  
    });  
    await yuta.groupParticipantsUpdate(from, [menc_os2], "remove");  
    ADVT = ADVT.filter(x => x !== menc_os2);  
} else {  
    reply(`*⚠️ ᴀᴅᴠᴇʀᴛᴇ̂ɴᴄɪᴀ ${totalAdv}/3 ᴘᴀʀᴀ @${menc_os2.split("@")[0]}*`, {  
        mentions: [menc_os2]  
    });  
}
}

// REMOVER ADVERTÊNCIA
if(budy === 'rmvadv' || budy2 === 'rmadv' && isGroup) {
if(!isGroupAdmins) return reply(mess.onlyAdmins());
if(!menc_os2) return reply("*🌟 ᴍᴀʀǫᴜᴇ ᴏ ᴜsᴜᴀ́ʀɪᴏ*");

const index = ADVT.indexOf(menc_os2);  
if(index === -1) return reply("*ℹ️ ᴇsᴛᴇ ᴜsᴜᴀ́ʀɪᴏ ɴᴀ̃ᴏ ᴛᴇᴍ ᴀᴅᴠᴇʀᴛᴇ̂ɴᴄɪᴀs*");  

ADVT.splice(index, 1);  
setGp(dataGp);  
reply(`*✅ ᴀᴅᴠᴇʀᴛᴇ̂ɴᴄɪᴀ ʀᴇᴍᴏᴠɪᴅᴀ ᴅᴇ @${menc_os2.split("@")[0]}*`, {  
    mentions: [menc_os2]  
});
}

// LISTAR ADVERTÊNCIAS
if(budy === 'listadv' || budy2 === 'listaadv' && isGroup) {
if(!isGroupAdmins) return reply(mess.onlyAdmins());
const index = ADVT.indexOf(menc_os2);

const advCount = {};  
ADVT.forEach(user => {  
    advCount[user] = (advCount[user] || 0) + 1;  
});  

let lista = "*📋 ʟɪsᴛᴀ ᴅᴇ ᴀᴅᴠᴇʀᴛᴇ̂ɴᴄɪᴀs*\n\n";  
for(const [user, count] of Object.entries(advCount)) {  
    const username = user.split("@")[0];  
    lista += `• @${username} → ${count} ᴀᴅᴠᴇʀᴛᴇ̂ɴᴄɪᴀ(s)\n`, {  
    mentions: [menc_os2]  
}  
}  

if(Object.keys(advCount).length === 0) {  
    lista = "*📭 ɴᴇɴʜᴜᴍᴀ ᴀᴅᴠᴇʀᴛᴇ̂ɴᴄɪᴀ ʀᴇɢɪsᴛʀᴀᴅᴀ*", {  
    mentions: [menc_os2]  
}  
}  

await yuta.sendMessage(from, {  
    text: lista,  
    mentions: Object.keys(advCount).map(u => u)  
});
}

// ABRIR GRUPO
if(budy2 === 'a' && isGroup && isGroupAdmins && isBotGroupAdmins && groupMetadata.announce == true) {
setTimeout(() => {reagir(from, "✅")}, 300)
yuta.groupSettingUpdate(from, 'not_announcement')
reply("*ɢʀᴜᴘᴏ ᴀʙᴇʀᴛᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ sᴇɴʜᴏʀ(ᴀ) 🙇‍♂️*")
}

// FECHAR GRUPO
if(budy2 === 'f' && isGroup && isGroupAdmins && isBotGroupAdmins && groupMetadata.announce == false) {
setTimeout(() => {reagir(from, "🚫")}, 300)
yuta.groupSettingUpdate(from, 'announcement')
reply("*ɢʀᴜᴘᴏ ғᴇᴄʜᴀᴅᴏ ᴄᴏᴍ sᴜᴄᴇssᴏ sᴇɴʜᴏʀ(ᴀ) 🙇‍♂️*")
}

// AUTORIZAR ENTRADA
if((budy2 === 'autorizar' || budy2 === 'aceitar' || budy2 === '✅') && isGroup) {
if(!isGroupAdmins && !SoDono) return reply(mess.onlyAdmins());
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin);

const req = await yuta.groupRequestParticipantsList(from);  
if(req.length === 0) return reply('*❌ ɴᴀ̃ᴏ ʜᴀ́ sᴏʟɪᴄɪᴛᴀᴄ̧ᴏ̃ᴇs ᴘᴇɴᴅᴇɴᴛᴇs*');  

for(const user of req) {  
    await yuta.groupRequestParticipantsUpdate(  
        from,   
        [user.jid.includes('@') ? user.jid : `${user.jid}@s.whatsapp.net`],   
        "approve"  
    );  
}  
reply('*✅ sᴏʟɪᴄɪᴛᴀᴄ̧ᴏ̃ᴇs ᴀᴘʀᴏᴠᴀᴅᴀs!*');
}

// RECUSAR ENTRADA
if((budy2 === 'recusar' || budy2 === '❌') && isGroup) {
if(!isGroupAdmins && !SoDono) return reply(mess.onlyAdmins());
if(!isBotGroupAdmins) return reply(enviar.msg.Badmin);

const req = await yuta.groupRequestParticipantsList(from);  
if(req.length === 0) return reply('*❌ ɴᴀ̃ᴏ ʜᴀ́ sᴏʟɪᴄɪᴛᴀᴄ̧ᴏ̃ᴇs ᴘᴇɴᴅᴇɴᴛᴇs*');  

for(const user of req) {  
    await yuta.groupRequestParticipantsUpdate(  
        from,  
        [user.jid.includes('@') ? user.jid : `${user.jid}@s.whatsapp.net`],  
        "reject"  
    );  
}  
reply('*❌ sᴏʟɪᴄɪᴛᴀᴄ̧ᴏ̃ᴇs ʀᴇᴄᴜsᴀᴅᴀs!*');
}

// LISTAR SOLICITAÇÕES
if((budy2 === '📃' || budy2 === 'solicitacao' || budy2 === 'soli') && isGroup) {
if(!isGroupAdmins) return reply(mess.onlyAdmins());

const solAll = await yuta.groupRequestParticipantsList(from);  
if(!solAll || solAll.length === 0) return reply('*📭 sᴇᴍ sᴏʟɪᴄɪᴛᴀᴄ̧ᴏ̃ᴇs ᴘᴇɴᴅᴇɴᴛᴇs*');  

let formattedString = solAll.map(item =>   
    `• @${item.jid.replace('@s.whatsapp.net', '')}\n` +  
    `• ᴍᴇ́ᴛᴏᴅᴏ: ${item.request_method || 'ɴ/ᴀ'}\n` +  
    `• ᴅᴀᴛᴀ: ${new Date(item.request_time * 1000).toLocaleString()}`  
).join('\n────────\n');  

const buttons = [  
    {buttonId: 'sim', buttonText: {displayText: '✅ ᴀᴄᴇɪᴛᴀʀ'}, type: 1},  
    {buttonId: 'nao', buttonText: {displayText: '❌ ʀᴇᴄᴜsᴀʀ'}, type: 1}  
];  

await yuta.sendMessage(from, {  
    text: `*📋 sᴏʟɪᴄɪᴛᴀᴄ̧ᴏ̃ᴇs ᴘᴇɴᴅᴇɴᴛᴇs:*\n${formattedString}`,  
    footer: 'sᴇʟᴇᴄɪᴏɴᴇ ᴜᴍᴀ ᴀᴄ̧ᴀ̃ᴏ:',  
    buttons: buttons,  
    mentions: solAll.map(u => u.jid)  
});
}

// MENU PRINCIPAL
if(budy === '🐔' || budy2 === 'menu' && isGroup) {
await reagir(from, "🌟");
if (isAudioMenu) await sendAudioMenu(from);

try {  
    const menuImage = await getBuffer(`${ftmenu.logo}`);  
    if (!menuImage) throw new Error("ɪᴍᴀɢᴇᴍ ɴᴀ̃ᴏ ᴄᴀʀʀᴇɢᴀᴅᴀ");  

    await yuta.sendMessage(from, {  
        image: menuImage,  
        caption: linguagem.menu(prefix, sender, pushname, isVip, isCargo),  
        contextInfo: {  
            forwardingScore: 1,  
            isForwarded: true,  
            forwardedNewsletterMessageInfo: {  
                newsletterJid: `${setting.channelnk}`,  
                newsletterName: `${NomeDoBot}`  
            }  
        }  
    }, { quoted: selo });  
} catch(e) {  
    console.error("ᴇʀʀᴏ ɴᴏ ᴍᴇɴᴜ:", e);  
    reply("*❌ ᴇʀʀᴏ ᴀᴏ ᴄᴀʀʀᴇɢᴀʀ ᴏ ᴍᴇɴᴜ*");  
}
}

// MENU ADM
if((budy2 === 'menuadm' || budy2 === 'adminmenu') && isGroup) {
if(!isGroupAdmins && !SoDono) return reply(mess.onlyAdmins());
await reagir(from, "🎅");

try {  
    const menuadmImage = await getBuffer(`${ftmenu.logo}`);  
    await yuta.sendMessage(from, {  
        image: menuadmImage,  
        caption: linguagem.adms(prefix),  
        contextInfo: { /*...*/ }  
    }, { quoted: selo });  
} catch(e) {  
    console.error("ᴇʀʀᴏ ɴᴏ ᴍᴇɴᴜᴀᴅᴍ:", e);  
    reply("*❌ ᴇʀʀᴏ ɴᴏ ᴍᴇɴᴜ ᴅᴇ ᴀᴅᴍ*");  
}
}

// COMANDO SEM PREFIXO (MENU DONO)
if((budy2 === 'menudono' || budy2 === 'ownermenu') && isGroup) {
    if(!SoDono) return reply(mess.onlyOwner());
    await reagir(from, "❄");
    
    try {
        const menudonoImage = await getBuffer(`${ftmenu.logo}`);
        await yuta.sendMessage(from, {
            image: menudonoImage,
            caption: linguagem.menudono(prefix),
            contextInfo: { /*...*/ }
        }, { quoted: selo });
    } catch(e) {
        console.error("Erro no menudono:", e);
        reply("❌ Erro no menu de dono");
    }
}

// COMANDO SEM PREFIXO (INFO DONO)
if((budy2 === 'dono' || budy2 === 'owner') && isGroup) {
    await reagir(from, "💯");
    try {
        const thumbnail = await getBuffer(`https://files.catbox.moe/9an9o9.mp4`);
        await yuta.sendMessage(from, {
            video: thumbnail,
            caption: linguagem.dono(prefix, NomeDoBot, NumeroDoBot, ownerNumber, isBotoff, ownerName, botNumber),
            gifPlayback: true,
            contextInfo: { /*...*/ }
        }, { quoted: selo });
    } catch(e) {
        console.error("Erro no infodono:", e);
        reply("❌ Erro ao carregar informações");
    }
}

// COMANDO SEM PREFIXO (MENU LOGOS)
if((budy2 === 'logos' || budy2 === 'menulogo') && isGroup) {
    await reagir(from, "☃️");
    try {
        const menulogoImage = await getBuffer(`${ftmenu.logo}`);
        await yuta.sendMessage(from, {
            image: menulogoImage,
            caption: linguagem.menulogos(prefix),
            contextInfo: { /*...*/ }
        }, { quoted: selo });
    } catch(e) {
        console.error("Erro no menulogo:", e);
        reply("❌ Erro no menu de logos");
    }
}

if(isAutorepo) { 
if(budy2.includes("bom dia")){
    const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/bomdia.mp3');
    yuta.sendMessage(from, { audio: soundft, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}

if(budy2.includes("boa tarde")){
    const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/boatarde.mp3');
    yuta.sendMessage(from, { audio: soundft, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}

if(budy2.includes("boa noite")){
    const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/boanoite.mp3');
    yuta.sendMessage(from, { audio: soundft, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}

if(budy2.includes("bot")){
    const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/yuta.mp3');
    yuta.sendMessage(from, { audio: soundft, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}

if(budy2.includes("amo")){
    const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/amor.mp3');
    yuta.sendMessage(from, { audio: soundft, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}

if(budy2.includes("bot ruim")){
    const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/oi.mp3');
    yuta.sendMessage(from, { audio: soundft, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}

if(budy2.includes("louca")){
    const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/louca.mp3');
    yuta.sendMessage(from, { audio: soundft, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}

if(budy2.includes("prr")){
    const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/porra.mp3');
    yuta.sendMessage(from, { audio: soundft, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}

if(budy2.includes("gado")){
    const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/jack.mp3');
    yuta.sendMessage(from, { audio: soundft, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}

if(budy2.includes("gay")){
    const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/gay.mp3');
    yuta.sendMessage(from, { audio: soundft, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}

if(budy2.includes("burro")){
    const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/burro.mp3');
    yuta.sendMessage(from, { audio: soundft, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}

if(budy2.includes("lindo")){
    const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/gato.mp3');
    yuta.sendMessage(from, { audio: soundft, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}

if(budy2.includes("vt")){
    const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/cu.mp3');
    yuta.sendMessage(from, { audio: soundft, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}

if(budy2.includes("triste")){
    const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/depre.mp3');
    yuta.sendMessage(from, { audio: soundft, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}

if(budy2.includes(`@${ownerNumber}`)){
    const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/nkzin.mp3');
    yuta.sendMessage(from, { audio: soundft, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}

if(budy2.includes("e a louca")){
    const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/mulher.mp3');
    yuta.sendMessage(from, { audio: soundft, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}

if(budy2.includes("bct")){
    const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/bct.mp3');
    yuta.sendMessage(from, { audio: soundft, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}

if(budy2.includes("kkk")){
    const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/risos.mp3');
    yuta.sendMessage(from, { audio: soundft, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}

if(budy2.includes("indio")){
    const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/indio.mp3');
    yuta.sendMessage(from, { audio: soundft, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}

if(budy2.includes("mentira")){
    const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/fake.mp3');
    yuta.sendMessage(from, { audio: soundft, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}

if(budy2.includes("aff")){
    const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/meme.mp3');
    yuta.sendMessage(from, { audio: soundft, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}

if(budy2.includes("clbc")){
    const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/macaco.mp3');
    yuta.sendMessage(from, { audio: soundft, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}

if(budy2.includes("macaco")){
    const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/macaco2.mp3');
    yuta.sendMessage(from, { audio: soundft, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}

if(budy2.includes("sexo")){
    const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/websescsu.mp3');
    yuta.sendMessage(from, { audio: soundft, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}

if(budy2.includes("pai")){
    const soundft = fs.readFileSync('./DADOS DO YUTA/data/media/audios/sempai.mp3');
    yuta.sendMessage(from, { audio: soundft, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}


if(budy2.includes("bot corno")){
if(info.key.fromMe) return 
reply("*Me chamou de ruim? vou arquivar sapouha perai 😡*")
}

if(budy2.includes("adivinha meu celular") || budy2.includes("bot qual meu celular")){
yuta.sendMessage(from, {text: adivinha}, {quoted: selo})
}

if(budy2.includes("corno")){
tujuh = await fetch(corno).then(v => v.buffer())
await yuta.sendMessage(from, {audio: tujuh, mimetype: "audio/mpeg", contextInfo: { forwardingScore: 1, isForwarded: true, forwardedNewsletterMessageInfo: { newsletterJid: `${setting.channelnk}`, newsletterName: `${NomeDoBot}` 
}
}
}, 
{ quoted: selo });
}
}



if(budy2 === "prefixo") {
reply(`*ᴏᴘᴀᴀᴀᴀ, ᴀǫᴜɪ ᴇsᴛᴀ ᴏ ᴍᴇᴜ ᴘʀᴇғɪxᴏ ᴘᴀʀᴀ ᴜsᴏ ᴅᴇ ᴍᴇᴜs ᴄᴏᴍᴀɴᴅᴏs『 ${prefix} 』💁‍♂️*`)
}

//=[ ANTI PALAVRAS - (🤖) - GRUPOS ]=\\
if(isGroup && isPalavrao && isBotGroupAdmins && !SoDono && !isGroupAdmins) {
if(dataGp[0].antipalavrao.palavras.some(i => budy2.includes(i.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, "")))) {
setTimeout(() => {
if(!JSON.stringify(groupMembers).includes(sender)) return 
yuta.groupParticipantsUpdate(from, [sender], 'remove');
setTimeout(() => {yuta.sendMessage(from, {delete: { remoteJid: from, fromMe: false, id: info.key.id, participant: sender}})}, 500)
}, 2000);
yuta.sendMessage(from, {text: mess.permissionDenied_rUser()}, {quoted: selo});
}
}

if (isGroup && isSimi && budy != undefined) {
if(type == 'imageMessage') return 
if(type == 'audioMessage') return 
if(type == 'stickerMessage') return   
if(info.key.fromMe) return 
muehe = await simih(budy);
await yuta.sendMessage(from, {text: muehe}, {quoted: selo}).catch(async(e) => {
reply(mess.errorResponseSimi());
});
}

if(isCmd) {
reply("Comando errado saporr");
}
}
}
}


//=================

const nmrdn = setting.ownerNumber.replace(new RegExp("[()+-/ +/]", "gi"), "") + `@s.whatsapp.net`;

async function forTemporaryVip() {
if(vip.length > 0) {
for (y of vip) {
if(y.save != Number(moment.tz('America/Sao_Paulo').format('DD'))) {
y.save = Number(moment.tz('America/Sao_Paulo').format('DD'));
fs.writeFileSync("./DADOS DO YUTA/usuarios/vip.json", JSON.stringify(vip));
if(y.infinito == false) {
if(y.dias > 1) {
y.dias -= 1;
fs.writeFileSync("./DADOS DO YUTA/usuarios/vip.json", JSON.stringify(vip));
} else {
yuta.sendMessage(y.id, {text: `*sᴇᴜs ᴅɪᴀs ᴅᴇ ᴜsᴜᴀʀɪᴏ(ᴀ) ᴠɪᴘ ᴀᴄᴀʙᴀʀᴀᴍ 🙅‍♂️*`});
AB = vip.map(b => b.id).indexOf(y.id);
vip.splice(AB, 1);
fs.writeFileSync("./DADOS DO YUTA/usuarios/vip.json", JSON.stringify(vip));
}
}
}
}
}
}

forTemporaryVip().catch((error) => {console.log(error)});


startFunctionNaga().catch(async(error) => {
if(JSON.stringify(error).includes(API_KEY_YUTA2)) {} else if(String(error).includes("Erro: aborted")) {
fileStart = require.resolve("./connect.js");
delete require.cache[fileStart];
require(fileStart);
} else if(String(error).includes("nativeFlowResponseMessage")) {
// Para ignorar um erro contendo essa função, até a correção, está funcionando perfeitamente. //
} else { 
return console.log('O servidor-geral caiu ou não foi possivel executar esta ação.', error);
}
})
}
}

/* Atualizar o arquivo de forma automática, após o yuta.js ser salvo com uma modificação.*/
fs.watchFile(require.resolve(__filename), () => {
    fs.unwatchFile(require.resolve(__filename));
    console.log(colors.blue(`Alterações salvas, aguarde que estou carregando :) - '${__filename}'`));
    delete require.cache[require.resolve(__filename)]
    require(require.resolve(__filename))
})

module.exports = startyuta;